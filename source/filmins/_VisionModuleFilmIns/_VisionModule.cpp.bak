// _VisionModule.cpp: implementation of the C_VisionModule class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "include/_FuncModuleBasic.h"
#include "include/_FuncModuleHal.h"
#include "_VisionModuleFilmIns.h"
#include "math.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Vision Data
//////////////////////////////////////////////////////////////////////
C_VisionData::C_VisionData()
{

}

C_VisionData::~C_VisionData()
{

}

/////////////////////////////////////////////////
//Inspection function
//
BOOL C_VisionModule::FindPuchingChip(long win, Hobject *image, Hobject *image2, RECT ins_region, RECT ins_chip_region, 
									 int pf_edit_thresh, int pf_edit_tol, int pf_pitch,
									 int min_punch_area, int max_punch_area, int bur_tol, int pos_error, int pos_error2, Hobject chip_ins_region,
									 int pf_Count, BOOL *PuchErr, Hobject *rslt_region, BOOL *bCheckChip) //CHOKI20111104 pf_Count 추가
{
	//20100115LSS
	Hobject Region, ImageReduced, ConnectedRegions, SelectedRegions, RegionConvex, SelComplactRegion;
	HTuple Range, Num;

	Hobject LeftRegion, RightRegion, LeftImageReduced, RightImageReduced, LeftRsltRgn, RightRsltRgn;

	Hobject ConvxRegion;

	Hobject CheckChipRgn, InsChipRgn, ThreshChipRgn; //CHOKI20110117
	HTuple AreaCheckRgn, AreaChipRgn;//CHOKI20110117
	HTuple MeanChipArea; //CHOKI20110901

	CRect rect;

	long left, wd, ht;
	long area;
	long min;
	long i, num;
	int thresh;
	long Area;
	double CRow,CCol;
	long chip_cen_posx, chip_cen_posy;


	HTuple Row, Col, Row2, Col2, Dist;

	Hobject LeftSelectRgn, RightSelectRgn;

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*image, NULL, NULL, &wd, &ht);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_21!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	rect = ins_region;

	gen_rectangle1(&Region, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.right);

	//CHOKI20110117
	gen_rectangle1(&InsChipRgn, ins_chip_region.top, 
		                    ins_chip_region.left, 
							ins_chip_region.bottom, 
							ins_chip_region.right);
	reduce_domain(*image2,InsChipRgn,&CheckChipRgn);

	set_check("~give_error");
	herr = 	threshold(CheckChipRgn,&ThreshChipRgn,HTuple(0),HTuple(100)); //20110603 lee
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_16!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	area_center(InsChipRgn, &AreaCheckRgn, _, _);
	area_center(ThreshChipRgn, &AreaChipRgn, _, _);
	intensity(InsChipRgn, *image2, &MeanChipArea, _); //CHOKI20110901
	if(((long)AreaCheckRgn[0] * 0.2) > (long)AreaChipRgn[0])
	{
		*bCheckChip = FALSE;
	}
	else
	{
		if((long)MeanChipArea[0] < 180) //CHOKI20110901
		{
			*bCheckChip = TRUE;
		}
		else
		{
			*bCheckChip = FALSE;
		}
		
	}
	//CHOKI20110117

	//PF막힘 검사////////////////////////////////
	//검사 영역에서 PF영거만 검사 하도록 수정 //20100814 lee
	//3mm /PF : 100Pixel 로 정의 한다. 해상도 변해도 무리 없을듯..
	//35mm / 48mm / 70mm 모두 기준 위치부터 100pixel(약3mm)검사 영역 설정 
	gen_rectangle1(&LeftRegion, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.left + 100);
	left = ins_region.right - 100;
	if(0 > left)
	{
		left = 0;
	}
	gen_rectangle1(&RightRegion, ins_region.top, 
		                    left, 
							ins_region.bottom, 
							wd);

	
	reduce_domain(*image, LeftRegion, &LeftImageReduced);
	reduce_domain(*image, RightRegion, &RightImageReduced);

	thresh = 255 - pf_edit_thresh;
	if(0 > thresh)
	{
		thresh = 0;
	}
	else if(254 < thresh)//CHOKI20110603
	{
		thresh = 254;
	}

	set_check("~give_error");
	herr = threshold(LeftImageReduced, &LeftRsltRgn, HTuple(thresh), HTuple(255));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_17!... %ld", (long)thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	set_check("~give_error");
	herr = threshold(RightImageReduced, &RightRsltRgn, HTuple(thresh), HTuple(255));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_18!... %ld", (long)thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(LeftRsltRgn, &LeftRsltRgn);
	connection(RightRsltRgn, &RightRsltRgn);

	area = pf_edit_tol * pf_edit_tol;
	if(area > 2999)
	{
		area = 2999;
	}
	if(area < 0)
	{
		area = 0;
	}
	min = 45-pf_edit_tol;  //20100712 lee

	if(min > 64)
	{
		min = 64;
	}
	if(min < 0)
	{
		min = 0;
	}

	 //20100712 lee
	select_shape(LeftRsltRgn, &LeftRsltRgn, HTuple("area"), HTuple("and"), HTuple(area), HTuple(4000));
	select_shape(LeftRsltRgn, &LeftRsltRgn, HTuple("width").Concat("height"), HTuple("or"), HTuple(min).Concat(min), HTuple(70).Concat(70));
	
	select_shape(RightRsltRgn, &RightRsltRgn, HTuple("area"), HTuple("and"), HTuple(area), HTuple(4000));
	select_shape(RightRsltRgn, &RightRsltRgn, HTuple("width").Concat("height"), HTuple("or"), HTuple(min).Concat(min), HTuple(70).Concat(70));

	*PuchErr = FALSE;

	//Left

	count_obj(LeftRsltRgn, &Num);
	num = (long)Num[0];
	
	if(pf_Count > num)//if(2 > num)  //PF 수량으로 변경하여 비교해야 한다 5PF는 몇개이상?으로 //CHOKI20111104 2개 이상이면 무조건 양품이 되므로 안됨.
	{
		*PuchErr = TRUE;
	}

	num--;

	//20100810 lee
	for(i = 0; i < num-1; i++)
	{
		select_obj(LeftRsltRgn, &LeftSelectRgn, i + 1);
		area_center(LeftSelectRgn, _, &Row, &Col);

		select_obj(LeftRsltRgn, &LeftSelectRgn, i + 2);
		area_center(LeftSelectRgn, _, &Row2, &Col2);

		distance_pp(Row, Col, Row2, Col2, &Dist);

		if((1.5 * pf_pitch) < (double)Dist[0] )
		{
			*PuchErr = TRUE;
		}
	}
	
	//Right
	num = 0;
	count_obj(RightRsltRgn, &Num);
	num = (long)Num[0];
	
	if(pf_Count > num)//if(2 > num)  //PF 수량으로 변경하여 비교해야 한다 5PF는 몇개이상?으로 //CHOKI20111104 2개 이상이면 무조건 양품이 되므로 안됨.
	{
		*PuchErr = TRUE;
	}

	num--;
	//20100810 lee
	for(i = 0; i < num-1; i++)
	{
		select_obj(RightRsltRgn, &RightSelectRgn, i + 1);
		area_center(RightSelectRgn, _, &Row, &Col);

		select_obj(RightRsltRgn, &RightSelectRgn, i + 2);
		area_center(RightSelectRgn, _, &Row2, &Col2);

		distance_pp(Row, Col, Row2, Col2, &Dist);

		if( (1.5 * pf_pitch) < (double)Dist[0] )
		{
			*PuchErr = TRUE;
		}
	}

	//Punching inspection////////////////////////
	erosion_rectangle1(Region, &Region, 100, 3);

	reduce_domain(*image,Region,&ImageReduced);

	//mean_image(ImageReduced, &ImageReduced, 10, 10);

	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(Region, win);
	}

	set_check("~give_error");
#ifdef AVI_TYPE_1
	herr = threshold(ImageReduced,&Region,HTuple(190),HTuple(255)); //20100408 lee //CHOKI20110930 210->180 //CHOKI20111007 180->190	//AVI_TYPE_1//
#else	
	herr = threshold(ImageReduced,&Region,HTuple(210),HTuple(255)); //20100408 lee //CHOKI20111024 230->210 펀치미인식ㅇ로 과검출발생.	set_check("give_error");
#endif
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_19!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	//Punch 유무 검사 
	connection(Region,&ConnectedRegions);

	//원형 펀치 검사 //20100725 lee
	select_shape(ConnectedRegions,&SelectedRegions, HTuple("width").Concat("height"), HTuple("and"), HTuple(150).Concat(150), HTuple(190).Concat(190));
	select_shape(SelectedRegions,&SelectedRegions,HTuple("circularity"),HTuple("and"),HTuple(0.6),HTuple(1.0)); //20110530 lee 0.9->0.7
	count_obj(SelectedRegions, &Num);
	if(1 == (long)Num[0])  //한개 이상 있다? 그럼 원형 펀치!! 이건 위치 않보고 그냥 펀치!
	{

		//원형 Punch가 있는데 사각 Punch가 없으면 우선 불량..향후 원형만 있을 경우 조치 필요함. //20100811 lee
		//사각 펀치 검사 
		select_shape(ConnectedRegions,&SelectedRegions,HTuple("area"),HTuple("and"),HTuple(min_punch_area),HTuple(max_punch_area));
		count_obj(SelectedRegions, &Num);

		if(1 > (long)Num[0])  //아무 것도 없다? Punch가 아니다.!!
		{
			*PuchErr = TRUE;  //원형 Punch긴 하나 사각 Punch가 없으므로 편집 불량으로 간다. //20100811 lee
			return TRUE;  //Punch 면 TRUE
		}
		//Circle Punching
		return TRUE;    //Punch 면 TRUE
	}
	//원형 펀치 검사 //20100725 lee

	//사각 펀치 검사 
	select_shape(ConnectedRegions,&SelectedRegions,HTuple("area"),HTuple("and"),HTuple(min_punch_area),HTuple("max"));
	select_shape(SelectedRegions,&SelectedRegions,HTuple("rectangularity"),HTuple("and"),HTuple(0.6),HTuple("max"));
	count_obj(SelectedRegions, &Num);

	if(1 > (long)Num[0])  //아무 것도 없다? Punch가 아니다.!!
	{
		//Not Punching
		return FALSE;  //Punch 아니며 FALSE
	}

	//이하 Punch가 있는 경우 
	//punch 중심 위치와 Chip 중심 위치를 확인하여 편차발생 시 불량 
	area_center(SelectedRegions, &Area,&CRow,&CCol);

	chip_cen_posx = ins_chip_region.left + abs(ins_chip_region.right - ins_chip_region.left) / 2;
	if(abs(CCol - chip_cen_posx) > pos_error2) //CHOKI20110824
	{	
		copy_obj(SelectedRegions, rslt_region, 1, -1);//불량 표시
		*PuchErr = TRUE;
		return TRUE;  //Punch 면 TRUE
	}
	chip_cen_posy = ins_chip_region.top + abs(ins_chip_region.bottom - ins_chip_region.top) / 2; 
	if(abs(CRow - chip_cen_posy) > pos_error)
	{	
		copy_obj(SelectedRegions, rslt_region, 1, -1);//불량 표시
		*PuchErr = TRUE;
		return TRUE;  //Punch 면 TRUE
	}

	//CHOKI20110703 펀치면적기준 초과시 불량 확인
	if((long)Area > (long)max_punch_area) 
	{	
		copy_obj(SelectedRegions, rslt_region, 1, -1);//불량 표시
		*PuchErr = TRUE;
		return TRUE;  //Punch 면 TRUE
	}


	//Punch burr검사/////////////////////////////
	union1(SelectedRegions, &SelectedRegions);
	shape_trans(SelectedRegions, &ConvxRegion, "convex");
	erosion_circle(ConvxRegion, &ConvxRegion, 5.5);
	difference(ConvxRegion, SelectedRegions, &SelectedRegions);
	connection(SelectedRegions, &SelectedRegions);
	select_shape(SelectedRegions,&SelectedRegions,HTuple("area"),HTuple("and"),HTuple(bur_tol),HTuple("max"));

	union1(SelectedRegions, &SelectedRegions);
	count_obj(SelectedRegions, &Num);

	if(0 < (long)Num[0]) //
	{
		//편집 불량으로 처리 
		copy_obj(SelectedRegions, rslt_region, 1, -1);//불량 표시
		*PuchErr = TRUE;
		return TRUE;  //Punch 면 TRUE
	}
	return TRUE;
}

//20100702
//PPunch(펀칭부 검사)
BOOL C_VisionModule::FindPPuchingChip(long win, Hobject *image, RECT ins_region, 
									 int min_punch_area, int max_punch_area, int bur_tol,
									 Hobject *rslt_region)
{
	//20100115LSS
	Hobject Region, ImageReduced, ConnectedRegions, SelectedRegions, RegionConvex, SelComplactRegion;
	HTuple Range, Num;

	Hobject LeftRegion, RightRegion, LeftImageReduced, RightImageReduced, LeftRsltRgn, RightRsltRgn;

	Hobject ConvxRegion;

	CRect rect;
 
	long wd, ht;

	BOOL rslt = TRUE; 

	HTuple Row, Col, Row2, Col2, Dist;

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*image, NULL, NULL, &wd, &ht);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_22!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	rect = ins_region;

	gen_rectangle1(&Region, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.right);

	//Punching inspection////////////////////////

	reduce_domain(*image,Region,&ImageReduced);

	//mean_image(ImageReduced, &ImageReduced, 10, 10);

	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(Region, win);
	}

	//min_max_gray(Region, ImageReduced, 0, _, _, &Range);
	set_check("~give_error");
#ifdef AVI_TYPE_1
	herr = threshold(ImageReduced,&Region,HTuple(180),HTuple(255)); //20100712 lee	//AVI_TYPE_1//
#else	
	herr = threshold(ImageReduced,&Region,HTuple(160),HTuple(255)); //20100712 lee
#endif
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_20!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}


	//Punch 유무 검사 
	connection(Region,&ConnectedRegions);
	//크기는 기준의 1.5배 이상이면 불량이므로 임시로 4000000을 상한치로 설정한다. 큰 사이지는 SR 찢김으로 검출 
	//Model별  Punch Size Teaching 기능 추가 필요 
	select_shape(ConnectedRegions,&SelectedRegions,HTuple("area"),HTuple("and"),HTuple(min_punch_area),HTuple(max_punch_area));
	count_obj(SelectedRegions, &Num);

	if(1 > (long)Num[0])  //아무 것도 없다? Punch가 아니다.!!
	{
		//Not Punching
		rslt = FALSE;
		return rslt;
	}
	else
	{
		if(win)
		{
			set_color(win, HTuple("green"));
			disp_obj(SelectedRegions, win);
		}
	}

	//Punch burr검사/////////////////////////////
	union1(SelectedRegions, &SelectedRegions);
	shape_trans(SelectedRegions, &ConvxRegion, "convex");
	erosion_circle(ConvxRegion, &ConvxRegion, 5.5);
	difference(ConvxRegion, SelectedRegions, &SelectedRegions);
	connection(SelectedRegions, &SelectedRegions);
	select_shape(SelectedRegions,&SelectedRegions,HTuple("area"),HTuple("and"),HTuple(bur_tol),HTuple("max"));


	/*
	// Punch 불량 검사 : Punch 후보군의 Compactness가 크면 불량!! 4번 Iamge 사용 
	select_shape(SelectedRegions,&SelComplactRegion,HTuple("compactness"),HTuple("and"),HTuple(0),HTuple(1.9));
	count_obj(SelComplactRegion, &Num);
	*/
	union1(SelectedRegions, &SelectedRegions);
	count_obj(SelectedRegions, &Num);

	if(0 < (long)Num[0]) //
	{
		//편집 불량으로 처리 
		copy_obj(SelectedRegions, rslt_region, 1, -1);//불량 표시

		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(SelectedRegions, win);
		}

		rslt = FALSE;
	}

	return rslt;
}

//CHOKI20111013
//PPunch(펀칭부 위치 검사)
BOOL C_VisionModule::FindPPuchingChipPos(long win, Hobject *image, RECT ins_region, Hobject *rslt_region)
{
	//20100115LSS
	Hobject Region, ImageReduced, ConnectedRegions, SelectedRegions, RegionConvex, SelComplactRegion;
	HTuple Range, Num;

	Hobject LeftRegion, RightRegion, LeftImageReduced, RightImageReduced, LeftRsltRgn, RightRsltRgn;

	Hobject ConvxRegion;

	CRect rect;
 
	long wd, ht;

	BOOL rslt = TRUE; 

	HTuple Area, Row, Col, Row2, Col2, Dist;

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*image, NULL, NULL, &wd, &ht);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_22!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	rect = ins_region;

	gen_rectangle1(&Region, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.right);

	reduce_domain(*image,Region,&ImageReduced);



	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(Region, win);
	}

	
	set_check("~give_error");
	herr = threshold(ImageReduced,&Region,HTuple(0),HTuple(3)); //20100712 lee
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_2011!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	connection(Region,&ConnectedRegions);
	
	select_shape(ConnectedRegions,&SelectedRegions,HTuple("area"),HTuple("and"),HTuple(2000),HTuple(7000));
	count_obj(SelectedRegions, &Num);

	if(0 == (long)Num[0] )  //if(1 != (long)Num[0] )
	{
		//No Chip Or Error
		rslt = FALSE;
	}
	else if(1 >(long)Num[0])
	{
		rslt = FALSE;
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(SelectedRegions, win);
		}
	}
	else
	{
		area_center(SelectedRegions, &Area, &Row, &Col); 
		if((long)Col[0] > 280 && (long)Col[0] < 360)
		{
			rslt = TRUE;
			if(win)
			{
				set_color(win, HTuple("green"));
				disp_obj(SelectedRegions, win);
			}
		}
		else
		{
			rslt = FALSE;
			if(win)
			{
				set_color(win, HTuple("red"));
				disp_obj(SelectedRegions, win);
			}
		}
		
	}

	return rslt;
}
//CHOKI20111013

//CHOKI20100712
BOOL C_VisionModule::CheckPuchingChip(long win, Hobject *image, RECT ins_region, 
									 int min_punch_area, int max_punch_area, int bur_tol,
									 Hobject *rslt_region)
{
		//20100115LSS
	Hobject Region, ImageReduced, ConnectedRegions, SelectedRegions, RegionConvex, SelComplactRegion;
	HTuple Range, Num;

	Hobject LeftRegion, RightRegion, LeftImageReduced, RightImageReduced, LeftRsltRgn, RightRsltRgn;

	Hobject ConvxRegion;

	CRect rect;

	long wd, ht;
	HTuple Row, Col, Row2, Col2, Dist;

	Hobject LeftSelectRgn, RightSelectRgn;

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*image, NULL, NULL, &wd, &ht);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_23!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	rect = ins_region;

	gen_rectangle1(&Region, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.right);


	//Punching inspection////////////////////////
	erosion_rectangle1(Region, &Region, 100, 3);

	reduce_domain(*image,Region,&ImageReduced);

	//mean_image(ImageReduced, &ImageReduced, 10, 10);

	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(Region, win);
	}

	//min_max_gray(Region, ImageReduced, 0, _, _, &Range);
	set_check("~give_error");
	herr = threshold(ImageReduced,&Region,HTuple(220),HTuple(255)); //20100408 lee
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_21!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	//Punch 유무 검사 
	connection(Region,&ConnectedRegions);
	//크기는 기준의 1.5배 이상이면 불량이므로 임시로 4000000을 상한치로 설정한다. 큰 사이지는 SR 찢김으로 검출 
	//Model별  Punch Size Teaching 기능 추가 필요 
	select_shape(ConnectedRegions,&SelectedRegions,HTuple("area"),HTuple("and"),HTuple(min_punch_area),HTuple(max_punch_area));
	count_obj(SelectedRegions, &Num);

	if(1 > (long)Num[0])  //아무 것도 없다? Punch가 아니다.!!
	{
		//Not Punching
		return FALSE;
	}
	else
	{
		return TRUE;
	}
/*	Hobject Region, ImageReduced, ConnectedRegions, SelectedRegions;
	HTuple Mean, Num;

	gen_rectangle1(&Region, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.right);

	reduce_domain(*image,Region,&ImageReduced);

	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(Region, win);
	}

//	threshold(ImageReduced,&Region,HTuple(200),HTuple(255)); 
	hysteresis_threshold(ImageReduced,&Region,HTuple(200),HTuple(230),HTuple(10));
	connection(Region,&ConnectedRegions);
	select_shape(ConnectedRegions,&SelectedRegions,HTuple("area"),HTuple("and"),HTuple(200000),HTuple("max"));
	select_shape(SelectedRegions,&SelectedRegions,HTuple("compactness"),HTuple("and"),HTuple(0),HTuple(2.5));
	
	count_obj(SelectedRegions, &Num);
	if(1 > (long)Num[0])
	{
		//Not punching
		return TRUE;
	}
	else
	{
		return FALSE;
	}
	
	*/

}

//CHOKI20110725
BOOL C_VisionModule::CheckPuchingChipAuto(long win, Hobject *image, RECT ins_region, 
									 int min_punch_area, int max_punch_area, int bur_tol,
									 Hobject *rslt_region)
{
	Hobject Region, ImageReduced, ConnectedRegions, SelectedRegions, RegionConvex, SelComplactRegion;
	HTuple Range, Num;

	Hobject LeftRegion, RightRegion, LeftImageReduced, RightImageReduced, LeftRsltRgn, RightRsltRgn;

	Hobject ConvxRegion;

	CRect rect;

	long wd, ht;
	HTuple Row, Col, Row2, Col2, Dist;

	Hobject LeftSelectRgn, RightSelectRgn;

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*image, NULL, NULL, &wd, &ht);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_36!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	rect = ins_region;

	gen_rectangle1(&Region, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.right);


	//Punching inspection////////////////////////
	erosion_rectangle1(Region, &Region, 100, 3);

	reduce_domain(*image,Region,&ImageReduced);

	//mean_image(ImageReduced, &ImageReduced, 10, 10);

	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(Region, win);
	}

	//min_max_gray(Region, ImageReduced, 0, _, _, &Range);
	set_check("~give_error");
	herr = threshold(ImageReduced,&Region,HTuple(220),HTuple(255)); //20100408 lee
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_64!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	//Punch 유무 검사 
	connection(Region,&ConnectedRegions);
	//크기는 기준의 1.5배 이상이면 불량이므로 임시로 4000000을 상한치로 설정한다. 큰 사이지는 SR 찢김으로 검출 
	//Model별  Punch Size Teaching 기능 추가 필요 
	select_shape(ConnectedRegions,&SelectedRegions,HTuple("area"),HTuple("and"),HTuple(min_punch_area),HTuple(max_punch_area*2));
	count_obj(SelectedRegions, &Num);

	if(1 > (long)Num[0])  //아무 것도 없다? Punch가 아니다.!!
	{
		//Not Punching
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

BOOL C_VisionModule::FindPuchingChipSR(long win, Hobject *image, RECT ins_region)
{
	Hobject Region, ImageReduced, ConnectedRegions, SelectedRegions;
	HTuple Mean, Num;

	gen_rectangle1(&Region, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.right);

	reduce_domain(*image,Region,&ImageReduced);

	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(Region, win);
	}

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = threshold(ImageReduced,&Region,HTuple(0),HTuple(100)); //20100405 lee
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_22!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(Region,&ConnectedRegions);
	select_shape(ConnectedRegions,&SelectedRegions,HTuple("area"),HTuple("and"),HTuple(200000),HTuple("max"));
	select_shape(SelectedRegions,&SelectedRegions,HTuple("compactness"),HTuple("and"),HTuple(0),HTuple(2.5));
	
	count_obj(SelectedRegions, &Num);
	if(1 > (long)Num[0])
	{
		//Not punching
		return FALSE;
	}
	/*
	intensity(Region, ImageReduced, &Mean, _);

	if( 100 < (long)Mean[0])
	{
		return FALSE;
	}
	*/

	return TRUE;
}

BOOL C_VisionModule::FindChip(long win, Hobject *image, RECT ins_region, Hobject *rslt_chip_region)
{
	BOOL rslt = TRUE;
	long min_area, min_width, min_height;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;


	rslt = _Hal_FindChip(win, image, ins_region, rslt_chip_region,
					    min_area, min_width, min_height);

	HTuple Temp1, Temp2, Temp3, Temp4;
	smallest_rectangle1(*rslt_chip_region,&Temp1,&Temp2,&Temp3,&Temp4); //CHOKI20110504

	return rslt;
}

BOOL C_VisionModule::ChipOut(long win, Hobject *image, Hobject *image2, Hobject *image3, Hobject *image4, Hobject *image5, 
							 Hobject chip_ins_region, Hobject chip_ins_region1,
							  double offset_ox, double offset_oy, 
							  double offset_ox2, double offset_oy2, 
							  double offset_rx, double offset_ry,
							  double offset_rx2, double offset_ry2,
							  int thresh, int high_thresh, int tolerance, 
							  int mthresh, int mhigh_thresh, int mtolerance, long moutcount,//CHOKI20100714
							  long *rslt_num, Hobject *rslt_region)
{
	BOOL rslt = TRUE;
	BOOL rslt1 = TRUE;
	BOOL rslt2 = TRUE;
	BOOL rslt3 = TRUE;
	BOOL rslt4 = TRUE;
	long min_area, min_width, min_height;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;


	//CHOKI20100724 미세크랙 복원
	rslt1 = _Hal_ChipOutTop(win, image, image3, image5, chip_ins_region, chip_ins_region1,
							  offset_ox, offset_oy, 
							  offset_ox2, offset_oy2, 
							  offset_rx, offset_ry,
							  offset_rx2, offset_ry2,
							 mthresh, mhigh_thresh, mtolerance, moutcount, rslt_num, rslt_region,
							 min_area, min_width, min_height);

	rslt2 = _Hal_ChipOutBtm(win, image, image3, image5, chip_ins_region, chip_ins_region1,
							  offset_ox, offset_oy, 
							  offset_ox2, offset_oy2, 
							  offset_rx, offset_ry,
							  offset_rx2, offset_ry2,
							 mthresh, mhigh_thresh, mtolerance, moutcount, rslt_num, rslt_region,
							 min_area, min_width, min_height);

	rslt3 = _Hal_ChipOut(win, image, image5, chip_ins_region, chip_ins_region1,
							  offset_ox, offset_oy, 
							  offset_ox2, offset_oy2, 
							  offset_rx, offset_ry,
							  offset_rx2, offset_ry2,
							 thresh, high_thresh, tolerance, rslt_num, rslt_region,
							 min_area, min_width, min_height);

//	rslt4 = TRUE;  //20100729 lee
//	rslt1 = TRUE;
//	rslt2 = TRUE;
//	rslt3 = TRUE;
	rslt4 = _Hal_ChipOut2(win, image3, image2, image4, chip_ins_region, chip_ins_region1,
							  offset_ox, offset_oy, 
							  offset_ox2, offset_oy2, 
							  offset_rx, offset_ry,
							  offset_rx2, offset_ry2,
							 mthresh, mhigh_thresh, mtolerance, rslt_num, rslt_region,
							 min_area, min_width, min_height);

  //검증 필요 OVK 발생 20100728 lee

	if( rslt1 == TRUE && rslt2 == TRUE && rslt3 == TRUE && rslt4 == TRUE )
	{
		 rslt = TRUE;
	}
	else
	{
		 rslt =FALSE;
	}


	
  	return rslt;
}

BOOL C_VisionModule::_Hal_ChipOut(long win, Hobject *image, Hobject *image2, Hobject chip_ins_region, Hobject chip_ins_region1,
							  double offset_ox, double offset_oy, 
							  double offset_ox2, double offset_oy2, 
							  double offset_rx, double offset_ry,
							  double offset_rx2, double offset_ry2,
							 int thresh, int high_thresh, int tolerance, long *rslt_num, Hobject *rslt_region,
							 long min_area, long min_width, long min_height)
{
	Hobject ImageReduced, Region, RegionClosing, InsRgn, RsltRgn0, RsltRgn1, ChipRgn1, SelectRgn;
	HTuple Num;
	HTuple DiffAng, HomMat2D;
	Hobject CenterRgn0, CenterRgn1, LeftRightRgn, RsltRgn2, RsltRgn3, InsRgn2;
	
	double offset_x, offset_y;
	int tol;

	angle_ll(offset_ry, offset_rx, offset_ry2, offset_rx2, offset_oy, offset_ox, offset_oy2, offset_ox2, &DiffAng);

	offset_x = offset_rx - offset_ox;
	offset_y = offset_ry - offset_oy;

	float OffsetLengthX;

	OffsetLengthX = fabs(offset_ox-offset_ox2) - fabs(offset_rx-offset_rx2); //20110528 lee


	vector_angle_to_rigid(offset_oy, offset_ox, DiffAng, offset_ry, offset_rx+OffsetLengthX, HTuple(0), &HomMat2D);
	affine_trans_region(chip_ins_region1, &ChipRgn1, HomMat2D, HTuple("false"));

	//런타임 칩영역//////////////////////////////

	erosion_rectangle1(ChipRgn1, &InsRgn, 3, 3); 
	/////////////////////////////////////////////
	//Center/////////////////////////////////////

	if(1 > tolerance)
	{
		tol = 1;
	}
	else if(511 < tolerance)
	{
		tol = 511;
	}
	else
	{
		tol = tolerance;
	}
	
	erosion_rectangle1(InsRgn, &CenterRgn0, tol, 1);
	reduce_domain(*image, CenterRgn0, &ImageReduced);

	//CHOKI20110603
	if(thresh+10 > high_thresh)
	{
		thresh = high_thresh;
	}
	if((high_thresh + 20) >255)
	{
		high_thresh = 234;
	}

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = hysteresis_threshold(ImageReduced,&Region,HTuple(thresh),HTuple(high_thresh+20),HTuple(10));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_01!... %ld, %ld", (long)thresh, (long)high_thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(Region, &Region);
	closing_circle(Region,&RegionClosing,HTuple(3.5));

	//20100518 lss
	select_shape(RegionClosing, &RsltRgn0, HTuple("height"), HTuple("and"), HTuple(tolerance), HTuple("max"));

	//티칭시 등록된 칩영역///////////////////////
	erosion_rectangle1(ChipRgn1, &InsRgn2, 10, 10);


	if(1 > tolerance)
	{
		tol = 1;
	}
	else if(511 < tolerance)
	{
		tol = 511;
	}
	else
	{
		tol = tolerance;
	}

	erosion_rectangle1(InsRgn2, &CenterRgn1, tol, 1);
	reduce_domain(*image, CenterRgn1, &ImageReduced);

	if(thresh > high_thresh+20) thresh = high_thresh; //20110616 lee

	set_check("~give_error");
	herr = hysteresis_threshold(ImageReduced,&Region,HTuple(thresh),HTuple(high_thresh+20),HTuple(10));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_02!... %ld, %ld", (long)thresh, (long)high_thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(Region, &Region);
	closing_circle(Region,&RegionClosing,HTuple(3.5));

	//20100518 lss	
	select_shape(RegionClosing, &RsltRgn1, HTuple("height"), HTuple("and"), HTuple(tolerance), HTuple("max"));

	//20100518
	/////////////////////////////////////////////
	//LeftRight//////////////////////////////////
	//

	//20100618 lss 
	erosion_rectangle1(InsRgn, &CenterRgn0, 100, 1);
	dilation_rectangle1(CenterRgn0, &CenterRgn0, 1, 10);

	//가운데 검사영역 제거
	difference(InsRgn, CenterRgn0, &LeftRightRgn);

	//20100618 lss
	tol = tolerance;
	if(1 > tol)
	{
		tol = 1;
	}
	else if(511 < tol)
	{
		tol = 511;
	}
	
	erosion_rectangle1(LeftRightRgn, &LeftRightRgn, 1, tol);
	  
	reduce_domain(*image, LeftRightRgn, &ImageReduced);

	set_check("~give_error");
	herr = hysteresis_threshold(ImageReduced,&Region,HTuple(thresh),HTuple(high_thresh+20),HTuple(10));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_03!... %ld, %ld", (long)thresh, (long)high_thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(Region, &Region);
	closing_circle(Region,&RegionClosing,HTuple(3.5));

	select_shape(RegionClosing, &RsltRgn2, HTuple("ra"), HTuple("and"), HTuple(tolerance), HTuple("max"));

	//티칭시 등록된 칩영역///////////////////////

	//20100618 lss
	erosion_rectangle1(InsRgn2, &CenterRgn1, 100, 1);
	dilation_rectangle1(CenterRgn1, &CenterRgn1, 1, 10);

	difference(InsRgn2, CenterRgn1, &LeftRightRgn);

	//20100618 lss
	erosion_rectangle1(LeftRightRgn, &LeftRightRgn, 1, tol);

	reduce_domain(*image, LeftRightRgn, &ImageReduced);

	if(thresh > high_thresh+20) thresh = high_thresh; //20110616 lee

	set_check("~give_error");
	herr = hysteresis_threshold(ImageReduced,&Region,HTuple(thresh),HTuple(high_thresh+20),HTuple(10));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_04!... %ld, %ld", (long)thresh, (long)high_thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(Region, &Region);
	closing_circle(Region,&RegionClosing,HTuple(3.5));

	select_shape(RegionClosing, &RsltRgn3, HTuple("ra"), HTuple("and"), HTuple(tolerance), HTuple("max"));

	union2(RsltRgn0, RsltRgn1, &RsltRgn0);
	union2(RsltRgn0, RsltRgn2, &RsltRgn0); //CHOKI20110509
	union2(RsltRgn0, RsltRgn3, &RsltRgn0);

	connection(RsltRgn0, &RsltRgn0);
	count_obj(RsltRgn0, &Num);
	if(0 < (long)Num[0])
	{
		for(int i = 0; i < (long)Num[0]; i++)
		{
			select_obj(RsltRgn0, &SelectRgn, i + 1);
			select_shape(SelectRgn, &SelectRgn, HTuple("width").Concat("height"), HTuple("and"), HTuple(tolerance+2).Concat(tolerance+2), HTuple("max").Concat("max"));
			union2(SelectRgn, *rslt_region, rslt_region);
			connection(*rslt_region, rslt_region);
			count_obj(*rslt_region, &Num);
			*rslt_num += (long)Num[0];
			if(0 < (long)Num[0])
				return FALSE;
		}
	}	

	return TRUE;
}

//CHOKI20100714
BOOL C_VisionModule::_Hal_ChipOutTop(long win, Hobject *image, Hobject *image2, Hobject *image3, 
							Hobject chip_ins_region, Hobject chip_ins_region1,
							  double offset_ox, double offset_oy, 
							  double offset_ox2, double offset_oy2, 
							  double offset_rx, double offset_ry,
							  double offset_rx2, double offset_ry2,
							 int thresh, int high_thresh, int tolerance, long outcount, long *rslt_num, Hobject *rslt_region,
							 long min_area, long min_width, long min_height)
{
	Hobject ImageReduced, Region, RegionClosing, InsRgn, RsltRgn0, RsltRgn1, ChipRgn1, RegionErosion, RegionDilation;
	HTuple Num;
	HTuple DiffAng, HomMat2D;
	Hobject CenterRgn0, CenterRgn1, LeftRightRgn, RsltRgn2, RsltRgn3, InsRgn2;
	CRect ChipAreaRect; 
	long ChipAreaTop, ChipAreaCenter;

	//CHOKI20100804
	BOOL ReturnRslt=TRUE;
	Hobject SelectRgn, ResultRgn;
	HTuple Mean;
	
	double offset_x, offset_y;
	int tol;
	HTuple CRow0, CCol0, CRow1, CCol1;

	angle_ll(offset_ry, offset_rx, offset_ry2, offset_rx2, offset_oy, offset_ox, offset_oy2, offset_ox2, &DiffAng);
//	angle_ll(offset_oy, offset_ox, offset_oy2, offset_ox2, offset_ry, offset_rx, offset_ry2, offset_rx2, &DiffAng);

	offset_x = offset_rx - offset_ox;
	offset_y = offset_ry - offset_oy;

	float OffsetLengthX;

	OffsetLengthX = fabs(offset_ox-offset_ox2) - fabs(offset_rx-offset_rx2); //20110528 lee

	vector_angle_to_rigid(offset_oy, offset_ox, DiffAng, offset_ry, offset_rx+OffsetLengthX, HTuple(0), &HomMat2D);
	affine_trans_region(chip_ins_region1, &ChipRgn1, HomMat2D, HTuple("false"));

	erosion_rectangle1(ChipRgn1, &InsRgn2, 1, 1);

	tol = tolerance;

	erosion_rectangle1(InsRgn2, &CenterRgn1, 1, 1);
	dilation_rectangle1(CenterRgn1, &CenterRgn1, 1, 1);

	reduce_domain(*image, CenterRgn1, &ImageReduced);

//	emphasize(ImageReduced, &ImageReduced, 4, 4, 3);

	//CHOKI20110603
	if(thresh >= high_thresh)
	{
		thresh = high_thresh -10;
	}
	if(thresh < 0 ) 
	{
		thresh = 0;
	}
	else if(thresh > 244)
	{
		thresh = 244;
	}
	if(high_thresh < 10)
	{
		high_thresh = 10;
	}
	else if(high_thresh > 255)
	{
		high_thresh = 255;
	}


	Herror herr;
	CString status;

	set_check("~give_error");
	herr = threshold(ImageReduced,&Region,HTuple(thresh),HTuple(high_thresh));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_23!... %ld, %ld", (long)thresh, (long)high_thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}
	
	connection(Region, &Region);
	closing_circle(Region,&RegionClosing,HTuple(3.5));

	smallest_rectangle1(ImageReduced,&CRow0,&CCol0,&CRow1,&CCol1);

	ChipAreaRect.top = (long)CRow0[0];
	ChipAreaRect.bottom = (long)CRow1[0];
	ChipAreaRect.left = (long)CCol0[0];
	ChipAreaRect.right = (long)CCol1[0];

	ChipAreaTop = (long)ChipAreaRect.top;


	ChipAreaCenter = (long)(ChipAreaTop+15);//CHOKI20100802

	select_shape(RegionClosing, &RsltRgn0, HTuple("width").Concat("height"), HTuple("and"), HTuple(tolerance).Concat(tolerance), HTuple(100).Concat(20));//20110519 lee 미검 발생함. 
	select_shape(RsltRgn0, &RsltRgn0, HTuple("row"), HTuple("and"), HTuple(ChipAreaTop), HTuple(ChipAreaCenter));

	connection(RsltRgn0, &RsltRgn0);
	count_obj(RsltRgn0, &Num);

	gen_empty_obj(rslt_region);

	//CHOKI20110523 //조건 제외시 검출만 되고 이력이 남지않음
    long ResultCount;
	ResultCount = (long)Num[0];
	//CHOKI20110523

	if(outcount <= (long)Num[0])
	{
		for(int i = 0; i < (long)Num[0]; i++)//CHOKI20100804 *rslt_num->(long)Num[0]
		{
			select_obj(RsltRgn0, &SelectRgn, i + 1);
			select_shape(SelectRgn, &SelectRgn, HTuple("width").Concat("height"), HTuple("and"), HTuple(tolerance).Concat(tolerance), HTuple(100).Concat(20));
			intensity(SelectRgn, *image2, &Mean, _);
			//20110530 lee 
			if((long)Mean[0]<180)//CHOKI20110516 칩표면 수지 밝기 필터링 기준을 200->170 -> 150 //CHOKI20110523  제거 되었던 조건을 수치조정하여  재설정 140->180
			{
				union2(SelectRgn, *rslt_region, rslt_region);
				ReturnRslt = FALSE;//CHOKI20100805 if문 안쪽으로 이동
			}
		}
		connection(*rslt_region, rslt_region);
		count_obj(*rslt_region, &Num);
		*rslt_num = (long)Num[0];
		//CHOKI20110523
	}

	//CHOKI20110531
	Hobject ImageReduced530, Thresh530, RsltRgn530, RegionClosing530, RegionErosion530, RegionDilation530;
	HTuple Num530;
	long TempCount = 0;
	HTuple ChipRow, ChipCol, ChipPhi, ChipWidth, ChipHeight;
	HTuple ChipOutArea;

	erosion_rectangle1(CenterRgn1, &RegionErosion530, 4, 2); //20110601 lee

	reduce_domain(*image2, RegionErosion530, &ImageReduced530);

	set_check("~give_error");
	herr = threshold(ImageReduced530,&Thresh530,HTuple(5),HTuple(100));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_24!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	
	
	connection(Thresh530, &Thresh530);
	closing_circle(Thresh530,&RegionClosing530,HTuple(1.5));

	select_shape(RegionClosing530, &RsltRgn530, HTuple("area"), HTuple("and"), HTuple(tolerance), HTuple("max"));
	select_shape(RsltRgn530, &RsltRgn530, HTuple("height"), HTuple("and"), HTuple(2), HTuple(20)); //20110601 lee

	connection(RsltRgn530, &RsltRgn530);
	count_obj(RsltRgn530, &Num530);

	if( 0 < (long)Num530[0])
	{
		for(int i = 0; i < (long)Num530[0]; i++)
		{
			select_obj(RsltRgn530, &SelectRgn, i + 1);
			intensity(SelectRgn, *image, &Mean, _);
			smallest_rectangle2(SelectRgn, &ChipRow, &ChipCol, &ChipPhi, &ChipWidth, &ChipHeight);
			area_center(SelectRgn, &ChipOutArea, _, _);

			if(((long)Mean[0]>40  || (long)Mean[0] < 16) && (double)ChipWidth[0]*2 < 40 &&((double)ChipWidth[0]*2 >= tolerance || (double)ChipHeight[0]*2 >= tolerance ))
			{
				union2(SelectRgn, *rslt_region, rslt_region);
				ReturnRslt = FALSE;
				TempCount++;
			}
		}
		connection(*rslt_region, rslt_region);
		count_obj(*rslt_region, &Num);
		*rslt_num += TempCount;
	}
	//CHOKI20110531

	return ReturnRslt;
}

//CHOKI20100714
BOOL C_VisionModule::_Hal_ChipOutBtm(long win, Hobject *image, Hobject *image2, Hobject *image3, 
							Hobject chip_ins_region, Hobject chip_ins_region1,
							  double offset_ox, double offset_oy, 
							  double offset_ox2, double offset_oy2, 
							  double offset_rx, double offset_ry,
							  double offset_rx2, double offset_ry2,
							 int thresh, int high_thresh, int tolerance, long outcount, long *rslt_num, Hobject *rslt_region,
							 long min_area, long min_width, long min_height)
{
	Hobject ImageReduced, Region, RegionClosing, InsRgn, RsltRgn0, RsltRgn1, ChipRgn1, RegionErosion, RegionDilation;
	HTuple Num;
	HTuple DiffAng, HomMat2D;
	Hobject CenterRgn0, CenterRgn1, LeftRightRgn, RsltRgn2, RsltRgn3, InsRgn2;
	CRect ChipAreaRect; 
	long ChipAreaBtm, ChipAreaCenter;

	//CHOKI20100802
	BOOL ReturnRslt=TRUE;
	Hobject SelectRgn, ResultRgn;
	HTuple Mean;
	
	double offset_x, offset_y;
	int tol;
	HTuple CRow0, CCol0, CRow1, CCol1;

	angle_ll(offset_ry, offset_rx, offset_ry2, offset_rx2, offset_oy, offset_ox, offset_oy2, offset_ox2, &DiffAng);

	offset_x = offset_rx - offset_ox;
	offset_y = offset_ry - offset_oy;

	float OffsetLengthX;

	OffsetLengthX = fabs(offset_ox-offset_ox2) - fabs(offset_rx-offset_rx2); //20110528 lee

	//CHOKI20110527 필름의 왜곡발생으로 안하여 정상적인 영역티칭이 되지않을 경우에 Offset값을 강제로 맞춰줌
	HTuple CRowC0,CColC0,CRowC1,CColC1;
	smallest_rectangle1(chip_ins_region1,&CRowC0,&CColC0,&CRowC1,&CColC1);
    gen_rectangle1(&chip_ins_region1,(long)CRowC0[0],(long)CColC0[0],(long)CRowC1[0],(long)CColC1[0]); //CHOKI20110715
//	gen_rectangle1(&chip_ins_region1,(long)CRowC0[0],(long)CColC0[0]-OffsetLengthX,(long)CRowC1[0],(long)CColC1[0]-OffsetLengthX);
	//CHOKI20110527

	vector_angle_to_rigid(offset_oy, offset_ox, DiffAng, offset_ry, offset_rx+OffsetLengthX, HTuple(0), &HomMat2D);
//	vector_angle_to_rigid(offset_ry, offset_rx, DiffAng, offset_oy, offset_ox, HTuple(0), &HomMat2D); //CHOKI20110524 affine_trans_region의 참조값이 바꿔있어 영역을 정상적으로 찾지 못함
	affine_trans_region(chip_ins_region1, &ChipRgn1, HomMat2D, HTuple("false"));

	//	erosion_rectangle1(chip_ins_region, &InsRgn, 1, 1); 
	erosion_rectangle1(ChipRgn1, &InsRgn2, 2, 1);

	tol = tolerance;

//	erosion_rectangle1(InsRgn2, &CenterRgn1, tol, 1);//CHOKI20100810
	erosion_rectangle1(InsRgn2, &CenterRgn1, 1, 1);

	reduce_domain(*image, CenterRgn1, &ImageReduced);

//	hysteresis_threshold(ImageReduced,&Region,HTuple(thresh),HTuple(high_thresh),HTuple(10));

	//CHOKI20110603
	if(thresh >= high_thresh)
	{
		thresh = high_thresh -10;
	}
	if(thresh < 0 ) 
	{
		thresh = 0;
	}
	else if(thresh > 244)
	{
		thresh = 244;
	}
	if(high_thresh < 10)
	{
		high_thresh = 10;
	}
	else if(high_thresh > 255)
	{
		high_thresh = 255;
	}


	Herror herr;
	CString status;

	set_check("~give_error");
	herr = threshold(ImageReduced,&Region,HTuple(thresh),HTuple(high_thresh));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_25!... %ld, %ld", (long)thresh, (long)high_thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(Region, &Region);
	closing_circle(Region,&RegionClosing,HTuple(1.5));

	connection(RegionClosing, &RegionClosing);

//	erosion_rectangle1(RegionClosing, &RegionErosion, 1, 1);
	dilation_rectangle1(RegionErosion, &RegionDilation, 2, 6);

	smallest_rectangle1(ImageReduced,&CRow0,&CCol0,&CRow1,&CCol1);

//	ChipAreaBtm = (long)CRow1[0];
//	ChipAreaCenter = (long)(((long)CRow0[0]+(long)CRow1[0])/2);
	ChipAreaRect.top = (long)CRow0[0];
	ChipAreaRect.bottom = (long)CRow1[0];
	ChipAreaRect.left = (long)CCol0[0];
	ChipAreaRect.right = (long)CCol1[0];

	ChipAreaBtm = (long)ChipAreaRect.bottom;


	ChipAreaCenter = (long)(ChipAreaBtm-15);//CHOKI20100802

//	select_shape(RegionClosing, &RsltRgn0, HTuple("height"), HTuple("and"), HTuple(tolerance), HTuple(10));
//	select_shape(RegionClosing, &RsltRgn0, HTuple("width").Concat("height"), HTuple("and"), HTuple(2).Concat(tolerance), HTuple(10).Concat(10));//CHOKI20100903 Check OVK발생.
	select_shape(RegionClosing, &RsltRgn0, HTuple("width").Concat("height"), HTuple("and"), HTuple(2).Concat(tolerance), HTuple(100).Concat(20));//20110519 lee 미검 발생 Size횡으로 클겨우 있음. 
	select_shape(RsltRgn0, &RsltRgn0, HTuple("row"), HTuple("and"), HTuple(ChipAreaCenter), HTuple(ChipAreaBtm));

	Hobject select_object;
	HTuple Row1, Column1, Row2, Column2;

//	union2(RsltRgn0, RsltRgn1, &RsltRgn0);

	connection(RsltRgn0, &RsltRgn0);

	count_obj(RsltRgn0, &Num);

	//CHOKI20110523 //조건 제외시 검출만 되고 이력이 남지않음
//	*rslt_num = (long)Num[0]; 
    long ResultCount;
	ResultCount = (long)Num[0];
	//CHOKI20110523

	if(outcount <= (long)Num[0])
	{
		for(int i = 0; i < (long)Num[0]; i++)//CHOKI20100804 *rslt_num->(long)Num[0]
		{
			select_obj(RsltRgn0, &SelectRgn, i + 1);
			intensity(SelectRgn, *image2, &Mean, _);
			//20110530 lee
			if((long)Mean[0]<180) //CHOKI20110516 칩표면 수지 밝기 필터링 기준을 200->170 -> 150 //CHOKI20110523 //CHOKI20110811 제거 되었던 조건을 수치조정하여  재설정 140->180
			{
			//	union1(SelectRgn, rslt_region);
				union2(SelectRgn, *rslt_region, rslt_region);	//CHOKI20100804//CHOKI20100805

				if(win)
				{
					set_color(win, HTuple("red"));
					disp_obj(*rslt_region, win);
				}
				ReturnRslt = FALSE;//CHOKI20100805 if문 안쪽으로 이동
			}
		}
		//CHOKI20110523
		connection(*rslt_region, rslt_region); 
		count_obj(*rslt_region, &Num);
		*rslt_num = (long)Num[0]; 
		//CHOKI20110523
	}

	//CHOKI20110531
	Hobject ImageReduced530, Thresh530, RsltRgn530, RegionClosing530, RegionErosion530, RegionDilation530;
	HTuple Num530;
	long TempCount = 0;
	HTuple ChipRow, ChipCol, ChipPhi, ChipWidth, ChipHeight; //CHOKI20110616
	HTuple ChipOutArea; //CHOKI20110617

	erosion_rectangle1(CenterRgn1, &RegionErosion530, 4, 2); //20110601 lee

	reduce_domain(*image2, RegionErosion530, &ImageReduced530);
	
	set_check("~give_error");
	herr = threshold(ImageReduced530,&Thresh530,HTuple(5),HTuple(100));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_26!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	
	
	connection(Thresh530, &Thresh530);
	closing_circle(Thresh530,&RegionClosing530,HTuple(1.5));

	select_shape(RegionClosing530, &RsltRgn530, HTuple("area"), HTuple("and"), HTuple(tolerance), HTuple("max"));
	select_shape(RsltRgn530, &RsltRgn530, HTuple("height"), HTuple("and"), HTuple(2), HTuple(20)); //20110601 lee

	connection(RsltRgn530, &RsltRgn530);
	count_obj(RsltRgn530, &Num530);

	if( 0 < (long)Num530[0])
	{
		for(int i = 0; i < (long)Num530[0]; i++)
		{
			select_obj(RsltRgn530, &SelectRgn, i + 1);
			intensity(SelectRgn, *image, &Mean, _);
			smallest_rectangle2(SelectRgn, &ChipRow, &ChipCol, &ChipPhi, &ChipWidth, &ChipHeight); //CHOKI20110616
			area_center(SelectRgn, &ChipOutArea, _, _);

			if(((long)Mean[0]>40  || (long)Mean[0] < 16) && (double)ChipWidth[0]*2 < 40 &&((double)ChipWidth[0]*2 >= tolerance || (double)ChipHeight[0]*2 >= tolerance ))
			{
				union2(SelectRgn, *rslt_region, rslt_region);
				ReturnRslt = FALSE;
				TempCount++;
			}
		}
		connection(*rslt_region, rslt_region);
		count_obj(*rslt_region, &Num);
		*rslt_num += TempCount;
	}
	//CHOKI20110531

	return ReturnRslt;
	//CHOKI20100802 
}

//CHOKI20100810
BOOL C_VisionModule::_Hal_ChipOutTopBtm(long win, Hobject *image, Hobject *image2, Hobject chip_ins_region, Hobject chip_ins_region1,
							  double offset_ox, double offset_oy, 
							  double offset_ox2, double offset_oy2, 
							  double offset_rx, double offset_ry,
							  double offset_rx2, double offset_ry2,
							 int thresh, int high_thresh, int tolerance, long outcount, long *rslt_num, Hobject *rslt_region,
							 long min_area, long min_width, long min_height)
{
	Hobject ImageReduced, Region, RegionClosing, InsRgn, RsltRgn0, RsltRgn1, ChipRgn1, RegionErosion, RegionDilation;
	HTuple Num;
	HTuple DiffAng, HomMat2D;
	Hobject CenterRgn0, CenterRgn1, LeftRightRgn, RsltRgn2, RsltRgn3, InsRgn2;
	CRect ChipAreaRect; 
	long ChipAreaTop, ChipAreaBtm, ChipAreaTopCenter, ChipAreaBtmCenter;

	BOOL ReturnRslt=TRUE;
	Hobject SelectRgn, ResultRgn;
	HTuple Mean;
	
	double offset_x, offset_y;
	int tol;
	HTuple CRow0, CCol0, CRow1, CCol1;

	angle_ll(offset_ry, offset_rx, offset_ry2, offset_rx2, offset_oy, offset_ox, offset_oy2, offset_ox2, &DiffAng);

	offset_x = offset_rx - offset_ox;
	offset_y = offset_ry - offset_oy;

	vector_angle_to_rigid(offset_oy, offset_ox, DiffAng, offset_ry, offset_rx, HTuple(0), &HomMat2D);
	affine_trans_region(chip_ins_region1, &ChipRgn1, HomMat2D, HTuple("false"));

	erosion_rectangle1(ChipRgn1, &InsRgn2, 1, 1);

	tol = tolerance;

//	erosion_rectangle1(InsRgn2, &CenterRgn1, tol, 1);//CHOKI20100810
	erosion_rectangle1(InsRgn2, &CenterRgn1, 1, 1);

	//CHOKI20110603
	if(thresh >= high_thresh)
	{
		thresh = high_thresh -10;
	}
	if(thresh < 0 ) 
	{
		thresh = 0;
	}
	else if(thresh > 244)
	{
		thresh = 244;
	}
	if(high_thresh < 10)
	{
		high_thresh = 10;
	}
	else if(high_thresh > 255)
	{
		high_thresh = 255;
	}

	reduce_domain(*image, CenterRgn1, &ImageReduced);

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = threshold(ImageReduced,&Region,HTuple(thresh),HTuple(high_thresh));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_27!... %ld, %ld", (long)thresh, (long)high_thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(Region, &Region);
	closing_circle(Region,&RegionClosing,HTuple(3.5));

//	erosion_rectangle1(RegionClosing, &RegionErosion, 1, 1);
	dilation_rectangle1(RegionErosion, &RegionDilation, 2, 6);

	smallest_rectangle1(ImageReduced,&CRow0,&CCol0,&CRow1,&CCol1);

	ChipAreaRect.top = (long)CRow0[0];
	ChipAreaRect.bottom = (long)CRow1[0];
	ChipAreaRect.left = (long)CCol0[0];
	ChipAreaRect.right = (long)CCol1[0];

	ChipAreaBtm = (long)ChipAreaRect.bottom;

	ChipAreaTop = (long)ChipAreaRect.top;

	ChipAreaTopCenter = (long)(ChipAreaTop+10);
	ChipAreaBtmCenter = (long)(ChipAreaBtm-10);

	select_shape(RegionClosing, &RsltRgn0, HTuple("height"), HTuple("and"), HTuple(tolerance), HTuple(10));
	select_shape(RsltRgn0, &RsltRgn0, HTuple("row"), HTuple("and"), HTuple(ChipAreaTop), HTuple(ChipAreaTopCenter));

	select_shape(RegionClosing, &RsltRgn1, HTuple("height"), HTuple("and"), HTuple(tolerance), HTuple(10));
	select_shape(RsltRgn1, &RsltRgn1, HTuple("row"), HTuple("and"), HTuple(ChipAreaBtmCenter), HTuple(ChipAreaBtm));

	Hobject select_object;
	HTuple Row1, Column1, Row2, Column2;

//	union2(RsltRgn0, RsltRgn1, &RsltRgn0);

	connection(RsltRgn0, &RsltRgn0);

	count_obj(RsltRgn0, &Num);
	
	//CHOKI20110523 //조건 제외시 검출만 되고 이력이 남지않음
//	*rslt_num = (long)Num[0]; 
    long ResultCount;
	ResultCount = (long)Num[0];
	//CHOKI20110523

	if(outcount <= (long)Num[0])
	{
		for(int i = 0; i < (long)Num[0]; i++)
		{
			select_obj(RsltRgn0, &SelectRgn, i + 1);
			intensity(SelectRgn, *image2, &Mean, _);
			if((long)Mean[0]<200)
			{
				union2(SelectRgn, *rslt_region, rslt_region);	

				if(win)
				{
					set_color(win, HTuple("red"));
					disp_obj(*rslt_region, win);
				}
				ReturnRslt = FALSE;
			}
		}
		//CHOKI20110523
		connection(*rslt_region, rslt_region); 
		count_obj(*rslt_region, &Num);
		*rslt_num = (long)Num[0]; 
		//CHOKI20110523
	}

	return ReturnRslt;
}

//CHOKI20100722 -> 20100725
BOOL C_VisionModule::_Hal_ChipOut2(long win, Hobject *image, Hobject *image2, Hobject *image3, Hobject chip_ins_region, Hobject chip_ins_region1,
						  double offset_ox, double offset_oy, 
						  double offset_ox2, double offset_oy2, 
						  double offset_rx, double offset_ry,
						  double offset_rx2, double offset_ry2,
						 int thresh, int high_thresh, int tolerance, long *rslt_num, Hobject *rslt_region,
						 long min_area, long min_width, long min_height)
{
	Hobject ImageReduced, Region, RegionClosing, InsRgn, RsltRgn0, RsltRgn1, ChipRgn1;
	HTuple Num;
	HTuple DiffAng, HomMat2D;
	Hobject CenterRgn0, CenterRgn1, LeftRightRgn, RsltRgn2, RsltRgn3, InsRgn2;
	HTuple MeanLT, MeanLB, MeanRT, MeanRB;
	HTuple MeanLT2, MeanLB2, MeanRT2, MeanRB2, MeanChip;
	Hobject LTRgnintensity, LBRgnintensity, RTRgnintensity, RBRgnintensity;
	Hobject InLTRgn0, InLBRgn0, InRTRgn0, InRBRgn0;//CHOKI20100810
	Hobject LTRgn0, LBRgn0, RTRgn0, RBRgn0;
	Hobject LTRgn1, LBRgn1, RTRgn1, RBRgn1;
	Hobject LTReduced, LBReduced, RTReduced, RBReduced;
	Hobject LTRsltRgn, LBRsltRgn, RTRsltRgn, RBRsltRgn, RegionTot;
//	CRect ChipAreaRect; 
	HTuple CRow0, CCol0, CRow1, CCol1;
	HTuple CRow3, CCol3, Phi3, ChipHeight3, ChipWidth3;//CHOKI20100810

	//CHOKI20110511
	Hobject SelectRgn;
	HTuple Mean;
	BOOL ReturnRslt;

	smallest_rectangle1(chip_ins_region1, &CRow0, &CCol0, &CRow1, &CCol1);


	//CHOKI20100725
	CRect ChipLTRect; 
	CRect ChipLBRect; 
	CRect ChipRTRect; 
	CRect ChipRBRect; 

	//CHOKI20100810
	CRect InChipLTRect; 
	CRect InChipLBRect; 
	CRect InChipRTRect; 
	CRect InChipRBRect; 
	
	double offset_x, offset_y;
//	int tol;

	angle_ll(offset_ry, offset_rx, offset_ry2, offset_rx2, offset_oy, offset_ox, offset_oy2, offset_ox2, &DiffAng);

	offset_x = offset_rx - offset_ox;
	offset_y = offset_ry - offset_oy;

	float OffsetLengthX;

	OffsetLengthX = fabs(offset_ox-offset_ox2) - fabs(offset_rx-offset_rx2); //CHOKI20110715

	vector_angle_to_rigid(offset_oy, offset_ox, DiffAng, offset_ry, offset_rx+OffsetLengthX, HTuple(0), &HomMat2D);
//	vector_angle_to_rigid(offset_ry, offset_rx, DiffAng, offset_oy, offset_ox, HTuple(0), &HomMat2D); //CHOKI20110524 affine_trans_region의 참조값이 바꿔있어 영역을 정상적으로 찾지 못함


	smallest_rectangle1(chip_ins_region1,&CRow0,&CCol0,&CRow1,&CCol1);

	InChipLTRect.top = (long)CRow0[0]+1;
	InChipLTRect.bottom = (long)CRow0[0]+6;
	InChipLTRect.left = (long)CCol0[0]+1;//-OffsetLengthX; //CHOKI20110711
	InChipLTRect.right = (long)CCol0[0]+6;//-OffsetLengthX; //CHOKI20110711
	
	InChipLBRect.top = (long)CRow1[0]-6;
	InChipLBRect.bottom = (long)CRow1[0]-1;
	InChipLBRect.left = (long)CCol0[0]+1;//-OffsetLengthX; //CHOKI20110711
	InChipLBRect.right = (long)CCol0[0]+6;//-OffsetLengthX; //CHOKI20110711
	
	InChipRTRect.top = (long)CRow0[0]+1;
	InChipRTRect.bottom = (long)CRow0[0]+6;
	InChipRTRect.left = (long)CCol1[0]-6-OffsetLengthX;
	InChipRTRect.right = (long)CCol1[0]-1-OffsetLengthX;
	
	InChipRBRect.top = (long)CRow1[0]-6;
	InChipRBRect.bottom = (long)CRow1[0]-1;
	InChipRBRect.left = (long)CCol1[0]-6-OffsetLengthX;
	InChipRBRect.right = (long)CCol1[0]-1-OffsetLengthX;


	gen_rectangle1(&InLTRgn0, InChipLTRect.top, InChipLTRect.left, InChipLTRect.bottom, InChipLTRect.right);
//	dilation_rectangle1(InLTRgn0, &InLTRgn0, 2, 2);
	
	gen_rectangle1(&InLBRgn0, InChipLBRect.top, InChipLBRect.left, InChipLBRect.bottom, InChipLBRect.right);
//	dilation_rectangle1(InLBRgn0, &InLBRgn0, 2, 2);
	
	gen_rectangle1(&InRTRgn0, InChipRTRect.top, InChipRTRect.left, InChipRTRect.bottom, InChipRTRect.right);
//	dilation_rectangle1(InRTRgn0, &InRTRgn0, 2, 2);

	gen_rectangle1(&InRBRgn0, InChipRBRect.top, InChipRBRect.left, InChipRBRect.bottom, InChipRBRect.right);
//	dilation_rectangle1(InRBRgn0, &InRBRgn0, 2, 2);

	affine_trans_region(InLTRgn0, &LTRgn0, HomMat2D, HTuple("false"));
	affine_trans_region(InLBRgn0, &LBRgn0, HomMat2D, HTuple("false"));
	affine_trans_region(InRTRgn0, &RTRgn0, HomMat2D, HTuple("false"));
	affine_trans_region(InRBRgn0, &RBRgn0, HomMat2D, HTuple("false"));
	//CHOKI20100810

	reduce_domain(*image, LTRgn0, &LTReduced);
	reduce_domain(*image, LBRgn0, &LBReduced);
	reduce_domain(*image, RTRgn0, &RTReduced);
	reduce_domain(*image, RBRgn0, &RBReduced);
	
	//CHOKI20110510
	gen_empty_obj(&LTRsltRgn);
	gen_empty_obj(&LBRsltRgn);
	gen_empty_obj(&RTRsltRgn);
	gen_empty_obj(&RBRsltRgn);

	intensity(LTRgn0, *image, &MeanLT, _);//CHOKI20100727
	if((long)MeanLT[0] < 200)
	{
		Herror herr;
		CString status;

		set_check("~give_error");
		herr = threshold(LTReduced,&LTRgn1,HTuple(5),HTuple(140)); //CHOKI20110725
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_28!");
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}

		connection(LTRgn1, &LTRgn1);
		select_shape(LTRgn1, &LTRsltRgn, HTuple("area"), HTuple("and"), HTuple(15), HTuple("max"));
		select_shape(LTRsltRgn, &LTRsltRgn, HTuple("width"), HTuple("and"), HTuple(3), HTuple("max"));//CHOKI20100903
	}


	intensity(LBRgn0, *image, &MeanLB, _);//CHOKI20100727
	if((long)MeanLB[0] < 200)
	{
		Herror herr;
		CString status;

		set_check("~give_error");
		herr = threshold(LBReduced,&LBRgn1,HTuple(5),HTuple(140)); //CHOKI20110725
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_29!");
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}	
	
		connection(LBRgn1, &LBRgn1);
		select_shape(LBRgn1, &LBRsltRgn, HTuple("area"), HTuple("and"), HTuple(15), HTuple("max"));
		select_shape(LBRsltRgn, &LBRsltRgn, HTuple("width"), HTuple("and"), HTuple(3), HTuple("max"));//CHOKI20100903


	}

	intensity(RTRgn0, *image, &MeanRT, _);//CHOKI20100727
	if((long)MeanRT[0] < 200)
	{
		Herror herr;
		CString status;

		set_check("~give_error");
		herr = threshold(RTReduced,&RTRgn1,HTuple(5),HTuple(140)); //CHOKI20110725
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_30!");
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}
		
		connection(RTRgn1, &RTRgn1);
		select_shape(RTRgn1, &RTRsltRgn, HTuple("area"), HTuple("and"), HTuple(15), HTuple("max"));
		select_shape(RTRsltRgn, &RTRsltRgn, HTuple("width"), HTuple("and"), HTuple(3), HTuple("max"));//CHOKI20100903
	}


	intensity(RBRgn0, *image, &MeanRB, _);//CHOKI20100727
	if((long)MeanRB[0] < 200)
	{
		Herror herr;
		CString status;

		set_check("~give_error");
		herr = threshold(RBReduced,&RBRgn1,HTuple(5),HTuple(140)); //CHOKI20110725
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_31!");
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}
		
		connection(RBRgn1, &RBRgn1);
		select_shape(RBRgn1, &RBRsltRgn, HTuple("area"), HTuple("and"), HTuple(15), HTuple("max"));
		select_shape(RBRsltRgn, &RBRsltRgn, HTuple("width"), HTuple("and"), HTuple(3), HTuple("max"));//CHOKI20100903
	}

	gen_empty_obj(&RegionTot);
	union2(LTRsltRgn,RegionTot,&RegionTot);//CHOKI20100805 분리
	union2(LBRsltRgn,RegionTot,&RegionTot);
	union2(RTRsltRgn,RegionTot,&RegionTot);
	union2(RBRsltRgn,RegionTot,&RegionTot);

	ReturnRslt = TRUE;

	connection(RegionTot, &RegionTot);
	count_obj(RegionTot, &Num);
	
	//CHOKI20110523 //조건 제외시 검출만 되고 이력이 남지않음
//	*rslt_num = (long)Num[0]; 
    long ResultCount;
	ResultCount = (long)Num[0];
	//CHOKI20110523

	if(0 < (long)Num[0])
	{
		for(int i = 0; i < (long)Num[0]; i++)
		{
			select_obj(RegionTot, &SelectRgn, i + 1);   //CHOKI20110512 Down
			intensity(SelectRgn, *image2, &Mean, _);
			if((long)Mean[0]>50)  //CHOKI20110618 //CHOKI20110811 칩연마흔적으로 인한 과검으로 수치조정 40->50
			{
				union2(*rslt_region,SelectRgn, rslt_region);	
				
				if(win)
				{
					set_color(win, HTuple("red"));
					disp_obj(*rslt_region, win);
				}
				ReturnRslt = FALSE;
			}
		}
		//CHOKI20110523
		connection(*rslt_region, rslt_region); 
		count_obj(*rslt_region, &Num);
		*rslt_num = (long)Num[0]; 
		//CHOKI20110523
	}
	return ReturnRslt;
}

BOOL C_VisionModule::ChipMold(long win, Hobject *image, Hobject *broken_image, Hobject chip_ins_region,
							  double offset_ox, double offset_oy, 
							  double offset_ox2, double offset_oy2, 
							  double offset_rx, double offset_ry,
							  double offset_rx2, double offset_ry2,
							  int thresh, int high_thresh, int tolerance, int broken_thresh, 
							  long *rslt_num, Hobject *rslt_region, long *rslt_broken_num, Hobject *rslt_broken_region)
{
	BOOL rslt = TRUE;
	long min_area, min_width, min_height;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;


	rslt = _Hal_ChipMold(win, image, broken_image, chip_ins_region, 
							  offset_ox, offset_oy, 
							  offset_ox2, offset_oy2, 
							  offset_rx, offset_ry,
							  offset_rx2, offset_ry2,
							  thresh, high_thresh, tolerance, broken_thresh, 
							  rslt_num, rslt_region, rslt_broken_num, rslt_broken_region,
							  min_area, min_width, min_height);

	return rslt;	



}

BOOL  C_VisionModule::_Hal_ChipMold(long win, Hobject *image, Hobject *broken_image, Hobject chip_ins_region, 
							  double offset_ox, double offset_oy, 
							  double offset_ox2, double offset_oy2, 
							  double offset_rx, double offset_ry,
							  double offset_rx2, double offset_ry2,
							  int thresh, int high_thresh, int tolerance, int broken_thresh, 
							  long *rslt_num, Hobject *rslt_region, long *rslt_broken_num, Hobject *rslt_broken_region,
							  long min_area, long min_width, long min_height)
{
	BOOL rslt = TRUE;
	Hobject ImageReduced, Region, RegionClosing, InsRegion, Line, Image;
	HTuple Num, Area;
	long chip_area, tol_area;
	HTuple RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond, ColumnEdgeSecond, AmplitudeSecond, MeasureHandle, IntraDistance, InterDistance;

	long row, col, leng1, height;
	HTuple Row0, Column0;
	RECT ins_region;
	HTuple Width, Height;

	Hobject RsltRgn, RsltBrokenRgn, ChipRgn1;

	HTuple DiffAng, HomMat2D;
	double offset_x, offset_y;

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*image, _, _, &Width, &Height);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_24!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	gen_empty_obj(&RsltRgn);
	gen_empty_obj(&RsltBrokenRgn);

	angle_ll(offset_ry, offset_rx, offset_ry2, offset_rx2, offset_oy, offset_ox, offset_oy2, offset_ox2, &DiffAng);
	
	offset_x = offset_rx - offset_ox;
	offset_y = offset_ry - offset_oy;
	
	vector_angle_to_rigid(offset_oy, offset_ox, DiffAng, offset_ry, offset_rx, HTuple(0), &HomMat2D);
	affine_trans_region(chip_ins_region, &ChipRgn1, HomMat2D, HTuple("false"));
	
	//Mold칩 이면 결함. //////////////////////////////////////
	erosion_rectangle1(ChipRgn1, &InsRegion, 5, 5);
	reduce_domain(*image, InsRegion, &ImageReduced);

	//CHOKI20110603
	if(thresh >= high_thresh)
	{
		thresh = high_thresh -10;
	}
	if(thresh < 0 ) 
	{
		thresh = 0;
	}
	else if(thresh > 244)
	{
		thresh = 244;
	}
	if(high_thresh < 10)
	{
		high_thresh = 10;
	}
	else if(high_thresh > 255)
	{
		high_thresh = 255;
	}

	set_check("~give_error");
#ifdef AVI_TYPE_1
	herr = threshold(ImageReduced,&Region,HTuple(thresh),HTuple(high_thresh+30));	//CHOKI20111024 기준이미지를 1->0으로 변경하면서 기준값을 +30	//AVI_TYPE_1//
#else
	herr = threshold(ImageReduced,&Region,HTuple(thresh),HTuple(high_thresh));
#endif
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_32!... %ld, %ld", (long)thresh, (long)high_thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(Region, &Region);
	closing_circle(Region,&RegionClosing,HTuple(3.5));

	area_center(chip_ins_region, &Area, _, _);
	chip_area = (long)Area[0];

	if(0 == tolerance)
	{
		tol_area = min_area;
	}
	else
	{
		tol_area = (long)( ((double)chip_area) * (tolerance * 0.01) );
	}

	select_shape(RegionClosing, &RsltRgn, HTuple("area"), HTuple("and"), HTuple(1),  HTuple("max"));
	select_shape(RsltRgn, &RsltRgn, HTuple("compactness"), HTuple("and"), HTuple(1),  HTuple(20));
	
	connection(RsltRgn, &RsltRgn);

	Hobject select_object;
	HTuple Row1, Column1, Row2, Column2;

	count_obj(RsltRgn, &Num);

	if(0 < (long)Num[0])
	{
		union1(RsltRgn, &RsltRgn);
		area_center(RsltRgn, &Area, _, _);
		if(tol_area < (long)Area[0])
		{
			if(win)
			{
				set_color(win, HTuple("red"));
				disp_obj(RsltRgn, win);
			}

			
			*rslt_num = 1;

			rslt = FALSE;
		}
		else
		{
			*rslt_num = 0;

		}
	}

	copy_obj(RsltRgn, rslt_region, 1, -1);

	//Broken/////////////////////////////////////
	mean_image(*broken_image, &Image, 1, 20);
	emphasize(Image, &Image, 5, 3, 5);

	if(win)
	{
		disp_obj(Image, win);
	}

	smallest_rectangle1(InsRegion, &Row0, &Column0, &Row1, &Column1);

	ins_region.left = (long)Column0[0];
	ins_region.top = (long)Row0[0];
	ins_region.right = (long)Column1[0];
	ins_region.bottom = (long)Row1[0];

	row = (ins_region.top + ins_region.bottom) * 0.5;
	col = (ins_region.left + ins_region.right) * 0.5;
	leng1 = (ins_region.right - ins_region.left) * 0.4;
	height = (ins_region.bottom - ins_region.top) * 0.4;

	*rslt_broken_num = 0;
	gen_measure_rectangle2(row,col,HTuple(0),leng1,height,Width,Height,HTuple("nearest_neighbor"),&MeasureHandle);

	measure_pairs(Image, MeasureHandle, HTuple(1), HTuple(broken_thresh), HTuple("negative"), HTuple("all"),
			            &RowEdgeFirst,&ColumnEdgeFirst,&AmplitudeFirst,  
						&RowEdgeSecond,&ColumnEdgeSecond,&AmplitudeSecond,
						&IntraDistance, &InterDistance);


	//20100416 lee
	long edgeCnt;

	edgeCnt = RowEdgeFirst.Num();

	if( (0 < RowEdgeFirst.Num()) && (2 > RowEdgeFirst.Num()) ) //너무 많으면 broken이 아니라 chip grind가 잘못된것->양품처리
	{
		//gen_region_points(&Line, RowEdgeFirst,ColumnEdgeFirst);
		gen_region_line(&Line, RowEdgeFirst, ColumnEdgeFirst, RowEdgeSecond,ColumnEdgeSecond);

		connection(Line, &Line);
		select_shape(Line, &Line, HTuple("area"), HTuple("and"), HTuple(1),  HTuple(5));
		count_obj(Line, &Num);
		
		if(0 < (long)Num[0])
		{
			union2(RsltBrokenRgn, Line, &RsltBrokenRgn);

			*rslt_broken_num = 1;
			if(win)
			{
				set_color(win, HTuple("red"));
				disp_obj(RsltBrokenRgn, win);
			}
			rslt = FALSE;
		}
	}

	copy_obj(RsltBrokenRgn, rslt_broken_region, 1, -1);

	close_measure(MeasureHandle);

	return rslt;
}

//5 0 부분
//6 6
//1 3 못잡았다
BOOL C_VisionModule::PotPart(long win, Hobject *image, Hobject *image2, Hobject *crack_image, Hobject *over_resin,
							 RECT ChipFindArea, Hobject chip_ins_region, Hobject pot_ins_region, Hobject sr_region,
							 double offset_ox, double offset_oy, 
							 double offset_ox2, double offset_oy2, 
							 double offset_rx, double offset_ry,
							 double offset_rx2, double offset_ry2,
							 int part_thresh, int part2_thresh, int high_thresh, int tolerance, int tolerance_hide_part, int range_tolerance, int black_pot_tol, int black_thresh,
							 long *rslt_num, Hobject *rslt_region, long *range_rslt_num, Hobject *range_rslt_region, Hobject *recog_ins_rslt_region)
{
	//BOOL rslt = TRUE;
	long min_area, min_width, min_height, recog_dist, min_area_sr, min_width_sr, min_height_sr;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;
	recog_dist = RECOG_DIST;
	min_area_sr = VISION_FACT_MIN_AREA_SR;
	min_width_sr = VISION_FACT_MIN_WIDTH_SR;
	min_height_sr = VISION_FACT_MIN_HEIGHT_SR;


	BOOL rslt = TRUE;
	Hobject ImageReduced, Region, RegionClosing, DilationRegion, ImageReduced2, Region2;
	HTuple Num;
	Hobject FillRegion, RangeRegion, ConvRegion;
	HTuple Row0, Col0, Row1, Col1;
	Hobject RecogRgn;
	Hobject PotBlackPart, RlstPotBlackPart;

	Hobject OutRgn, SelectRgn, ResultRgn;
	HTuple Mean, OutMean;
	Hobject ComplRgn;
	Hobject PosChkRgnTop, PosChkRgnRight, PosChkRgnBottom, PosChkRgnLeft;
	HTuple AreaTop, AreaBottom, AreaLeft, AreaRight;

	Hobject SRRegion, RecogRegion, RsltRegion, RangeRsltRegion, RecogRsltRegion;

	Hobject Pot2InsRgn, Pot2RsltRgn, Pot2ImageReduced, Pot2FillRegion, Pot2DilationRegion;

	HTuple HomMat2D, DiffAng, Area;

	angle_ll(offset_ry, offset_rx, offset_ry2, offset_rx2, offset_oy, offset_ox, offset_oy2, offset_ox2, &DiffAng);

	vector_angle_to_rigid(offset_oy, offset_ox, DiffAng, offset_ry, offset_rx, HTuple(0), &HomMat2D);
	affine_trans_region(sr_region, &SRRegion, HomMat2D, HTuple("false"));

	//CHOKI20110702 수지도포 초과
	Hobject ChipFindAreaTemp, ChipFindAreaRgn;
	Hobject ChipInsRgn, PotInsRgn;
	Hobject OverPotReduce, OverPotThrash, OverPotDilation, OverPotDiffrence, OverPotResult;
	HTuple OverArea;
	gen_rectangle1(&ChipFindAreaTemp, ChipFindArea.top, ChipFindArea.left, ChipFindArea.bottom, ChipFindArea.right);
//	affine_trans_region(chip_ins_region, &ChipInsRgn, HomMat2D, HTuple("false"));
//	affine_trans_region(pot_ins_region, &PotInsRgn, HomMat2D, HTuple("false"));
	affine_trans_region(ChipFindAreaTemp, &ChipFindAreaRgn, HomMat2D, HTuple("false"));

#ifdef AVI_TYPE_1
	dilation_rectangle1(ChipFindAreaRgn, &OverPotDilation, 30, 50); //CHOKI20110925 50->30 x축의 경우 패턴의 영향으로 너무 넓게 확장 안됨	//AVI_TYPE_1//
#else
	dilation_rectangle1(ChipFindAreaRgn, &OverPotDilation, 50, 50);
#endif
	difference(OverPotDilation, ChipFindAreaRgn, &OverPotDiffrence);
	reduce_domain(*over_resin, OverPotDiffrence, &OverPotReduce); 

	Herror herr;
	CString status;

	set_check("~give_error");
#ifdef AVI_TYPE_1	
	herr = threshold(OverPotReduce,&OverPotThrash,HTuple(5),HTuple(140)); //CHOKI20110704 110->105	//110802 85 -> 70 //CHOKI20110925 70->110 약한 수지 넘침을 잡을 경우 과검 다량 발생		//AVI_TYPE_1//
#else
	herr = threshold(OverPotReduce,&OverPotThrash,HTuple(5),HTuple(60)); //CHOKI20110704 110->105	//110802 85 -> 70	set_check("give_error"); //CHOKI20110926 110->140
#endif
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_33!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	
	//AVI_TYPE_1//>>>>>>>>>>>>>>>>>>>>
#ifdef AVI_TYPE_1
	connection(OverPotThrash, &OverPotThrash);		

	select_shape(OverPotThrash, &OverPotResult, HTuple("area"), HTuple("and"), HTuple(range_tolerance),  HTuple("max"));
//	connection(OverPotResult, &OverPotResult);
	count_obj(OverPotResult, &Num);
	area_center(OverPotResult, &OverArea, _, _);

	//CHOKI20110928
	long CountNum=0;
	long CuntNumCheck = 0;
	Hobject TempResult;
	gen_empty_obj(&TempResult);
	CountNum = (long)Num[0];
	*range_rslt_num = 0;
	if(0 < CountNum)
	{
		for(int i = 0; i < CountNum; i++)
		{
			select_obj(OverPotResult, &SelectRgn, i + 1);
			
			intensity(SelectRgn, *crack_image, &OutMean, _);

			if((long)OutMean[0] < 110)
			{
				CuntNumCheck++;

				union2(TempResult, SelectRgn, &TempResult);

				if(0 < *range_rslt_num)
				{
					if(win)
					{
						set_color(win, HTuple("red"));
						disp_obj(TempResult, win);
					}
				}
				
				rslt = FALSE;	
			}
		}
		*range_rslt_num = CuntNumCheck;
	}

	copy_obj(TempResult, range_rslt_region, 1, -1);
	//CHOKI20110702
	//CHOKI20110928
	//AVI_TYPE_1//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#else
	select_shape(OverPotThrash, &OverPotResult, HTuple("area"), HTuple("and"), HTuple(range_tolerance),  HTuple("max"));
//	connection(OverPotResult, &OverPotResult);
	count_obj(OverPotResult, &Num);
	area_center(OverPotResult, &OverArea, _, _);

	*range_rslt_num = (long)Num[0];

	if(0 < *range_rslt_num)
	{
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(OverPotResult, win);
		}
		
		rslt = FALSE;
	}

	copy_obj(OverPotResult, range_rslt_region, 1, -1);
#endif
	return rslt;

}

/////////// Masterimage: GetHalRefRedImage(cam_idx, 1),  image2: GetHalRedImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[6])
//CHOKI20100811
BOOL C_VisionModule::PotPart2(long win, Hobject *Masterimage, Hobject *image, Hobject *image2, 
							  Hobject *crack_image, Hobject *image5, //CHOKI20110619
							  Hobject *image6, //CHOKI201107010
							  Hobject *RefGreenImage, //CHOKI20110824
							  Hobject chip_ins_region, RECT ins_region, Hobject pot_ins_region,
							 double offset_ox, double offset_oy, 
							 double offset_ox2, double offset_oy2, 
							 double offset_rx, double offset_ry,
							 double offset_rx2, double offset_ry2,
							 int part_thresh, int part2_thresh, int high_thresh, int tolerance, int tolerance_hide_part, int range_tolerance, int black_pot_tol, int black_thresh,
							 long *rslt_num, Hobject *rslt_region, long *range_rslt_num, Hobject *range_rslt_region, Hobject *recog_ins_rslt_region)
{
	long min_area, min_width, min_height, recog_dist, min_area_sr, min_width_sr, min_height_sr;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;
	recog_dist = RECOG_DIST;
	min_area_sr = VISION_FACT_MIN_AREA_SR;
	min_width_sr = VISION_FACT_MIN_WIDTH_SR;
	min_height_sr = VISION_FACT_MIN_HEIGHT_SR;


	BOOL rslt = TRUE;
	Hobject ImagePotReduced, ImageMastertReduced, SubReduced, Region, RegionClosing, DilationRegion, ImageReduced2, Region2;
	HTuple Num;
	Hobject FillRegion, RangeRegion, ConvRegion;
	HTuple Row0, Col0, Row1, Col1;
	Hobject RecogRgn;
	Hobject Test1, 	test2;
	Hobject InverPot, InverMaster;
	Hobject erosionRegion;
	Hobject AlignRegion;
	Hobject MasterImageRegion, PotImageRegion;

	Hobject OutRgn, SelectRgn, ResultRgn;
	HTuple Mean, OutMean;

	Hobject ChipRegion, PotRegion, RecogRegion, RsltRegion;
	Hobject PotRegion2; //CHOKI20110619

	Hobject Pot2InsRgn, Pot2RsltRgn, Pot2ImageReduced, Pot2FillRegion, Pot2DilationRegion;
	Hobject threshImageMaster, threshImagePot;

	HTuple HomMat2D, DiffAng, Area;

	angle_ll(offset_ry, offset_rx, offset_ry2, offset_rx2, offset_oy, offset_ox, offset_oy2, offset_ox2, &DiffAng);

	//Chip 영역 회전 
	vector_angle_to_rigid(offset_oy, offset_ox, DiffAng, offset_ry, offset_rx, HTuple(0), &HomMat2D);

	//Pot 검사 영역 생성 
	gen_rectangle1(&PotRegion, ins_region.top, ins_region.left, ins_region.bottom, ins_region.right);
	affine_trans_region(PotRegion, &PotRegion2, HomMat2D, HTuple("false"));//CHOKI20110619
	
	//CHOKI20110215
	Hobject PotRgn, ThreshPotRgn, SelectPotRgn; 
	reduce_domain(*crack_image, PotRegion, &PotRgn);

	Herror herr;
	CString status;

	set_check("~give_error");
#ifdef AVI_TYPE_1
	herr = threshold(PotRgn,&ThreshPotRgn,HTuple(190),HTuple(255)); //CHOKI20110725		//AVI_TYPE_1//
#else
	herr = threshold(PotRgn,&ThreshPotRgn,HTuple(180),HTuple(255)); //CHOKI20110725 //CHOKI20110926 170->180	
#endif	
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_34!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	select_shape(ThreshPotRgn, &SelectPotRgn, HTuple("area"), HTuple("and"), HTuple(tolerance), HTuple(50000));
	count_obj(SelectPotRgn, &Num);
	
	//CHOKI20100812
	//Pot Search 영역에서 Chip 영역 제거  
	erosion_rectangle1(pot_ins_region, &SubReduced, 4, 4);
	difference(PotRegion, SubReduced, &PotRegion);
	affine_trans_region(PotRegion, &PotRegion, HomMat2D, HTuple("false"));//CHOKI20110118
 
	copy_obj(*image2, &PotImageRegion, 1, -1);
	copy_obj(*Masterimage, &MasterImageRegion, 1, -1);
 
	//Pattern 추출     
	emphasize(PotImageRegion, &PotImageRegion, 5, 5, 1);
	emphasize(MasterImageRegion, &MasterImageRegion, 5, 5, 3);  //20110521 lee

	set_check("~give_error");
	herr = threshold(PotImageRegion,&threshImagePot,HTuple(0),HTuple(100));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_35!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	set_check("~give_error");
	herr = threshold(MasterImageRegion,&threshImageMaster,HTuple(0),HTuple(110));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_36!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	dilation_rectangle1(threshImageMaster, &threshImageMaster, 8, 5);

	affine_trans_region(threshImageMaster, &AlignRegion, HomMat2D, HTuple("false"));

	//CHOKI20110619
	Hobject RefImageTrans; 
	affine_trans_image(*Masterimage, &RefImageTrans, HomMat2D, HTuple("constant"), HTuple("false"));
	//CHOKI20110824
	Hobject RefGreenImageTrans; 
	affine_trans_image(*RefGreenImage, &RefGreenImageTrans, HomMat2D, HTuple("constant"), HTuple("false"));

	//원본 이미지에서 검사 영역 만큼 영역 추출  
	reduce_domain(threshImagePot, PotRegion, &ImagePotReduced);
	reduce_domain(AlignRegion, PotRegion, &ImageMastertReduced);

	dilation_rectangle1(ImageMastertReduced, &DilationRegion, 8, 5);
	erosion_rectangle1(DilationRegion, &DilationRegion, 2, 1);

	difference(ImagePotReduced, DilationRegion, &RecogRegion);

	connection(RecogRegion, &RecogRegion);

	select_shape(RecogRegion, &Pot2RsltRgn, HTuple("area"), HTuple("and"), HTuple(tolerance), HTuple(500)); //20110519 lee 10->tolerance
	//20100818 외부에서 치수 넣을 수 있게...
	select_shape(Pot2RsltRgn, &Pot2RsltRgn, HTuple("width").Concat("height"), HTuple("and"), HTuple(tolerance).Concat(tolerance), HTuple(50).Concat(50));
	connection(Pot2RsltRgn, &Pot2RsltRgn);

	count_obj(Pot2RsltRgn, &Num);

	//CHOKI20110607
	long CountNum = 0;
	HTuple lCenterX, lCenterY, lPi, lWidth, lHeight;
	Hobject TempResult;
	HTuple MeanGreen5, MeanGreen5Side; //CHOKI20110808
	Hobject DilationSide; //CHOKI20110808
	long absDiffGreen5; //CHOKI20110808

	gen_empty_obj(&TempResult);

	CountNum = (long)Num[0];
	if(0 < CountNum)
	{
		for(int i = 0; i < CountNum; i++)
		{
			select_obj(Pot2RsltRgn, &SelectRgn, i + 1);
			smallest_rectangle2(SelectRgn,&lCenterX, &lCenterY, &lPi, &lWidth, &lHeight);  
			intensity(SelectRgn, *image2, &Mean, _);

			//CHOKI20110808
			intensity(SelectRgn, *image5, &MeanGreen5, _);
			dilation_rectangle1(SelectRgn, &DilationSide, 10, 1);
			intensity(DilationSide, *image5, &MeanGreen5Side, _);
			absDiffGreen5 = abs((long)MeanGreen5[0]-(long)MeanGreen5Side[0]);
			//CHOKI20110808
#ifdef AVI_TYPE_1
			if((double)lWidth[0] < (double)lHeight[0]*2.5 && (long)Mean[0] < 65 )//&& 5 < absDiffGreen5) //CHOKI20110711 100->90 //CHOKI20110720 90->80 //CHOKI20110808 검출영역의 좌우 확장영역 밝기값이 영역의 밝기값과 차이가 없을 경우 과검으로 제거함.		//AVI_TYPE_1//
			{//CHOKI20110725 80->70 //CHOKI20110921  (5 < absDiffGreen5) 제거 //CHOKI20111102 80->65
#else
			if((double)lWidth[0] < (double)lHeight[0]*2.5 && (long)Mean[0] < 70 && 5 < absDiffGreen5) //CHOKI20110711 100->90 //CHOKI20110720 90->80 //CHOKI20110808 검출영역의 좌우 확장영역 밝기값이 영역의 밝기값과 차이가 없을 경우 과검으로 제거함.
			{//CHOKI20110725 80->70
#endif
				union2(TempResult, SelectRgn, &TempResult);
			}
		}
	}

	count_obj(TempResult, &Num);
	//CHOKI20110607

	*rslt_num = (long)Num[0];
	if(0 < *rslt_num)
	{
		if(win)
		{
			set_color(win, HTuple("red"));
		}
		connection(TempResult, &TempResult);		
		rslt = FALSE;
	}

	//CHOKI20110619
	Hobject ImagePotReduced5, threshImagePot5, ErosionRgn5, DilationRgn5, ResultTemp1, ResultTemp2;
	long CountNum2 = 0; 
	long CountNum3 = 0;
	HTuple MeanRef5, Mean5, MeanRef;
	HTuple MeanBase; //CHOKI20110622
	HTuple RowS5,ColumS5,RowE5,ColumE5, RowC5,ColumnC5, AreaC5;
	HTuple lCenterX2, lCenterY2, lPi2, lWidth2, lHeight2;
	HTuple MeanRefGreen; //CHOKI20110824
	long dist_intensity; //CHOKI20110622
	reduce_domain(*image5, PotRegion2, &ImagePotReduced5);

	set_check("~give_error");
#ifdef AVI_TYPE_1	
	herr = threshold(ImagePotReduced5,&threshImagePot5,HTuple(170),HTuple(255)); //CHOKI20110720 140->150 //CHOKI20110727 150->160 //CHOKI20110808 160->165 //CHOKI20110824 165->170		//AVI_TYPE_1//
#else	
	herr = threshold(ImagePotReduced5,&threshImagePot5,HTuple(180),HTuple(255)); //CHOKI20110720 140->150 //CHOKI20110727 150->160 //CHOKI20110808 160->165 //CHOKI20110824 165->170set_check("give_error");
#endif	
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_37!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	erosion_rectangle1(threshImagePot5, &ErosionRgn5, 2, 2);
	dilation_rectangle1(ErosionRgn5, &DilationRgn5, 1, 1); //CHOKI20110720 2,2->1,1
	connection(DilationRgn5, &DilationRgn5);
//	select_shape(DilationRgn5, &ResultTemp1, HTuple("width").Concat("height"), HTuple("and"), HTuple(tolerance).Concat(tolerance), HTuple(50).Concat(50));
	select_shape(DilationRgn5, &ResultTemp1, HTuple("area"), HTuple("and"), HTuple(tolerance ), HTuple(200));
	connection(ResultTemp1, &ResultTemp1);
	count_obj(ResultTemp1, &Num);

	CountNum2 = (long)Num[0];

	gen_empty_obj(&ResultTemp2);
	smallest_rectangle1(pot_ins_region,&RowS5,&ColumS5,&RowE5,&ColumE5);

	if(0 < CountNum2)
	{
		for(int i = 0; i < CountNum2; i++)
		{
			select_obj(ResultTemp1, &SelectRgn, i + 1);
			
			intensity(SelectRgn, *image2, &Mean5, _);
			intensity(SelectRgn, RefImageTrans, &MeanRef5, _);
			intensity(SelectRgn, RefGreenImageTrans, &MeanRefGreen, _);			
			intensity(PotRegion, RefImageTrans, &MeanRef, _);
			intensity(PotRegion, *image2, &MeanBase, _);
			area_center(SelectRgn, &AreaC5, &RowC5, &ColumnC5);
			smallest_rectangle2(SelectRgn,&lCenterX2, &lCenterY2, &lPi2, &lWidth2, &lHeight2);  
			if((long)MeanRef[0] > 150)
			{
				//CHOKI20110622
				dist_intensity = (long)MeanBase[0] - (long)MeanRef[0];
				if(dist_intensity >= 10)
					dist_intensity = -5; //CHOKI20110808 부호변경 //CHOKI20110810 가중치 변경 10->5
				else if(dist_intensity <= -10)
					dist_intensity = 5; //CHOKI20110808 부호변경 //CHOKI20110810 가중치 변경 10->5
				else
					dist_intensity = 0;
				//CHOKI20110622

				if((long)Mean5[0] < (130+dist_intensity) && (long)MeanRef5[0] > 185 && (long)ColumnC5[0] > (long)ColumS5[0] &&  (long)ColumnC5[0] < (long)ColumE5[0] && (double)lWidth2[0]*2 >= 3 && (double)lHeight2[0]*2 >= 3) //CHOKI20110725 180->185
				{
					union2(ResultTemp2, SelectRgn, &ResultTemp2);
				}
			}
			else
			{
				//CHOKI20110622
				dist_intensity = (long)MeanBase[0] - (long)MeanRef[0];
				if(dist_intensity >= 10)
					dist_intensity = -5; //CHOKI20110808 부호변경 //CHOKI20110810 가중치 변경 10->5
				else if(dist_intensity <= -10)
					dist_intensity = 5; //CHOKI20110808 부호변경 //CHOKI20110810 가중치 변경 10->5
				else
					dist_intensity = 0;
				//CHOKI20110622
				//CHIOKI20110824 MeanRefGreen 145
				if((long)MeanRefGreen[0] < 145 &&(long)Mean5[0] < (120+dist_intensity) && (long)MeanRef5[0] > 175 && (long)ColumnC5[0] > (long)ColumS5[0] &&  (long)ColumnC5[0] < (long)ColumE5[0] && (double)lWidth2[0]*2 >= 3 && (double)lHeight2[0]*2 >= 3) //CHOKI20110720 130->120, 160->170 //CHOKI20110725 170->175
				{
					union2(ResultTemp2, SelectRgn, &ResultTemp2);
				}
			}
		}
	}

	connection(ResultTemp2, &ResultTemp2);
	count_obj(ResultTemp2, &Num);

	CountNum3 = (long)Num[0];

	if(CountNum3 > 0)
	{
		*rslt_num += (long)Num[0];
		if(win)
		{
			set_color(win, HTuple("red"));
		}
		union2(ResultTemp2, TempResult, &TempResult);
		connection(TempResult, &TempResult);		
		rslt = FALSE;
	}
	//CHOKI20110619

/*	//CHOKI20110710
	Hobject PotRegion6, ImagePotReducedT, threshImagePotT, ErosionRgnT, DilationRgnT, ResultTempT;
	HTuple RowS6,ColumS6,RowE6,ColumE6;
	//smallest_rectangle1(pot_ins_region,&RowS5,&ColumS5,&RowE5,&ColumE5);
	smallest_rectangle1(PotRegion2,&RowS6,&ColumS6,&RowE6,&ColumE6);
	gen_rectangle1(&PotRegion6, RowS6, ColumS5, RowE6, ColumE5);
	erosion_rectangle1(PotRegion6, &PotRegion6, 20, 1);
	reduce_domain(*image6, PotRegion6, &ImagePotReducedT);
	threshold(ImagePotReducedT,&threshImagePotT,HTuple(0),HTuple(45)); //45~50 가변필요
	connection(threshImagePotT, &threshImagePotT);
	select_shape(threshImagePotT, &ResultTempT, HTuple("ra"), HTuple("and"), HTuple(1 ), HTuple(5));
	select_shape(ResultTempT, &ResultTempT, HTuple("area"), HTuple("and"), HTuple(10 ), HTuple(1000));
	select_shape(ResultTempT, &ResultTempT, HTuple("height"), HTuple("and"), HTuple(2 ), HTuple(100));
	count_obj(ResultTempT, &Num);
	*rslt_num += (long)Num[0];
	if(win)
	{
		set_color(win, HTuple("red"));
	}
	union2(ResultTempT, TempResult, &TempResult);
	connection(TempResult, &TempResult);		
	rslt = FALSE;
	//CHOKI20110710*/

	copy_obj(TempResult, rslt_region, 1, -1); 


	return rslt;
}

BOOL C_VisionModule::ChipPot(long win, Hobject *image, RECT ins_region, long pot_area, int thresh, int under_tol, int over_tol, long *rslt_num, long *rslt_area, Hobject *rslt_region)
{
	BOOL rslt = TRUE;
	long min_area, min_width, min_height;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;

	rslt = _Hal_ChipPot(win, image, ins_region, pot_area, thresh, under_tol, over_tol, rslt_num, rslt_area, rslt_region,
					   min_area, min_width, min_height);


	return rslt;

}


//rslt_num : 불량개수
//rslt_region : 불량영역(SR + user area불량)
//rslt_sr_region : sr 검사영역(위치보정된 후)
//rslt_notsr_region : lead부분의 불량 잡은것(첫번째와 두번째 영상 뺀것)
//rslt_user_region : user area 검사영역(위치보정된 후)
BOOL C_VisionModule::FilmMold(long win, 
							  Hobject *align_image,   //map 0
							  Hobject *align_image2,   //Red 3
							  Hobject *mold_image, //map 1
							  Hobject *ink_image, //map 3
							  Hobject *user_image, //map 4
							  Hobject *scratch_image,//map 1
							  Hobject *particle_image, 
							  Hobject *ref_imageRed0,
							   Hobject *Green_image0, //CHOKI20110802
							  RECT ins_region, RECT chip_region, RECT ocv_region, 
							  Hobject ocv_chars_region, Hobject sr_region, Hobject user_region, Hobject sr_out_region,
							  long var_id, 
							  double offset_ox, double offset_oy, 
							  double offset_ox2, double offset_oy2, 
							  double offset_rx, double offset_ry,
							  double offset_rx2, double offset_ry2,
							  int abs_thresh, int var_thresh, int mold_fact, int tolerance, int tolerance_light, int user_thresh, int user_tol,
							  int sr_screach_thresh, int sr_screch_hi_thresh, int sr_screch_tol,
							  long *rslt_num, Hobject *rslt_region, Hobject *rslt_sr_region, Hobject *rslt_notsr_region, Hobject *rslt_user_region, Hobject *rslt_sr_out_region)
{
	BOOL rslt = TRUE;
	long min_area, min_width, min_height, recog_dist, min_area_sr, min_width_sr, min_height_sr;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;
	recog_dist = RECOG_DIST;
	min_area_sr = VISION_FACT_MIN_AREA_SR;
	min_width_sr = VISION_FACT_MIN_WIDTH_SR;
	min_height_sr = VISION_FACT_MIN_HEIGHT_SR;


	rslt = _Hal_FilmMold(win, align_image, align_image2, mold_image, 
		ink_image, user_image, scratch_image, 
		particle_image, ref_imageRed0, Green_image0, 
							  ins_region, chip_region, ocv_region, 
							  ocv_chars_region, sr_region, user_region, sr_out_region,
							  var_id, 
							  offset_ox, offset_oy, 
							  offset_ox2, offset_oy2, 
							  offset_rx, offset_ry,
							  offset_rx2, offset_ry2,
							  abs_thresh, var_thresh, mold_fact, tolerance, tolerance_light, user_thresh, user_tol,
							  sr_screach_thresh, sr_screch_hi_thresh, sr_screch_tol,
							  rslt_num, rslt_region, rslt_sr_region, rslt_notsr_region, rslt_user_region, rslt_sr_out_region,
							  min_area, min_width, min_height,
							  min_area_sr, min_width_sr, min_height_sr);

	return rslt;


}
//20100718 lee
//BOOL C_VisionModule::FilmMetal(long win, Hobject *image, Hobject sr_region, Hobject chip_ins_region1, Hobject char_region,
BOOL C_VisionModule::FilmMetal(long win, Hobject *image, Hobject *Ref_image, //CHOKI20110728 Ref_image추가
							   Hobject sr_region, RECT chip_region, RECT char_region,
							  double offset_ox, double offset_oy, 
							  double offset_ox2, double offset_oy2, 
							  double offset_rx, double offset_ry,
							  double offset_rx2, double offset_ry2,
							 int thresh, int tolerance, long *rslt_num, Hobject *rslt_region)
{
	BOOL rslt = TRUE;
	long min_area, min_width, min_height;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;

	Hobject ImageReduced, Region, RegionClosing, InsRgn, RsltRgn0, RsltRgn1, ChipRgn1, SRRgn, charRgn;
	HTuple Num;
	HTuple DiffAng, HomMat2D;


	double offset_x, offset_y;

	//CHOKI20110728
	Hobject SelectRgn, ResultTemp, RefImageTrans;
	HTuple MeanRef;
	long SelectCount, TempCount;

	gen_empty_obj(&ResultTemp);
	//CHOKI20110728

	angle_ll(offset_ry, offset_rx, offset_ry2, offset_rx2, offset_oy, offset_ox, offset_oy2, offset_ox2, &DiffAng);

	offset_x = offset_rx - offset_ox;
	offset_y = offset_ry - offset_oy;

	vector_angle_to_rigid(offset_oy, offset_ox, DiffAng, offset_ry, offset_rx, HTuple(0), &HomMat2D);
	affine_trans_region(sr_region, &SRRgn, HomMat2D, HTuple("false"));
	affine_trans_image(*Ref_image, &RefImageTrans, HomMat2D, HTuple("constant"), HTuple("false")); //CHOKI20110728

//	affine_trans_region(chip_ins_region1, &ChipRgn1, HomMat2D, HTuple("false"));

	//런타임 칩영역//////////////////////////////

	erosion_rectangle1(SRRgn, &InsRgn, 3, 3);
//	dilation_rectangle1(ChipRgn1, &ChipRgn1, 5.5, 5.5);
//	difference(InsRgn, ChipRgn1, &InsRgn);
	reduce_domain(*image, InsRgn, &ImageReduced);

//	threshold(ImageReduced,&Region,HTuple(thresh),HTuple(255));
	//20100718 lee  210->200으로 조정 
	if(thresh > 230) thresh = 220; //20110616 lee

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = hysteresis_threshold(ImageReduced, &Region, HTuple(thresh), HTuple(230), HTuple(5));

	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_05!... %ld", (long)thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	
	//chip과 ocv 영역 전체를 제거한다. 

	gen_rectangle1(&charRgn, (long)(char_region.top), 
								(long)(char_region.left), 
								(long)(char_region.bottom), 
								(long)(char_region.right));

	gen_rectangle1(&ChipRgn1, (long)(chip_region.top), 
								(long)(chip_region.left), 
								(long)(chip_region.bottom), 
								(long)(chip_region.right));	

	//LSS20100406
	//문자영역제외
//	difference(Region, char_region, &Region);
	difference(Region, charRgn, &Region);
	difference(Region, ChipRgn1, &Region);

	connection(Region, &Region);
	closing_circle(Region,&RegionClosing,HTuple(3.5));

	select_shape(RegionClosing, &RsltRgn0, HTuple("width").Concat("height"), HTuple("and"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));

	Hobject select_object;
	HTuple Row1, Column1, Row2, Column2;

	connection(RsltRgn0, &RsltRgn0);

	count_obj(RsltRgn0, &Num);
	//CHOKI20110728
//	*rslt_num = (long)Num[0];
	SelectCount = (long)Num[0];
	if(0 < SelectCount)//if(0 < *rslt_num)
	{
		TempCount = 0;
	//	copy_obj(RsltRgn0, rslt_region, 1, -1);
		for(int i = 0; i < (long)Num[0]; i++) 
		{
			select_obj(RsltRgn0, &SelectRgn, i + 1);
			intensity(SelectRgn, RefImageTrans, &MeanRef, _);
#ifdef AVI_TYPE_1
			if((long)MeanRef[0] < 180) //CHOKI20111004 230->215 111005 ytlee	215 -> 210  //CHOKI20111005 ->190 // 111007 ytlee 190 -> 180	//AVI_TYPE_1//
#else
			if((long)MeanRef[0] < 230)
#endif
			{
				union2(ResultTemp, SelectRgn, &ResultTemp);
				TempCount++;
			}
		}
		if(TempCount > 0)
		{
			connection(ResultTemp, &ResultTemp);
			count_obj(ResultTemp, &Num);
			*rslt_num = (long)Num[0];
			copy_obj(ResultTemp, rslt_region, 1, -1);

			if(win)
			{
				set_color(win, HTuple("red"));
				disp_obj(*rslt_region, win);
			}
			return FALSE;
		}
//		return FALSE;
	}
	//CHOKI20110728

	return TRUE;
}


BOOL C_VisionModule::FilmPF(long win, Hobject *image, Hobject *image2,  Hobject *Ref_image, //image : back light이미지->전체찢김검사 , image2 : 좀더 밝은 back light이미지->PF영역에서만 검사 //CHOKI20110717 기준검사를 위하여 Ref_image 추가
						   Hobject *Ref_image2, //CHOKI20110722
							RECT ins_region, RECT chip_region, Hobject pf_region, Hobject vacc_region,
						   double offset_ox, double offset_oy, 
						   double offset_ox2, double offset_oy2, 
						   double offset_rx, double offset_ry,
						   double offset_rx2, double offset_ry2,
						   int thresh, int high_thresh, int tolerance,
						   long *rslt_num, Hobject *rslt_region, Hobject *rslt_pf_region) 
{
	BOOL rslt = TRUE;
	long min_area, min_width, min_height, recog_dist, min_area_sr, min_width_sr, min_height_sr;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;
	recog_dist = RECOG_DIST;
	min_area_sr = VISION_FACT_MIN_AREA_SR;
	min_width_sr = VISION_FACT_MIN_WIDTH_SR;
	min_height_sr = VISION_FACT_MIN_HEIGHT_SR;

	rslt = _Hal_FilmPF(win, image, image2, Ref_image,//image : back light이미지->전체찢김검사 , image2 : 좀더 밝은 back light이미지->PF영역에서만 검사 //CHOKI20110717
						   Ref_image2, //CHOKI20110722
							ins_region, chip_region, pf_region, vacc_region,
						   offset_ox, offset_oy, 
						   offset_ox2, offset_oy2, 
						   offset_rx, offset_ry,
						   offset_rx2, offset_ry2,
						   thresh, high_thresh, tolerance,
						   rslt_num, rslt_region, rslt_pf_region,
						   min_area, min_width, min_height,
						   min_area_sr, min_width_sr, min_height_sr); 
	return rslt;




}

//하부결함(out lead)
BOOL C_VisionModule::DnLead(long win, Hobject *image, Hobject *crack_image, Hobject *Red_image, 
							Hobject *Green_image,  Hobject *Red_image2, Hobject *Blue_image, Hobject *Blue_image2,
							Hobject *Green_image2,
							RECT ins_region, 
							Hobject not_sr_region, Hobject dn_region,
							double offset_ox, double offset_oy, 
							double offset_ox2, double offset_oy2, 
							double offset_rx, double offset_ry,
							double offset_rx2, double offset_ry2,
						   int thres, double factor, int tolerance, 
						   double* line_width_avg, 
						   long *rslt_num, Hobject *rslt_region,  
						   long *rslt_num2, Hobject *rslt_region2,
						   Hobject *rslt_dn_region)
{
	BOOL rslt = TRUE;
	BOOL rslt1= TRUE;
	BOOL rslt2= TRUE;

	long min_area, min_width, min_height;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;

//	rslt1 = _Hal_DnLead(win, image, crack_image, ins_region, not_sr_region,	
/*	rslt1 = _Hal_DnLead(win, image, crack_image, Red_image, ins_region, not_sr_region,	//CHOKI20101030
							dn_region,
							offset_ox, offset_oy, 
							offset_ox2, offset_oy2, 
							offset_rx, offset_ry,
							offset_rx2, offset_ry2,
						   thres, factor, tolerance, 
						   line_width_avg, 
						   rslt_num, rslt_region,  
						   rslt_num2, rslt_region2,
						   rslt_dn_region,
						   min_area, min_width, min_height);
*/
	rslt1 = _Hal_DnLead2(win, image, crack_image, Red_image, Green_image, Red_image2, Blue_image, Blue_image2,
						Green_image2,
						ins_region, not_sr_region,	
						dn_region,
						offset_ox, offset_oy, 
						offset_ox2, offset_oy2, 
						offset_rx, offset_ry,
						offset_rx2, offset_ry2,
						thres, factor, tolerance, 
						line_width_avg, 
						rslt_num, rslt_region,  
						rslt_num2, rslt_region2,
						rslt_dn_region,
						   min_area, min_width, min_height);

//	if(rslt1 == FALSE || rslt2 == FALSE)
//	{
//		rslt = FALSE;
//	}
//
//
//	return rslt;
//	return rslt2;

	return rslt1;


}

//하부긁힘(out lead)
BOOL C_VisionModule::DnLeadScratch(long win, Hobject *image, Hobject rslt_dn_region, 
							 int thresh, int tolerance, long *rslt_num, Hobject *rslt_region)
{
	BOOL rslt = TRUE;
	long min_area, min_width, min_height;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;

	Hobject ImageReduced, Region, RegionClosing, InsRgn, RsltRgn, EmpImage;
	HTuple Num;

	int min_thresh, max_thresh;

	//런타임 dn lead 영역////////////////////////
	reduce_domain(*image, rslt_dn_region, &ImageReduced);

	emphasize(ImageReduced,&EmpImage,HTuple(5),HTuple(5),HTuple(2)); //20101008 lee

	max_thresh = thresh;
	min_thresh = max_thresh - 30;
	if(100 > min_thresh)
	{
		min_thresh = 100;
		max_thresh = 150;
	}

	if(min_thresh > max_thresh) min_thresh = max_thresh-10; //20110616 lee
	
	Herror herr;
	CString status;

	set_check("~give_error");
	herr = hysteresis_threshold(EmpImage,&Region,HTuple(min_thresh),HTuple(max_thresh),HTuple(20));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_06!... %ld, %ld", (long)min_thresh, (long)max_thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	
	
	connection(Region, &Region);
	closing_circle(Region,&RegionClosing,HTuple(3.5));

	select_shape(RegionClosing, &RegionClosing, HTuple("area"), HTuple("and"), HTuple(min_area), HTuple("max"));
	select_shape(RegionClosing, &RegionClosing, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width).Concat(min_height), HTuple("max").Concat("max"));
	select_shape(RegionClosing, &RsltRgn, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));

	Hobject select_object;
	HTuple Row1, Column1, Row2, Column2;

	connection(RsltRgn, &RsltRgn);

	count_obj(RsltRgn, &Num);
	*rslt_num = (long)Num[0];
	if(0 < *rslt_num)
	{
		copy_obj(RsltRgn, rslt_region, 1, -1);
		
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(*rslt_region, win);
		}

		return FALSE;
	}

	return TRUE;
}

//상부결함(in lead)
BOOL C_VisionModule::UpLead(long win, Hobject *image0, Hobject *image, Hobject *image2, 
							Hobject *image3,  Hobject *image4, Hobject *image5, Hobject *image6, Hobject *image7,Hobject *image8,
							RECT ins_region, RECT ins_region2, RECT ins_region3,
							Hobject not_sr_region, 
							Hobject up_region,
							Hobject dn_region,
							Hobject up_region2, 
							Hobject up_region3,
							double offset_ox, double offset_oy, 
							double offset_ox2, double offset_oy2, 
							double offset_rx, double offset_ry,
							double offset_rx2, double offset_ry2,
						   int thresh, double factor, int tolerance, 
						   int thresh_dirt, int tolerance_dirt,
						   long *rslt_num, Hobject *rslt_region, 
						   long *rslt_num2, Hobject *rslt_region2, 						   
						   Hobject *rslt_up_region)
{
	BOOL rslt = TRUE;
	long min_area, min_width, min_height;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;

	//CHOKI20100911
	unsigned int CaseInOutLeadPosition=0;
	HTuple UpLeadRow, UpLeadCaseCol, DnLeadRow, DnLeadCaseCol;
	area_center(up_region, _, &UpLeadRow, &UpLeadCaseCol);
	area_center(dn_region, _, &DnLeadRow, &DnLeadCaseCol);
	if(UpLeadRow < DnLeadRow)//Out 리드가 위쪽에 위치
	{
		CaseInOutLeadPosition = 1;
	}
	else if(UpLeadRow > DnLeadRow)//In 리드가 위쪽에 위치
	{
		CaseInOutLeadPosition = 2;
	}

	//20100618 lss
//	rslt = _Hal_UpLead(win, image0, image, image2, image3,
	rslt = _Hal_UpLeadColor(win, image0, image, image2, image3, image4, image5, image6, image7,//CHOKI20101028
							image8, //CHOKI201100831
							ins_region,	ins_region2, ins_region3, 
							not_sr_region, 
							up_region,
							up_region2,
							up_region3,
							offset_ox, offset_oy, 
							offset_ox2, offset_oy2, 
							offset_rx, offset_ry,
							offset_rx2, offset_ry2,
						   thresh, factor, tolerance, 
						   thresh_dirt, tolerance_dirt,
						   rslt_num, rslt_region, 
						   rslt_num2, rslt_region2, 						   
						   rslt_up_region,
						   min_area, min_width, min_height, CaseInOutLeadPosition);

	return rslt;


}

//20100618 lss
BOOL  C_VisionModule::_Hal_UpLead(long win, Hobject *image0, Hobject *image, Hobject *image2, Hobject *image3,
							RECT ins_region, RECT ins_region2, RECT ins_region3,
							Hobject not_sr_region, 
							Hobject up_region,
							Hobject up_region2,
							Hobject up_region3,
							double offset_ox, double offset_oy, 
							double offset_ox2, double offset_oy2, 
							double offset_rx, double offset_ry,
							double offset_rx2, double offset_ry2,
						   int thresh, double factor, int tolerance, 
						   int thresh_dirt, int tolerance_dirt,
						   long *rslt_num, Hobject *rslt_region, 
						   long *rslt_num2, Hobject *rslt_region2, 						   
						   Hobject *rslt_up_region,
						   long min_area, long min_width, long min_height, unsigned int checkleadpos)
{
	BOOL rslt = TRUE;
	HTuple   Pointer, Type, Width, Height, WindowHandle, Row1;
	HTuple   Column1, Row2, Column2, Row, Sum, Column, Diff;
	HTuple   Length1, UntilHeight, Start, MeasureHandle0, MeasureHandle1;
	HTuple   RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond;
	HTuple   ColumnEdgeSecond, AmplitudeSecond, IntraDistance;
	HTuple   InterDistance, End, Time;
	Hobject  I, InsRegion, DontCare;
	Hobject  Line, TotLine, select_object;
	HTuple   Num;
	long idx;
	HTuple HomMat2D;

	Hobject RegionDiff;
	Hobject OutRgn, SelectRgn, ResultRgn;
	HTuple Mean, OutMean;
	Hobject ComplRgn, EmpImage;

	Hobject Region, SubImage;
	HTuple DiffAng;

	Hobject MeanImage;
	long center;
	Hobject TotDirtyRgn, DirtyRgn, LineRgn, ImageReduced;
	long ins_area, tol_area, max;
	HTuple Min, Max, Area;

	//CHOKI20100823
	HTuple LeadRow1, LeadCol1, LeadRow2, LeadCol2;
	Hobject EdgeRgn, EdgeRgnReduced, EdgeThesh, EdgeRsltRegion;

	//CHOKI20100827
	Hobject UpLeadRgn2, UpLeadReduced2, UpLeadEmphasize, UpLeadEdge, UpLeadEdgeRsltRegion2;
	Hobject ContoursSplit, SelectedContours, UnionContours, SelectedContours1, RegressContours1;
	HTuple  EdgeRow, EdgeColumn, EdgePhi, EdgeLength1, EdgeLength2;
	Hobject MeanLeadReduced, MeanLeadThesh, MeanLeadRsltRegion, SelectRgn2, intersectionRgn, intersectionRsult;
	HTuple   NumMean, Numintersection;



	Hobject NotSRRgn, EmpImage2, InterRgn;

	long i, num;

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*image, &Pointer, &Type, &Width, &Height);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_25!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}
	
	long row = ins_region.top + 1;
	long col = (ins_region.left + ins_region.right) * 0.5;
	long leng1 = (ins_region.right - ins_region.left) * 0.5;
	long height = (ins_region.bottom - ins_region.top) - 1;

	//20100621 lss
	long row_l = (ins_region2.top + ins_region2.bottom) * 0.5;
	long col_l = ins_region2.left + 1;
	long leng1_l = (ins_region2.bottom - ins_region2.top) * 0.5;
	long height_l = (ins_region2.right - ins_region2.left) - 1;

	//20100621 lss
	long row_r = (ins_region3.top + ins_region3.bottom) * 0.5;
	long col_r = ins_region3.left + 1;
	long leng1_r = (ins_region3.bottom - ins_region3.top) * 0.5;
	long height_r = (ins_region3.right - ins_region3.left) - 1;

	Hobject RsltRegion, RsltRegion2, RsltUPRegion;

	Hobject TotLine_l, TotLine_r;

	gen_empty_obj(&RsltRegion);
	gen_empty_obj(&RsltRegion2);
	gen_empty_obj(&RsltUPRegion);

	angle_ll(offset_oy, offset_ox, offset_oy2, offset_ox2, offset_ry, offset_rx, offset_ry2, offset_rx2, &DiffAng);


	if(0.4 > factor)
	{
		factor = 0.4;
	}

	gen_rectangle1(&Region, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.right);

	vector_angle_to_rigid(offset_oy, offset_ox, HTuple(0), offset_ry, offset_rx, DiffAng, &HomMat2D);
	affine_trans_region(up_region, &RsltUPRegion, HomMat2D, HTuple("false"));

	//sub_image(*image, *crack_image, &SubImage, 1, 0);
	//emphasize(*image, &EmpImage, 20, 20, 2);
	emphasize(*image, &EmpImage, 10, 10, 2);
	emphasize(*image2, &EmpImage2, 10, 10, 2);

	gen_rectangle1(&InsRegion, ins_region.top, ins_region.left, ins_region.bottom, ins_region.right);
	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(InsRegion, win);
	}

	//Image1/////////////////////////////////////

	gen_empty_obj(&Line);
	gen_empty_obj(&TotLine);

	//20100621 lss
	gen_empty_obj(&TotLine_l);
	gen_empty_obj(&TotLine_r);	

	gen_measure_rectangle2(row,col,HTuple(0),leng1,HTuple(2),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
	gen_measure_rectangle2(row,col,HTuple(PI),leng1,HTuple(2),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);

	for(idx=1; idx<=height; idx+=1)
	{
		translate_measure(MeasureHandle0, row + idx, col);
		measure_pos(EmpImage, MeasureHandle0, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
			            &RowEdgeFirst,&ColumnEdgeFirst,&AmplitudeFirst,&InterDistance);
		
		translate_measure(MeasureHandle1, row + idx, col);
		measure_pos(EmpImage, MeasureHandle1, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
			            &RowEdgeSecond,&ColumnEdgeSecond,&AmplitudeFirst,&InterDistance);

		if(0 < RowEdgeFirst.Num())
		{
			gen_region_points(&Line, RowEdgeFirst,ColumnEdgeFirst);

			//concat_obj(TotLine, Line, &TotLine);
			union2(TotLine, Line, &TotLine);
		}

		if(0 < RowEdgeSecond.Num())
		{
			gen_region_points(&Line, RowEdgeSecond,ColumnEdgeSecond);

			//concat_obj(TotLine, Line, &TotLine);
			union2(TotLine, Line, &TotLine);
		}

	}

	close_measure(MeasureHandle0);
	close_measure(MeasureHandle1);

	//20100621 lss
	if((0 < ins_region2.right) && (0 < ins_region2.bottom))
	{
		//Left region////////////////////////////////
		gen_measure_rectangle2(row_l,col_l,HTuple(1.57079632679),leng1_l,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
		gen_measure_rectangle2(row_l,col_l,HTuple(-1.57079632679),leng1_l,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);
		
		for(idx=1; idx<=height_l; idx+=1)
		{
			translate_measure(MeasureHandle0, row_l, col_l + idx);
			//gen_measure_rectangle2(row_l,col_l + idx,HTuple(1.57079632679),leng1_l,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
			measure_pos(EmpImage, MeasureHandle0, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
				&RowEdgeFirst,&ColumnEdgeFirst,&AmplitudeFirst,&InterDistance);
			
			translate_measure(MeasureHandle1, row_l, col_l + idx);
			//gen_measure_rectangle2(row_l,col_l + idx,HTuple(-1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);
			measure_pos(EmpImage, MeasureHandle1, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
				&RowEdgeSecond,&ColumnEdgeSecond,&AmplitudeFirst,&InterDistance);
			
			if(0 < RowEdgeFirst.Num())
			{
				gen_region_points(&Line, RowEdgeFirst,ColumnEdgeFirst);
				
				//concat_obj(TotLine, Line, &TotLine);
				union2(TotLine_l, Line, &TotLine_l);
				
				if(win)
				{
					set_color(win, HTuple("green"));
					disp_obj(Line, win);
				}
			}
			
			if(0 < RowEdgeSecond.Num())
			{
				gen_region_points(&Line, RowEdgeSecond,ColumnEdgeSecond);
				
				//concat_obj(TotLine, Line, &TotLine);
				union2(TotLine_l, Line, &TotLine_l);
				
				if(win)
				{
					set_color(win, HTuple("blue"));
					disp_obj(Line, win);
				}
			}
		}
		
		close_measure(MeasureHandle0);
		close_measure(MeasureHandle1);
		/////////////////////////////////////////////
		
		//20100621 lss
		//Right region///////////////////////////////
		gen_measure_rectangle2(row_r,col_r,HTuple(1.57079632679),leng1_r,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
		gen_measure_rectangle2(row_r,col_r,HTuple(-1.57079632679),leng1_r,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);
		
		for(idx=1; idx<=height_r; idx+=1)
		{
			translate_measure(MeasureHandle0, row_r, col_r + idx);
			//gen_measure_rectangle2(row_r,col_r + idx,HTuple(1.57079632679),leng1_r,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
			measure_pos(EmpImage, MeasureHandle0, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
				&RowEdgeFirst,&ColumnEdgeFirst,&AmplitudeFirst,&InterDistance);
			
			translate_measure(MeasureHandle1, row_r, col_r + idx);
			//gen_measure_rectangle2(row_r,col_r + idx,HTuple(-1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);
			measure_pos(EmpImage, MeasureHandle1, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
				&RowEdgeSecond,&ColumnEdgeSecond,&AmplitudeFirst,&InterDistance);
			
			if(0 < RowEdgeFirst.Num())
			{
				gen_region_points(&Line, RowEdgeFirst,ColumnEdgeFirst);
				
				//concat_obj(TotLine, Line, &TotLine);
				union2(TotLine_r, Line, &TotLine_r);
				
				if(win)
				{
					set_color(win, HTuple("green"));
					disp_obj(Line, win);
				}
			}
			
			if(0 < RowEdgeSecond.Num())
			{
				gen_region_points(&Line, RowEdgeSecond,ColumnEdgeSecond);
				
				//concat_obj(TotLine, Line, &TotLine);
				union2(TotLine_r, Line, &TotLine_r);
				
				if(win)
				{
					set_color(win, HTuple("blue"));
					disp_obj(Line, win);
				}
			}
		}
		
		close_measure(MeasureHandle0);
		close_measure(MeasureHandle1);
		
	}
	
	/////////////////////////////////////////////

	connection(TotLine, &TotLine);

	erosion_rectangle1(RsltUPRegion, &RsltUPRegion, 5.5, 2.5);
	intersection(TotLine, RsltUPRegion, &TotLine);

	//20100621 lss
	union2(TotLine, TotLine_l, &TotLine);
	union2(TotLine, TotLine_r, &TotLine);
	connection(TotLine, &TotLine);

	//이진화 방식으로 얻은 영역과 에지측정으로 얻은 영역의 교집합이 존재하는 조건
	count_obj(TotLine, &Num);
	num = (long)Num[0];
	if(0 < num)
	{
		union1(TotLine, &TotLine);
		intersection(not_sr_region, RsltUPRegion, &NotSRRgn);
		connection(NotSRRgn, &NotSRRgn);
		count_obj(NotSRRgn, &Num);
		gen_empty_obj(&InterRgn);
		num = (long)Num[0];
		for(i = 0; i < num; i++)
		{
			select_obj(NotSRRgn, &SelectRgn, i + 1);
			intersection(TotLine, SelectRgn, &InterRgn);
			area_center(InterRgn, &Area, _, _);
			if(1 < (long)Area[0])
			{
				union2(TotLine, NotSRRgn, &TotLine);
			}
		}
	}

	//union2(TotLine, DynRegion, &TotLine);

	closing_circle(TotLine, &TotLine, HTuple(50.5));

	connection(TotLine, &TotLine);
	select_shape(TotLine, &TotLine, HTuple("area"), HTuple("and"), HTuple(min_area), HTuple("max"));
	select_shape(TotLine, &TotLine, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width).Concat(min_height), HTuple("max").Concat("max"));
	select_shape(TotLine, &RsltRegion, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));



	//Image2/////////////////////////////////////
	gen_empty_obj(&Line);
	gen_empty_obj(&TotLine);

	//20100621 lss
	gen_empty_obj(&TotLine_l);
	gen_empty_obj(&TotLine_r);	

	gen_measure_rectangle2(row,col,HTuple(0),leng1,HTuple(2),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
	gen_measure_rectangle2(row,col,HTuple(PI),leng1,HTuple(2),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);

	for(idx=1; idx<=height; idx+=1)
	{
		translate_measure(MeasureHandle0, row + idx, col);
		measure_pos(EmpImage2, MeasureHandle0, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
			            &RowEdgeFirst,&ColumnEdgeFirst,&AmplitudeFirst,&InterDistance);
		
		translate_measure(MeasureHandle1, row + idx, col);
		measure_pos(EmpImage2, MeasureHandle1, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
			            &RowEdgeSecond,&ColumnEdgeSecond,&AmplitudeFirst,&InterDistance);

		if(0 < RowEdgeFirst.Num())
		{
			gen_region_points(&Line, RowEdgeFirst,ColumnEdgeFirst);

			//concat_obj(TotLine, Line, &TotLine);
			union2(TotLine, Line, &TotLine);
		}

		if(0 < RowEdgeSecond.Num())
		{
			gen_region_points(&Line, RowEdgeSecond,ColumnEdgeSecond);

			//concat_obj(TotLine, Line, &TotLine);
			union2(TotLine, Line, &TotLine);
		}

	}

	close_measure(MeasureHandle0);
	close_measure(MeasureHandle1);

	//20100621 lss
	if((0 < ins_region2.right) && (0 < ins_region2.bottom))
	{
		//Left region////////////////////////////////
		gen_measure_rectangle2(row_l,col_l,HTuple(1.57079632679),leng1_l,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
		gen_measure_rectangle2(row_l,col_l,HTuple(-1.57079632679),leng1_l,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);
		
		for(idx=1; idx<=height_l; idx+=1)
		{
			translate_measure(MeasureHandle0, row_l, col_l + idx);
			//gen_measure_rectangle2(row_l,col_l + idx,HTuple(1.57079632679),leng1_l,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
			measure_pos(EmpImage2, MeasureHandle0, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
				&RowEdgeFirst,&ColumnEdgeFirst,&AmplitudeFirst,&InterDistance);
			
			translate_measure(MeasureHandle1, row_l, col_l + idx);
			//gen_measure_rectangle2(row_l,col_l + idx,HTuple(-1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);
			measure_pos(EmpImage2, MeasureHandle1, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
				&RowEdgeSecond,&ColumnEdgeSecond,&AmplitudeFirst,&InterDistance);
			
			if(0 < RowEdgeFirst.Num())
			{
				gen_region_points(&Line, RowEdgeFirst,ColumnEdgeFirst);
				
				//concat_obj(TotLine, Line, &TotLine);
				union2(TotLine_l, Line, &TotLine_l);
				
				if(win)
				{
					set_color(win, HTuple("green"));
					disp_obj(Line, win);
				}
			}
			
			if(0 < RowEdgeSecond.Num())
			{
				gen_region_points(&Line, RowEdgeSecond,ColumnEdgeSecond);
				
				//concat_obj(TotLine, Line, &TotLine);
				union2(TotLine_l, Line, &TotLine_l);
				
				if(win)
				{
					set_color(win, HTuple("blue"));
					disp_obj(Line, win);
				}
			}
		}
		
		close_measure(MeasureHandle0);
		close_measure(MeasureHandle1);
		/////////////////////////////////////////////
		
		//20100621 lss
		//Right region///////////////////////////////
		gen_measure_rectangle2(row_r,col_r,HTuple(1.57079632679),leng1_r,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
		gen_measure_rectangle2(row_r,col_r,HTuple(-1.57079632679),leng1_r,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);
		
		for(idx=1; idx<=height_r; idx+=1)
		{
			translate_measure(MeasureHandle0, row_r, col_r + idx);
			//gen_measure_rectangle2(row_r,col_r + idx,HTuple(1.57079632679),leng1_r,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
			measure_pos(EmpImage2, MeasureHandle0, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
				&RowEdgeFirst,&ColumnEdgeFirst,&AmplitudeFirst,&InterDistance);
			
			translate_measure(MeasureHandle1, row_r, col_r + idx);
			//gen_measure_rectangle2(row_r,col_r + idx,HTuple(-1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);
			measure_pos(EmpImage2, MeasureHandle1, HTuple(factor), HTuple(thresh), HTuple("all"), HTuple("all"),
				&RowEdgeSecond,&ColumnEdgeSecond,&AmplitudeFirst,&InterDistance);
			
			if(0 < RowEdgeFirst.Num())
			{
				gen_region_points(&Line, RowEdgeFirst,ColumnEdgeFirst);
				
				//concat_obj(TotLine, Line, &TotLine);
				union2(TotLine_r, Line, &TotLine_r);
				
				if(win)
				{
					set_color(win, HTuple("green"));
					disp_obj(Line, win);
				}
			}
			
			if(0 < RowEdgeSecond.Num())
			{
				gen_region_points(&Line, RowEdgeSecond,ColumnEdgeSecond);
				
				//concat_obj(TotLine, Line, &TotLine);
				union2(TotLine_r, Line, &TotLine_r);
				
				if(win)
				{
					set_color(win, HTuple("blue"));
					disp_obj(Line, win);
				}
			}
		}
		
		close_measure(MeasureHandle0);
		close_measure(MeasureHandle1);
	}
	/////////////////////////////////////////////


	connection(TotLine, &TotLine);

	erosion_rectangle1(RsltUPRegion, &RsltUPRegion, 5.5, 2.5);
	intersection(TotLine, RsltUPRegion, &TotLine);

	//20100621 lss
	union2(TotLine, TotLine_l, &TotLine);
	union2(TotLine, TotLine_r, &TotLine);
	connection(TotLine, &TotLine);

	//이진화 방식으로 얻은 영역과 에지측정으로 얻은 영역의 교집합이 존재하는 조건
	count_obj(TotLine, &Num);
	num = (long)Num[0];
	if(0 < num)
	{
		union1(TotLine, &TotLine);
		intersection(not_sr_region, RsltUPRegion, &NotSRRgn);
		connection(NotSRRgn, &NotSRRgn);
		count_obj(NotSRRgn, &Num);
		gen_empty_obj(&InterRgn);
		num = (long)Num[0];
		for(i = 0; i < num; i++)
		{
			select_obj(NotSRRgn, &SelectRgn, i + 1);
			intersection(TotLine, SelectRgn, &InterRgn);
			area_center(InterRgn, &Area, _, _);
			if(1 < (long)Area[0])
			{
				union2(TotLine, NotSRRgn, &TotLine);
			}
		}
	}

	//union2(TotLine, DynRegion, &TotLine);

	closing_circle(TotLine, &TotLine, HTuple(50.5));

	connection(TotLine, &TotLine);
	select_shape(TotLine, &TotLine, HTuple("area"), HTuple("and"), HTuple(min_area), HTuple("max"));
	select_shape(TotLine, &TotLine, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width).Concat(min_height), HTuple("max").Concat("max"));
	select_shape(TotLine, &RsltRegion2, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));

	//Image1/////////////////////////////////////
	//오염///////////////////////////////////////
	mean_image(*image, &MeanImage, 10, 2);

	center = (ins_region.left + ins_region.right) * 0.5;
	
	gen_empty_obj(&TotDirtyRgn);

	for(i = ins_region.top; i < ins_region.bottom; i++)
	{
		//Left///////////////////////////////////
		gen_region_line(&LineRgn, i, ins_region.left, i, center);

		reduce_domain(MeanImage, LineRgn, &ImageReduced);
		
		//Find suitable threshold
		min_max_gray(LineRgn, MeanImage, HTuple(20), &Min, &Max, _);
		max = (long)Max[0];
		max = max - thresh_dirt;
		if( (0 > max) || (255 < max) )
		{
			max = 1;
		}

		set_check("~give_error");
		herr = threshold(ImageReduced, &DirtyRgn, 0, max);
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
			max = 255;
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_38!... %ld", (long)max);
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}		

		//connection(DirtyRgn, &DirtyRgn);
		//select_shape(DirtyRgn, &DirtyRgn, HTuple("area"), HTuple("and"), HTuple(10000),  HTuple("max"));

		//concat_obj(TotDirtyRgn, DirtyRgn, &TotDirtyRgn);
		union2(TotDirtyRgn, DirtyRgn, &TotDirtyRgn);

		//Right//////////////////////////////////
		gen_region_line(&LineRgn, i, center, i, ins_region.right);

		reduce_domain(EmpImage, LineRgn, &ImageReduced);
		
		//Find suitable threshold
		min_max_gray(LineRgn, MeanImage, HTuple(20), &Min, &Max, _);
		max = (long)Max[0];
		max = max - thresh_dirt;
		if( (0 > max) || (255 < max) )
		{
			max = 1;
		}

		set_check("~give_error");
		herr = threshold(ImageReduced, &DirtyRgn, 0, max);
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
			max = 255;
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_39!... %ld", (long)max);
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}		
		
		//connection(DirtyRgn, &DirtyRgn);
		//select_shape(DirtyRgn, &DirtyRgn, HTuple("area"), HTuple("and"), HTuple(10000),  HTuple("max"));
		
		//concat_obj(TotDirtyRgn, DirtyRgn, &TotDirtyRgn);
		union2(TotDirtyRgn, DirtyRgn, &TotDirtyRgn);
	}

	//union1(TotDirtyRgn, &TotDirtyRgn);
	closing_circle(TotDirtyRgn, &TotDirtyRgn, 10.5);
	connection(TotDirtyRgn, &TotDirtyRgn);

	area_center(Region, &Area, _, _);
	ins_area = (long)Area[0];
	tol_area = (long)( ((double)ins_area) * (tolerance_dirt * 0.01) );

	select_shape(TotDirtyRgn, &TotDirtyRgn, HTuple("area"), HTuple("and"), HTuple(tol_area),  HTuple("max"));

	//20100621 lss
	//concat_obj(RsltRegion, TotDirtyRgn, rslt_region);
	concat_obj(RsltRegion, TotDirtyRgn, &RsltRegion);

	//CHOKI20100911
	if(checkleadpos == 1)//Out 리드가 위쪽에
	{
		//CHOKI20100823
		smallest_rectangle1(RsltUPRegion, &LeadRow1, &LeadCol1, &LeadRow2, &LeadCol2);

		gen_rectangle1(&EdgeRgn,LeadRow2,LeadCol1,LeadRow2+10,LeadCol2);

		reduce_domain(*image3, EdgeRgn, &EdgeRgnReduced);

		set_check("~give_error");
		herr = threshold(EdgeRgnReduced, &EdgeThesh, HTuple(0),HTuple(130));
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_40!");
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}	

		connection(EdgeThesh, &EdgeThesh);

		select_shape(EdgeThesh, &EdgeRsltRegion, HTuple("area"), HTuple("and"), HTuple(10), HTuple(10000));
		select_shape(EdgeRsltRegion, &EdgeRsltRegion, HTuple("width").Concat("height"), HTuple("and"), HTuple(3).Concat(3), HTuple(10).Concat("max"));//CHOKI20100903 Check 2개 이상 검사시 OVK발생.

		connection(EdgeRsltRegion, &EdgeRsltRegion);

		union2(RsltRegion, EdgeRsltRegion, &RsltRegion);

		//CHOKI20100823
	}
	else if(checkleadpos == 2)//In 리드가 위쪽에
	{
		//CHOKI20100823
		smallest_rectangle1(RsltUPRegion, &LeadRow1, &LeadCol1, &LeadRow2, &LeadCol2);

		gen_rectangle1(&EdgeRgn,LeadRow1-10,LeadCol1,LeadRow1,LeadCol2);//CHOKI20100910 In-Out Change

		reduce_domain(*image3, EdgeRgn, &EdgeRgnReduced);

		set_check("~give_error");
		herr = threshold(EdgeRgnReduced, &EdgeThesh, HTuple(0),HTuple(130));
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_41!");
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}		

		connection(EdgeThesh, &EdgeThesh);

		select_shape(EdgeThesh, &EdgeRsltRegion, HTuple("area"), HTuple("and"), HTuple(10), HTuple(10000));
		select_shape(EdgeRsltRegion, &EdgeRsltRegion, HTuple("width").Concat("height"), HTuple("and"), HTuple(3).Concat(3), HTuple(10).Concat("max"));//CHOKI20100903 Check 2개 이상 검사시 OVK발생.

		connection(EdgeRsltRegion, &EdgeRsltRegion);

		union2(RsltRegion, EdgeRsltRegion, &RsltRegion);

		//CHOKI20100823

	}
	//CHOKI20100911

/*	
	//CHOKI20100909
	Hobject EtcRgn, EtcRgnReduced, EtcThesh, EtcRsltRegion, EtcRegionClosing;
	gen_rectangle1(&EtcRgn, LeadRow1-35,LeadCol1,LeadRow1,LeadCol2);
	reduce_domain(*image0, EtcRgn, &EtcRgnReduced);
	threshold(EtcRgnReduced, &EtcThesh, HTuple(0),HTuple(120));
	connection(EtcThesh, &EtcThesh);
	closing_circle(EtcThesh,&EtcRegionClosing,HTuple(10));
	select_shape(EtcRegionClosing, &EtcRsltRegion, HTuple("area"), HTuple("and"), HTuple(1), HTuple(100));
	select_shape(EtcRsltRegion, &EtcRsltRegion, HTuple("width").Concat("height"), HTuple("and"), HTuple(1).Concat(1), HTuple(10).Concat(10));
	

	union2(RsltRegion, EtcRsltRegion, &RsltRegion);
	connection(RsltRegion, &RsltRegion);
	//CHOKI20100909
*/


	//CHOKI20100827
	long Checkintersection;
	long numMeanR, numEdge;
	Hobject EdgeRect[300];
	numMeanR = 0;
	numEdge = 0;

	reduce_domain(MeanImage, RsltUPRegion, &MeanLeadReduced);

	set_check("~give_error");
	herr = threshold(MeanLeadReduced, &MeanLeadThesh, HTuple(0),HTuple(90));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_42!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(MeanLeadThesh, &MeanLeadThesh);

	select_shape(MeanLeadThesh,&MeanLeadRsltRegion,HTuple("area"),HTuple("and"),HTuple(20),HTuple("max"));
	select_shape(MeanLeadRsltRegion, &MeanLeadRsltRegion, HTuple("width").Concat("height"), HTuple("and"), HTuple(4).Concat(4), HTuple("max").Concat("max"));
	connection(MeanLeadRsltRegion, &MeanLeadRsltRegion);
	//NumMean
	count_obj(MeanLeadRsltRegion, &NumMean);
	numMeanR = (long)NumMean[0];


	dilation_rectangle1(RsltUPRegion, &UpLeadRgn2, 5, 5);
	reduce_domain(*image, RsltUPRegion, &UpLeadReduced2);
	emphasize(UpLeadReduced2, &UpLeadEmphasize, 11, 11, 2);
	edges_sub_pix(UpLeadEmphasize, &UpLeadEdge, HTuple("lanser2"), HTuple(0.5), HTuple(20), HTuple(40));
	segment_contours_xld(UpLeadEdge,  &ContoursSplit, HTuple("lines"), HTuple(5), HTuple(4), HTuple(2));
	select_contours_xld(ContoursSplit, &SelectedContours, HTuple("contour_length"), HTuple(0.5), HTuple(200), HTuple(-0.5), HTuple(0.5));
	union_collinear_contours_xld(SelectedContours, &UnionContours, HTuple(10), HTuple(5), HTuple(2), HTuple(0.5), HTuple("attr_forget"));
	select_contours_xld(UnionContours, &SelectedContours1, HTuple("contour_length"), HTuple(0.5), HTuple(200), HTuple(-0.5), HTuple(0.5));
	regress_contours_xld(SelectedContours1, &RegressContours1, HTuple("drop"), HTuple(1));
	smallest_rectangle2_xld(RegressContours1, &EdgeRow, &EdgeColumn, &EdgePhi, &EdgeLength1, &EdgeLength2);
//	connection(RegressContours1, &RegressContours1);
	count_obj(RegressContours1, &Num);
	numEdge = (long)Num[0];

	if(0 < numMeanR)
	{
		for(int j = 0; j < numMeanR; j++)
		{
			Checkintersection = 0;
			select_obj(MeanLeadRsltRegion, &SelectRgn2, j + 1);
			//intensity(SelectRgn, *image2, &Mean, _);intersectionRgn

			
			for(i = 0; i < numEdge; i++)
			{
				gen_empty_obj(&intersectionRgn);
				gen_empty_obj(&intersectionRsult);

				if((long)EdgeRow[i]>((long)LeadRow1[0]+5) && (long)EdgeRow[i]<((long)LeadRow2[0]-5) && (long)EdgeColumn[i]>((long)LeadCol1[0]+5) && (long)EdgeColumn[i]<((long)LeadCol2[0]-5))
				{
					gen_rectangle2(&EdgeRect[i], (long)EdgeRow[i], (long)EdgeColumn[i], (long)EdgePhi[i], (long)EdgeLength1[i]+5, (long)EdgeLength2[i]+5);
				
					intersection(SelectRgn2, EdgeRect[i], &intersectionRgn);
					select_shape(intersectionRgn,&intersectionRsult, HTuple("area"),HTuple("and"),HTuple(10),HTuple("max"));
					
					count_obj(intersectionRsult, &Numintersection);

					if( (long)Numintersection[0] > 0 )
					{
					//	union2(RsltRegion, SelectRgn2, &RsltRegion);
						Checkintersection++;
					}	
				}
			}

			if(Checkintersection > 0)
			{
				union2(RsltRegion, SelectRgn2, &RsltRegion);
			}
		}
	}

    
	//CHOKI20100827

	/////////////////////////////////////////////

	//Image
	count_obj(RsltRegion, &Num);

	*rslt_num = (long)Num[0];

	if(0 < *rslt_num)
	{
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(RsltRegion, win);
		}

		rslt = FALSE;
	}
	copy_obj(RsltRegion, rslt_region, 1, -1);

	//Image2
	count_obj(RsltRegion2, &Num);

	*rslt_num2 = (long)Num[0];

	if(0 < *rslt_num2)
	{
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(RsltRegion2, win);
		}

		rslt = FALSE;
	}

	copy_obj(RsltRegion2, rslt_region2, 1, -1);

	copy_obj(RsltUPRegion, rslt_up_region, 1, -1);

	close_all_measures();

	return rslt;
}

/*
	if(UpLead(0, GetHalRedImage(cam_idx, buf_idx, 3), //CHOKI20101028
			GetHalBlueImage(cam_idx, buf_idx, 3),//CHOKI20101031
			GetHalGreenImage(cam_idx, buf_idx, 1), //CHOKI20101102						
			GetHalRedImage(cam_idx, buf_idx, 5),      //20110601 lee
			GetHalGreenImage(cam_idx, buf_idx, 3), //CHOKI20101116
			GetHalGreenImage(cam_idx, buf_idx, 5), //CHOKI20110511
			GetHalBlueImage(cam_idx, buf_idx, 5), //CHOKI20110511
			GetHalGreenImage(cam_idx, buf_idx, 2), //CHOKI20110703
			GetHalGreenImage(cam_idx, buf_idx, 4), //CHOKI20110831
*/

BOOL  C_VisionModule::_Hal_UpLeadColor(long win, Hobject *image0, Hobject *image1, Hobject *image2, 
									   Hobject *image3, Hobject *image4, Hobject *image5,  Hobject *image6, Hobject *image7,
									   Hobject *image8,
							RECT ins_region, RECT ins_region2, RECT ins_region3,
							Hobject not_sr_region, 
							Hobject up_region,
							Hobject up_region2,
							Hobject up_region3,
							double offset_ox, double offset_oy, 
							double offset_ox2, double offset_oy2, 
							double offset_rx, double offset_ry,
							double offset_rx2, double offset_ry2,
						   int thresh, double factor, int tolerance, //CHOKI20101116 factor : 스크래치 검출용 이진화값으로 차용
						   int thresh_dirt, int tolerance_dirt,
						   long *rslt_num, Hobject *rslt_region, 
						   long *rslt_num2, Hobject *rslt_region2, 						   
						   Hobject *rslt_up_region,
						   long min_area, long min_width, long min_height, unsigned int checkleadpos)
{
	BOOL rslt = TRUE;
	HTuple   Pointer, Type, Width, Height, WindowHandle, Row1;
	HTuple   Column1, Row2, Column2, Row, Sum, Column, Diff;
	HTuple   Length1, UntilHeight, Start, MeasureHandle0, MeasureHandle1;
	HTuple   RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond;
	HTuple   ColumnEdgeSecond, AmplitudeSecond, IntraDistance;
	HTuple   InterDistance, End, Time;
	Hobject  I, InsRegion, DontCare;
	Hobject  Line, TotLine, select_object;
	HTuple   Num;
	HTuple HomMat2D;

	Hobject RegionDiff;
	Hobject OutRgn, SelectRgn, ResultRgn;
	HTuple Mean, MeanG, OutMean;
	Hobject ComplRgn, EmpImage;

	Hobject Region, SubImage;
	HTuple DiffAng;

	Hobject MeanImage;
	Hobject TotDirtyRgn, DirtyRgn, LineRgn, ImageReduced, ImageInvert, ImageEmpha;
	HTuple Min, Max, Area;
	HTuple TotalArea;

	//CHOKI20100823
	HTuple LeadRow1, LeadCol1, LeadRow2, LeadCol2;
	Hobject EdgeRgn, EdgeRgnReduced, EdgeThesh, EdgeRsltRegion;

	//CHOKI20100827
	Hobject UpLeadRgn2, UpLeadReduced2, UpLeadEmphasize, UpLeadEdge, UpLeadEdgeRsltRegion2;
	Hobject ContoursSplit, SelectedContours, UnionContours, SelectedContours1, RegressContours1;
	HTuple  EdgeRow, EdgeColumn, EdgePhi, EdgeLength1, EdgeLength2;
	Hobject MeanLeadReduced, MeanLeadThesh, MeanLeadRsltRegion, SelectRgn2, intersectionRgn, intersectionRsult;
	HTuple   NumMean, Numintersection;

	//CHOKI20101028
	Hobject ThreshReduced, ErosionRgn, DilationRgn, ConnectionRgn;
	Hobject ThreshReducedD, ConnectionRgnD;
	long TotalCount = 0;

	//CHOKI20101031
	Hobject ImageReduced2, RegionDifference, DifferenceThresh, ErosionRgn2, DilationRgn2, ConnectionRgn2, SelectShape;
	Hobject RegionClosing;//CHOKI20101123


	Hobject NotSRRgn, EmpImage2, InterRgn;

//	long i, num;

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*image1, &Pointer, &Type, &Width, &Height);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_26!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}
	
	long row = ins_region.top + 1;
	long col = (ins_region.left + ins_region.right) * 0.5;
	long leng1 = (ins_region.right - ins_region.left) * 0.5;
	long height = (ins_region.bottom - ins_region.top) - 1;

	//CHOKI20101123
	Hobject DifferArea, DifferAreaAffine;
	gen_rectangle1(&DifferArea, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.right);

	Hobject RsltRegion, RsltRegion2, RsltUPRegion;

	gen_empty_obj(&RsltRegion);
	gen_empty_obj(&RsltRegion2);
	gen_empty_obj(&RsltUPRegion);

	angle_ll(offset_oy, offset_ox, offset_oy2, offset_ox2, offset_ry, offset_rx, offset_ry2, offset_rx2, &DiffAng);


//	if(0.4 > factor)
//	{
//		factor = 0.4;
//	}

	gen_rectangle1(&Region, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.right);

	vector_angle_to_rigid(offset_oy, offset_ox, HTuple(0), offset_ry, offset_rx, DiffAng, &HomMat2D);
	affine_trans_region(up_region, &RsltUPRegion, HomMat2D, HTuple("false"));
	affine_trans_region(DifferArea, &DifferAreaAffine, HomMat2D, HTuple("false"));//CHOKI20101123

	gen_rectangle1(&InsRegion, ins_region.top, ins_region.left, ins_region.bottom, ins_region.right);
	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(InsRegion, win);
	}

	//Image1/////////////////////////////////////

	gen_empty_obj(&Line);
	gen_empty_obj(&TotLine);

	HTuple RowT, ColT, Row1T, COl1T;
	smallest_rectangle1(RsltUPRegion, &RowT, &ColT, &Row1T, &COl1T);
	//미세한 오염(포팅 자국등) :
	//20110601 lee //////////////////////////////////
	HTuple Mean0624, Mean1021; //CHOKI20111021
	Hobject EroUPRegion; //CHOKI20110821
	invert_image(*image3, &ImageInvert);
	emphasize(ImageInvert, &ImageEmpha, 5,5,3); //20110606 lee
	erosion_rectangle1(RsltUPRegion, &EroUPRegion, 1, 5); //20110821
   	reduce_domain(ImageEmpha, EroUPRegion, &ImageReduced); //CHOKI20110821 RsltUPRegion -> EroUPRegion
//	emphasize(ImageReduced, &ImageReduced, 5,5,3); //20110606 lee
	intensity(RsltUPRegion, *image3, &Mean, _);

	if(thresh-50 < 10) thresh = 60; //20110616 lee

	set_check("~give_error");
	herr = hysteresis_threshold(ImageReduced,&ThreshReduced,HTuple(thresh-70),HTuple(thresh-5),HTuple(10));  
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_07!... %ld", (long)thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(ThreshReduced, &ConnectionRgn);
	select_shape(ConnectionRgn, &ConnectionRgn, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance).Concat(tolerance), HTuple(100).Concat(100));
	select_shape(ConnectionRgn, &ConnectionRgn, HTuple("area"), HTuple("and"), HTuple(tolerance), HTuple(300)); //CHOKI20110603 10000->150 미세오염이 일정수준 이상 클경우 OVK
	//CHOKI20110702 Area의 기준값 150->300 미검발생으로 수준 높임
	dilation_rectangle1(ConnectionRgn, &DilationRgn, 4, 4);
	connection(DilationRgn, &ConnectionRgn);
	count_obj(ConnectionRgn, &Num);
	
	//20110611 lee
	if(0 < (long)Num[0])
	{
		for(int i = 0; i < (long)Num[0]; i++) 
		{
			select_obj(ConnectionRgn, &SelectRgn, i + 1);
			area_center(SelectRgn, &Area, _, _); //CHOIKI20110603
#ifdef AVI_TYPE_1
			intensity(SelectRgn, *image0, &Mean1021, _); //CHOKI20111021	//AVI_TYPE_1//
			intensity(SelectRgn, *image3, &Mean0624, _);
			if((long)Area[0] < 400  && (long)Mean0624[0] < 200 && (long)Mean1021[0] < 200) //20110626 lee 180->160 으로 변경 3Pf에서 OVK발생  //CHOKI20110717 190->140	//AVI_TYPE_1//
#else
			intensity(SelectRgn, *image3, &Mean0624, _);
			if((long)Area[0] < 400  && (long)Mean0624[0] < 135) //20110626 lee 180->160 으로 변경 3Pf에서 OVK발생  //CHOKI20110717 190->140 // 111103 ytlee 140 -> 135
#endif
				union2(RsltRegion, SelectRgn, &RsltRegion);	//CHOKI20110702 180->300, 160->180 으로 변경 => 미약한 오염 미검발생	
		}    //CHOKI20110702 Area의 기준값 180->300->400 미검발생으로 수준 높임 //CHOKI20110821 Mean0624 : 140->130
		count_obj(RsltRegion, &Num); //CHOKI20110926 Mean0624 140->200 //CHOKI20111021 Mean1021 조건 추가
		if(0 < (long)Num[0])
		{
			*rslt_num += (long)Num[0];
			rslt = FALSE; 
		}
	}
	
//	union2(RsltRegion, RsltUPRegion, &RsltRegion);
//	*rslt_num ++;
//	rslt = FALSE; 
	
	
	//CHOKI20101116 약한 스크래치 검출용
	HTuple MeanSC;
	
	intensity(RsltUPRegion, *image4, &MeanSC, _);
	//20110602 lee
	Hobject ImageEmphasize, ImageReducedSC, ThreshReducedSC, ErosionRgnSC, DilationRgnSC, ConnectionRgnSC, RsltRegionSC;//CHOKI20101116
	
	//CHOKI20101117
	Hobject SelectRgnSC;
	HTuple CircleVarSC, MeanSC2, MeanSCArea; //CHOKI20110715
	unsigned int CheckCountSC = 0;
	Hobject DilationRgnSelect, DiffSelect; //CHOKI20110715
	HTuple MeanSC5, RowSC1, ColumnSC1, RowSC2, ColumnSC2; //CHOKI20110720
	HTuple AreaSC, RowSCC, ColumnSCC; //CHOKI20110720
	unsigned int LimitStartPos, LimitEndPos; //CHOKI20110720
#ifdef AVI_TYPE_1
	emphasize(*image4, &ImageEmphasize, 10,10,2);	//AVI_TYPE_1//
#else
	emphasize(*image4, &ImageEmphasize, 6,6,2);		// 110919 10,10,2->6,6,2
#endif
	//	reduce_domain(*image4, RsltUPRegion, &ImageReducedSC);	 //20110602 lee
	reduce_domain(ImageEmphasize, RsltUPRegion, &ImageReducedSC);	 //20110602 lee

	//CHOKI20110720
	smallest_rectangle1(RsltUPRegion,&RowSC1,&ColumnSC1,&RowSC2,&ColumnSC2);

	LimitStartPos = (long)ColumnSC1[0] + 100;
	LimitEndPos = (long)ColumnSC2[0] - 100;

	if(LimitStartPos > LimitEndPos) 
	{
		LimitStartPos = (long)ColumnSC1[0];
		LimitEndPos = (long)ColumnSC2[0];
	}
	if(LimitStartPos > 2000)
	{
		LimitStartPos = 490;
	}
	if(LimitEndPos < 800)
	{
		LimitEndPos = 1800;
	}
	//CHOKI20110720

	//CHOKI20110603
	if((long)MeanSC[0] <= factor || (long)MeanSC[0] <= 0)
	{
		factor = -10;
	}
	
	set_check("~give_error");
	herr = threshold(ImageReducedSC,&ThreshReducedSC,HTuple(0),HTuple((long)MeanSC[0] - (factor+5)));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_43!... %ld, %ld", (long)MeanSC[0], (long)factor);		// HTuple, double
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	
	
	erosion_rectangle1(ThreshReducedSC, &ErosionRgnSC, 1, 2); //20110617 lee 1->2
	dilation_rectangle1(ErosionRgnSC, &DilationRgnSC, 1, 1);
	
	connection(DilationRgnSC, &ConnectionRgnSC);
	
//	select_shape(ConnectionRgnSC, &RsltRegionSC, HTuple("width").Concat("height"), HTuple("and"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));
#ifdef AVI_TYPE_1
	select_shape(ConnectionRgnSC, &RsltRegionSC, HTuple("width"), HTuple("or"), HTuple(1), HTuple("max")); //20110618 lee	// 110929 ytlee 2->1	//AVI_TYPE_1//
#else
	select_shape(ConnectionRgnSC, &RsltRegionSC, HTuple("width"), HTuple("or"), HTuple(2), HTuple("max")); //20110618 lee
#endif
	select_shape(RsltRegionSC, &RsltRegionSC, HTuple("height"), HTuple("or"), HTuple(tolerance), HTuple("max")); //20110617 lee
	select_shape(RsltRegionSC, &RsltRegionSC, HTuple("area"), HTuple("and"), HTuple(tolerance), HTuple("max"));
	
	connection(RsltRegionSC, &RsltRegionSC); 
	
	count_obj(RsltRegionSC, &Num);
		
	if(0 < (long)Num[0])
	{
		for(int i = 0; i < (long)Num[0]; i++)
		{
			select_obj(RsltRegionSC, &SelectRgnSC, i + 1);
			circularity(SelectRgnSC, &CircleVarSC);	
			intensity(SelectRgnSC, *image4, &MeanSC5, _); //CHOKI20110720
			area_center(SelectRgnSC, &AreaSC, &RowSCC, &ColumnSCC); //CHOKI20110720
			//CHOKI20110715
			intensity(SelectRgnSC, *image5, &MeanSC2, _);
//			dilation_rectangle1(SelectRgnSC, &DilationRgnSelect, 3, 3);
//			difference(DilationRgnSelect, SelectRgnSC, &DiffSelect);
//			intensity(DiffSelect, *image5, &MeanSCArea, _);
#ifdef AVI_TYPE_1			
			if((double)CircleVarSC[0] < 0.6 && (long)MeanSC2[0] > 180) //CHOKI20110922 185->160		110928 Circlarity: 0.79	//AVI_TYPE_1//
			{ //CHOKI20110928 CircleVarSC 0.5 -> 0.6
				//CHOKI20110720
			//	union2(RsltRegion, RsltRegionSC, &RsltRegion);	
			//	CheckCountSC++;
				if((long)ColumnSCC[0] < LimitStartPos || (long)ColumnSCC[0] > LimitEndPos)
				{
					if((long)MeanSC5[0] < ((long)MeanSC[0]-15))		// 110829 ytlee 40 -> 25	// 110901 25 -> 30 과검 발생으로 수정		//110928 20 ->15	//AVI_TYPE_1//
					{ //CHOKI20110922 -30->-20
						union2(RsltRegion, RsltRegionSC, &RsltRegion);	
						CheckCountSC++;
					}
				}
				else
				{
					if((long)MeanSC5[0] < ((long)MeanSC[0]-15)) //CHOKI20110725		// 110829 ytlee 40 -> 25	// 110901 25 -> 30 과검 발생으로 수정 //110928 20 ->15	//AVI_TYPE_1//
					{
						union2(RsltRegion, RsltRegionSC, &RsltRegion);	
						CheckCountSC++;
					}
				}
				//CHOKI20110720
#else
			if((double)CircleVarSC[0] < 0.5 && (long)MeanSC2[0] > 185)
			{
				//CHOKI20110720
			//	union2(RsltRegion, RsltRegionSC, &RsltRegion);	
			//	CheckCountSC++;
				if((long)ColumnSCC[0] < LimitStartPos || (long)ColumnSCC[0] > LimitEndPos)
				{
					if((long)MeanSC5[0] < ((long)MeanSC[0]-40))		// 110829 ytlee 40 -> 25	// 110901 25 -> 30 과검 발생으로 수정	// 110919 30->40
					{
						union2(RsltRegion, RsltRegionSC, &RsltRegion);	
						CheckCountSC++;
					}
				}
				else
				{
					if((long)MeanSC5[0] < ((long)MeanSC[0]-40)) //CHOKI20110725		// 110829 ytlee 40 -> 25	// 110901 25 -> 30 과검 발생으로 수정	// 110919 30->40
					{
						union2(RsltRegion, RsltRegionSC, &RsltRegion);	
						CheckCountSC++;
					}
				}
#endif		
			}
			
		}
		//20110611 lee
		if(CheckCountSC > 0)
		{
			*rslt_num += CheckCountSC;
			connection(RsltRegion, &RsltRegion);
			rslt = FALSE;
		}
		
	}
	//CHOKI20101116 약한 스크래치 검출용

	//CHOKI20110703 약한 스크래치 검출용2
	Hobject SCFindReduced, SCFindThesh, SCFindSobel, SCFindClosing, SCFindConnect, SCFindResult;
	HTuple  SCFindMean;

	reduce_domain(*image4, RsltUPRegion, &SCFindReduced);
	sobel_amp(SCFindReduced, &SCFindSobel, HTuple("sum_abs"), HTuple(3));

	set_check("~give_error");
	//3Pf 모델 임시 대응 20110721 lee
#ifdef AVI_TYPE_1
	herr = threshold(SCFindSobel,&SCFindThesh,HTuple(30),HTuple(255)); //threshold(SCFindSobel,&SCFindThesh,HTuple(23),HTuple(255));		// 111010 ytlee 20 -> 30 Outlead 패턴이 굵은 경우	//AVI_TYPE_1//
//	herr = threshold(SCFindSobel,&SCFindThesh,HTuple(70),HTuple(255)); //threshold(SCFindSobel,&SCFindThesh,HTuple(23),HTuple(255));
#else
	//Gate Model은 차이가 난다. 임시 적용 20110919 lee 
	if(m_VDat[0]->m_InsPara.m_iParaBase[2] == 2 || m_VDat[0]->m_InsPara.m_iParaBase[2] == 3)
		herr = threshold(SCFindSobel,&SCFindThesh,HTuple(80),HTuple(255)); 
	else
		herr = threshold(SCFindSobel,&SCFindThesh,HTuple(70),HTuple(255)); 
#endif
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_44!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}		
	
	closing_circle(SCFindThesh, &SCFindClosing, 15);
	connection(SCFindClosing, &SCFindConnect);

	select_shape(SCFindConnect, &SCFindResult, HTuple("width"), HTuple("or"), HTuple(2), HTuple("max")); 
	select_shape(SCFindResult, &SCFindResult, HTuple("height"), HTuple("or"), HTuple(tolerance+1), HTuple("max")); 
	select_shape(SCFindResult, &SCFindResult, HTuple("area"), HTuple("and"), HTuple(tolerance+2), HTuple("max"));
	count_obj(SCFindResult, &Num);

	if(0 < (long)Num[0])
	{
		for(int i = 0; i < (long)Num[0]; i++)
		{
			select_obj(SCFindResult, &SelectRgnSC, i + 1);
		
			union2(RsltRegion, SelectRgnSC, &RsltRegion);	
			CheckCountSC++;
		}
			
		//20110611 lee
		if(CheckCountSC > 0)
		{
			*rslt_num += CheckCountSC;
			connection(RsltRegion, &RsltRegion);
			rslt = FALSE;
		}		
	}
	//CHOKI20110703 약한 스크래치 검출용2
	

	///CHOKI20101031///////////////////////////
	//약한 변색 검출 및 이물 필터링.
//	difference(RsltUPRegion, DifferAreaAffine, &RegionDifference);//CHOKI20101123
	erosion_rectangle1(RsltUPRegion,&RsltUPRegion,50,2); //CHOKI20110831 150->50
	reduce_domain(*image1, RsltUPRegion, &ImageReduced2);//CHOKI20101101
	mean_image(ImageReduced2, &ImageReduced2,10,10);	

	//CHOKI20101117
	HTuple MeanC;
	intensity(RsltUPRegion, *image1, &MeanC, _);
	int CountCheck = 0;
	long lArea;
	long lDefectSize;

	HTuple Mean7; //CHOKI20110703
	HTuple Mean8, LeadMean8; //CHOKI20110831
	HTuple MeanRed0, MeanBlue02, Area2; //CHOKI20110819

	area_center(RsltUPRegion, &Area, _, _);
	lArea = (long)Area[0];
	lDefectSize = (long)(lArea * (tolerance_dirt * 0.01));

	
	//20110618 lee
	if((long)MeanC[0] > 138)
	{
		set_check("~give_error");
		herr = threshold(ImageReduced2,&DifferenceThresh,HTuple(0),HTuple(thresh_dirt+5));
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_45!... %ld", (long)thresh_dirt);
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}	
	}
	else
	{
#ifdef AVI_TYPE_1
		thresh_dirt += (long)MeanC[0] - 140;//thresh_dirt += (long)MeanC[0] - 120;	//AVI_TYPE_1//
#else
		thresh_dirt += (long)MeanC[0] - 138;
#endif
		if(thresh_dirt < 100) thresh_dirt = 100; 
		{
			set_check("~give_error");
			herr = threshold(ImageReduced2,&DifferenceThresh,HTuple(0),HTuple(thresh_dirt));
			set_check("give_error");
			if(H_MSG_TRUE == herr)
			{
			}
			else
			{
				status.Format("Halcon Error Occured at threshold_46!... %ld", (long)thresh_dirt);
				WriteErrorList((LPCTSTR)status);
				return FALSE;
			}
		}			
	}

	intensity(RsltUPRegion, *image1, &MeanBlue02, _); //CHOKI20110819

	closing_rectangle1(DifferenceThresh, &DifferenceThresh, 20, 20);//&RegionClosing, 3, 6);//CHOKI20101123
	select_shape(DifferenceThresh, &DifferenceThresh, HTuple("width").Concat("height"), HTuple("and"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));
	select_shape(DifferenceThresh, &SelectShape, HTuple("area"), HTuple("and"), HTuple(lDefectSize), HTuple("max"));

	connection(SelectShape, &SelectShape);

	count_obj(SelectShape, &Num);

	if(0 < (long)Num[0])
	{
		for(int i = 0; i < (long)Num[0]; i++)
		{
			select_obj(SelectShape, &SelectRgn2, i + 1);
			intensity(SelectRgn2, *image7, &Mean7, _); //CHOKI20110703
			intensity(SelectRgn2, *image1, &MeanRed0, _); //CHOKI20110810
			intensity(SelectRgn2, *image8, &Mean8, _); //CHOKI20110831
			intensity(RsltUPRegion, *image8, &LeadMean8, _); //CHOKI20110831
			area_center(SelectRgn2, &Area2, _, _);
			//AVI_TYPE_1//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#ifdef AVI_TYPE_1
			if((long)Mean7[0] < 190 && (long)MeanBlue02[0] - (long)MeanRed0[0] > 15 && (long)Area2[0] > lDefectSize && (long)LeadMean8[0] - (long)Mean8[0] > 5) //미검발생으로 인하여 190->200으로 변경  //CHOKI20110815 검사설정 190->220 및 Red0삭제	// 110816 ytlee 220 -> 190	// 111011 ytlee 200 -> 190, 5 -> 10
			{ //CHOKI20110818 MeanRed0 160->190으로 변경하여 추가 적용하였으나 미검의 소지가 있어 일단 제거함	// 110830 15 -> 5		// 111010 ytlee 200 -> 190
				union2(RsltRegion, SelectRgn2, &RsltRegion); //CHOKI20110925 (long)MeanBlue02[0] - (long)MeanRed0[0] > 20 ->5
				CountCheck++;		
			}
//			else if((long)Mean7[0] < 190 && (long)MeanBlue02[0] - (long)MeanRed0[0] > 0 && (long)Area2[0] > lDefectSize && (long)LeadMean8[0] - (long)Mean8[0] > 0) 
//			{ //CHOKI20110925 리드 전체에 변색이 발생할 경우 대비	// 111010 ytlee 200 -> 190
//				union2(RsltRegion, SelectRgn2, &RsltRegion); 
//				CountCheck++;		
//			}
			else if((long)Mean7[0] < 230 && (long)MeanBlue02[0] - (long)MeanRed0[0] > 20 && (long)Area2[0] > lDefectSize && (long)LeadMean8[0] - (long)Mean8[0] > 5) 
			{ //CHOKI20110925 기준이미지의 변색은 적으나 비교이미에서 차이값이 클경우 사용
				union2(RsltRegion, SelectRgn2, &RsltRegion); 
				CountCheck++;		
			}
			else if((long)Mean7[0] < 230 && (long)MeanBlue02[0] - (long)MeanRed0[0] > 15 && (long)Area2[0] > lDefectSize && (long)LeadMean8[0] - (long)Mean8[0] > 10) 
			{ //CHOKI20110925 기준이미지의 변색은 적으나 비교이미에서 차이값이 클경우 사용
				union2(RsltRegion, SelectRgn2, &RsltRegion); 
				CountCheck++;		
			}
			//AVI_TYPE_1//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#else
			if((long)Mean7[0] < 240 && (long)MeanBlue02[0] - (long)MeanRed0[0] > 20 && (long)Area2[0] > lDefectSize && (long)LeadMean8[0] - (long)Mean8[0] > 5) //미검발생으로 인하여 190->200으로 변경  //CHOKI20110815 검사설정 190->220 및 Red0삭제	// 110816 ytlee 220 -> 190
			{ //CHOKI20110818 MeanRed0 160->190으로 변경하여 추가 적용하였으나 미검의 소지가 있어 일단 제거함	// 110830 15 -> 5	// 110923 (long)MeanBlue02[0] - (long)MeanRed0[0] > 20->10 110928 15 ->20
				union2(RsltRegion, SelectRgn2, &RsltRegion);
				CountCheck++;		
			}
#endif
		}
		//20110611 lee	
		if(CountCheck > 0)
		{
			*rslt_num += CheckCountSC;
			connection(RsltRegion, &RsltRegion);
			rslt = FALSE;
		}
	}
	
	//Image
	count_obj(RsltRegion, &Num);

	*rslt_num = (long)Num[0];

	if(0 < *rslt_num)
	{
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(RsltRegion, win);
		}

		rslt = FALSE;
	}
	copy_obj(RsltRegion, rslt_region, 1, -1);

	copy_obj(RsltUPRegion, rslt_up_region, 1, -1);

	return rslt;
}

//상부긁힘(in lead)
BOOL C_VisionModule::UpLeadScratch(long win, Hobject *image, Hobject rslt_up_region, 
							 int thresh, int tolerance, long *rslt_num, Hobject *rslt_region)
{
	BOOL rslt = TRUE;
	long min_area, min_width, min_height;
	min_area = VISION_FACT_MIN_AREA;
	min_width = VISION_FACT_MIN_WIDTH;
	min_height = VISION_FACT_MIN_HEIGHT;

	Hobject ImageReduced, Region, RegionClosing, InsRgn, RsltRgn, EmpImage;
	HTuple Num;

	int min_thresh, max_thresh;

	//런타임 up lead 영역////////////////////////
	reduce_domain(*image, rslt_up_region, &ImageReduced);

	emphasize(ImageReduced,&EmpImage,HTuple(27),HTuple(27),HTuple(2));

	max_thresh = thresh;
	min_thresh = max_thresh - 100;
	if(100 > min_thresh)
	{
		min_thresh = 100;
		max_thresh = 150;
	}

	if(min_thresh > max_thresh) min_thresh = max_thresh -10; //20110616 lee

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = hysteresis_threshold(EmpImage,&Region,HTuple(min_thresh),HTuple(max_thresh),HTuple(20));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_08!... %ld, %ld", (long)min_thresh, (long)max_thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	
	connection(Region, &Region);
	closing_circle(Region,&RegionClosing,HTuple(3.5));

	select_shape(RegionClosing, &RegionClosing, HTuple("area"), HTuple("and"), HTuple(min_area), HTuple("max"));
	select_shape(RegionClosing, &RegionClosing, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width).Concat(min_height), HTuple("max").Concat("max"));
	select_shape(RegionClosing, &RsltRgn, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));

	Hobject select_object;
	HTuple Row1, Column1, Row2, Column2;

	connection(RsltRgn, &RsltRgn);

	count_obj(RsltRgn, &Num);
	*rslt_num = (long)Num[0];
	if(0 < *rslt_num)
	{
		copy_obj(RsltRgn, rslt_region, 1, -1);
		
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(*rslt_region, win);
		}

		return FALSE;
	}

	return TRUE;
}

//SR 기포검사 & Hall 검사
BOOL C_VisionModule::SRBub(long win, Hobject *image, Hobject *hall_image, RECT ins_sr_region, RECT ins_film_region,
						   long var_id, double offset_ox, double offset_oy, double offset_rx, double offset_ry,
						   int abs_thresh, int var_thresh, int mold_fact, int tolerance, 
						   int tol_max, int tol_cnt,
						   int hall_thresh, int hall_tol,
						   int fold_thresh, int fold_tol,
			               long *rslt_num, Hobject *rslt_region, Hobject *rslt_sr_region,
						   long *rslt_hall_num, Hobject *rslt_hall_region, Hobject *rslt_hallins_region)
{
	BOOL rslt = TRUE;
	Hobject Image, ImageTrans, RegionDiff, ImageReduced;
	Hobject	RegionRect, RegionRectChip, ChipRect, OCVRect;
	HTuple HomMat2D, Num;
	Hobject select_object;

	Hobject OutRgn, SelectRgn, ResultRgn, ChipRegionRect;
	HTuple Mean, OutMean;
	int diff_var;
	Hobject ComplRgn;

	Hobject MeanImage, MeanImageReduced, HallImageReduced, HallRegion, DilRegion;
	long offset_x, offset_y;

	int i;

	int thresh, high_threshold;

	long num;

	gen_rectangle1(&RegionRect, (long)(ins_sr_region.top), 
								(long)(ins_sr_region.left), 
								(long)(ins_sr_region.bottom), 
								(long)(ins_sr_region.right));


	gen_rectangle1(&RegionRectChip, (long)(ins_film_region.top), 
								(long)(ins_film_region.left), 
								(long)(ins_film_region.bottom), 
								(long)(ins_film_region.right));


	//20100315 lss
	// 검사를 위한 조건을 넣습니다. 등록된 이미지와의 밝기 (임계)값차이와 변화 영상에 대한 조건을 넣습니다(inspection).
	//prepare_variation_model(var_id, HTuple(abs_thresh), HTuple(var_thresh));
		
    mean_image(*image, &Image, HTuple(mold_fact), HTuple(mold_fact));
	
	vector_angle_to_rigid(offset_ry, offset_rx, 0, offset_oy, offset_ox, HTuple(0), &HomMat2D);


	reduce_domain(Image, RegionRectChip, &ImageTrans);
	affine_trans_image(ImageTrans, &ImageTrans, HomMat2D, HTuple("constant"), HTuple("false"));
	
	reduce_domain(ImageTrans, RegionRect, &ImageReduced);
	
	// Template 검사(등록이미지와 변화이미지를 가지고 비교 검사를 합니다.)
	//compare_variation_model(ImageReduced, &RegionDiff, var_id);

	closing_circle(RegionDiff, &RegionDiff, 5.5);
	connection(RegionDiff, &RegionDiff);
	//select_shape(RegionDiff, &RegionDiff, HTuple("area"), HTuple("and"), HTuple(tolerance),  HTuple("max"));
	select_shape(RegionDiff, &RegionDiff, HTuple("ra").Concat("rb"), HTuple("and"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));

	vector_angle_to_rigid(offset_oy, offset_ox, 0, offset_ry, offset_rx, HTuple(0), &HomMat2D);
	affine_trans_region(RegionRect,rslt_sr_region,HomMat2D,HTuple("false"));

	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(*rslt_sr_region, win);
	}

	gen_empty_obj(&ResultRgn);

	//경계값 및 max tol 비교
	BOOL max_chk = FALSE;
	HTuple RA;
	count_obj(RegionDiff, &Num);
	*rslt_num = (long)Num[0];
	for(i = 0; i < *rslt_num; i++)
	{
		select_obj(RegionDiff, &SelectRgn, i + 1);
		dilation_circle(SelectRgn, &OutRgn, 5.5);
		difference(OutRgn, SelectRgn, &OutRgn);
		intensity(SelectRgn, ImageTrans, &Mean, _);
		intensity(OutRgn, ImageTrans, &OutMean, _);
		diff_var = ((long)OutMean[0]) - ((long)Mean[0]);
		elliptic_axis(SelectRgn, &RA, _, _);

		if(0 < diff_var)
		{

		}
		else
		{
			if((double)RA[0] > tol_max)
			{
				max_chk = TRUE;
			}

			//Light(-)
			//diff_var = abs(diff_var);
			//if( (abs_thresh * 0.5) < diff_var)
			//if(0 < diff_var)
			//{
				concat_obj(ResultRgn, SelectRgn, &ResultRgn);
			//}
		}
	}

	count_obj(ResultRgn, &Num);

	long chk = (long)Num[0];

	if( max_chk || (tol_cnt <= chk) )
	{
		*rslt_num = (long)Num[0];
	}
	else
	{
		*rslt_num = 0;
	}

	if(0 < *rslt_num)
	{
		vector_angle_to_rigid(offset_oy, offset_ox, 0, offset_ry, offset_rx, HTuple(0), &HomMat2D);
		affine_trans_region(RegionDiff,rslt_region,HomMat2D,HTuple("false"));
		affine_trans_region(RegionRect,rslt_sr_region,HomMat2D,HTuple("false"));
		
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(RegionDiff, win);
		}
	
		rslt = FALSE;
	}


	//찍힘검사///////////////////////////////////
	affine_trans_region(RegionRect,&RegionRect,HomMat2D,HTuple("false"));

	offset_x = offset_rx - offset_ox;
	offset_y = offset_ry - offset_oy;
			
	gen_rectangle1(&ChipRegionRect, (long)(ins_film_region.top + offset_y), 
								(long)(ins_film_region.left + offset_x), 
								(long)(ins_film_region.bottom + offset_y), 
								(long)(ins_film_region.right + offset_x));

	dilation_rectangle1(RegionRect, &DilRegion, 1.5, 1.5);
	difference(ChipRegionRect, DilRegion, rslt_hallins_region);

	Hobject HallImage, InsRgn, OutRgn2;

	dilation_rectangle1(*rslt_hallins_region, &InsRgn, 20.5, 20.5);
	reduce_domain(*hall_image, InsRgn, &HallImage);

	emphasize(HallImage,&HallImage,HTuple(57),HTuple(57),HTuple(1));
	gray_opening_shape(HallImage,&HallImage,HTuple(11),HTuple(11),HTuple("octagon"));
	gray_erosion_shape(HallImage,&HallImage,HTuple(5),HTuple(5),HTuple("octagon"));
	//gray_erosion_shape(HallImage,&HallImage,HTuple(11),HTuple(11),HTuple("octagon"));
	invert_image(HallImage,&HallImage);
	//mean_image(*hall_image, &MeanImage, HTuple(5), HTuple(5));
	reduce_domain(HallImage, *rslt_hallins_region, &HallImageReduced);
	//reduce_domain(MeanImage, *rslt_hallins_region, &MeanImageReduced);
	//dyn_threshold(HallImageReduced, MeanImageReduced, &HallRegion, hall_thresh, HTuple("dark"));
	/*
	emphasize(HallImageReduced,&HallImageReduced,HTuple(57),HTuple(57),HTuple(1));
	gray_opening_shape(HallImageReduced,&HallImageReduced,HTuple(11),HTuple(11),HTuple("octagon"));
	gray_erosion_shape(HallImageReduced,&HallImageReduced,HTuple(5),HTuple(5),HTuple("octagon"));
	invert_image(HallImageReduced,&HallImageReduced);
	*/

	high_threshold = 100 + hall_thresh;
	thresh = high_threshold - 10;
	if(0 > thresh)
	{
		thresh = 0;
		high_threshold = 10;
	}
	else if(255 < thresh)
	{
		thresh = 245;
		high_threshold = 255;
	}
	else if(0 > high_threshold)
	{
		thresh = 0;
		high_threshold = 10;
	}
	else if(255 < high_threshold)
	{
		thresh = 245;
		high_threshold = 255;
	}

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = hysteresis_threshold(HallImageReduced,&HallRegion,HTuple(thresh),HTuple(high_threshold),HTuple(10));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_09!... %ld, %ld", (long)thresh, (long)high_threshold);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	
	//closing_circle(HallRegion, &HallRegion, 5.5);
	closing_circle(HallRegion, &HallRegion, 10.5);
	connection(HallRegion, &HallRegion);

	if(50 <= hall_tol)
	{
		hall_tol = 49;
	}
	select_shape(HallRegion, &HallRegion, HTuple("width").Concat("height"), HTuple("and"), HTuple(hall_tol).Concat(hall_tol), HTuple(100).Concat(100));
	//select_shape(HallRegion, &HallRegion, HTuple("circularity"), HTuple("and"), HTuple(0.7), HTuple("max"));
	select_shape(HallRegion, &HallRegion, HTuple("circularity"), HTuple("and"), HTuple(0.1), HTuple("max"));

	count_obj(HallRegion, &Num);
	num = (long)Num[0];
	long a, b;
	HTuple Area;
	for(i = 0; i < num; i++)
	{
		select_obj(HallRegion, &SelectRgn, i + 1);
		dilation_circle(SelectRgn, &OutRgn, 20.5);
		dilation_circle(SelectRgn, &OutRgn2, 22.5);
		difference(OutRgn2, OutRgn, &OutRgn);
		intensity(SelectRgn, *hall_image, &Mean, _);

		area_center(SelectRgn, &Area, _, _);
		//smallest_rectangle1*(SelectRgn, &Row, &Col, &Row1, &COl1);

		if( 200 < ((long)Area[0]) )
		{
			//intensity(OutRgn, *hall_image, &OutMean, _);
			min_max_gray(OutRgn, *hall_image, 0, &OutMean, _, _);

			diff_var = ((long)OutMean[0]) - ((long)Mean[0]);
			a = ((long)OutMean[0]);
			b = ((long)Mean[0]);

			//if((hall_thresh * 0.0) < diff_var)
			if(10 < diff_var)
			//if(1)
			{
				concat_obj(*rslt_hall_region, SelectRgn, rslt_hall_region);
			}
			else
			{

			}
		}
		else if(50 < ((long)Area[0]))
		{
			//intensity(OutRgn, *hall_image, &OutMean, _);
			min_max_gray(OutRgn, *hall_image, 0, &OutMean, _, _);

			diff_var = ((long)OutMean[0]) - ((long)Mean[0]);
			a = ((long)OutMean[0]);
			b = ((long)Mean[0]);

			//if(1)
			//if((hall_thresh * 0.7) < diff_var)
			if(10 < diff_var)
			{
				concat_obj(*rslt_hall_region, SelectRgn, rslt_hall_region);
			}
			else
			{

			}
		}
		else
		{
			intensity(OutRgn, *hall_image, &OutMean, _);
			//min_max_gray(OutRgn, *hall_image, 0, &OutMean, _, _);

			diff_var = ((long)OutMean[0]) - ((long)Mean[0]);
			a = ((long)OutMean[0]);
			b = ((long)Mean[0]);

			//if((hall_thresh * 0.33) < diff_var)
			if(1)
			//if(10 < diff_var)
			{
				concat_obj(*rslt_hall_region, SelectRgn, rslt_hall_region);
			}
			else
			{

			}
		}


	}

	Hobject FoldInsRgn, FoldImageReduced, FoldRegion;
	
	//구겨짐///////////////////////////////////
	high_threshold = 130 + fold_thresh;
	thresh = high_threshold - 30;
	if(0 > thresh)
	{
		thresh = 0;
		high_threshold = 10;
	}
	else if(255 < thresh)
	{
		thresh = 245;
		high_threshold = 255;
	}
	else if(0 > high_threshold)
	{
		thresh = 0;
		high_threshold = 10;
	}
	else if(255 < high_threshold)
	{
		thresh = 245;
		high_threshold = 255;
	}
	
	erosion_rectangle1(*rslt_hallins_region, &FoldInsRgn, 30.5, 30.5);
	dilation_rectangle1(RegionRect, &DilRegion, 150.5, 150.5);
	difference(FoldInsRgn, DilRegion, &FoldInsRgn);
	reduce_domain(HallImage, FoldInsRgn, &FoldImageReduced);

	set_check("~give_error");
	herr = hysteresis_threshold(FoldImageReduced,&FoldRegion,HTuple(thresh),HTuple(high_threshold),HTuple(10));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_10!... %ld, %ld", (long)thresh, (long)high_threshold);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(FoldRegion, &FoldRegion);
	select_shape(FoldRegion, &FoldRegion, HTuple("area"), HTuple("and"), HTuple(fold_tol), HTuple("max"));
	concat_obj(*rslt_hall_region, FoldRegion, rslt_hall_region);

	count_obj(*rslt_hall_region, &Num);

	*rslt_hall_num = (long)Num[0];

	if(0 < *rslt_hall_num)
	{
		
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(*rslt_hall_region, win);
		}
	
		rslt = FALSE;
	}

	return rslt;
}

//
//
/////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Vision module
//////////////////////////////////////////////////////////////////////

C_VisionModule::C_VisionModule()
{
	if(!CheckLicense())
	{
		AfxMessageBox("Error : C_VisionModule license fail!");
		exit(0);
	}

	for(int i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		m_VDat[i] = new C_VisionData;
	}

	ResetInspectPara();
	ResetInspectRslt();
	ResetSystemPara();
	ResetSystemRslt();
	ResetMainSysPara();
	ResetMainSysRslt();
	ResetShiftRslt();
	ResetInspectNGRslt();
	ResetInspectRsltRgn();
	ResetInspectNGRsltRgn();
	ResetInspectRgn();
	ResetLotInfo();

	for(i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		m_lWindow[i] = 0;
	}

	m_iNGViewMode = -1;

	for(i = 0; i < SUB_RGN_MAX_NUM; i++)
	{
		m_bSRBubPrepare[i] = FALSE;
	}
}

C_VisionModule::~C_VisionModule()
{
	clear_all_shape_models();
	//clear_all_variation_models();

	for(int i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		delete m_VDat[i];
	}
}

BOOL C_VisionModule::CheckLicense()
{
	return TRUE;
}

//CHOKI20101101
void C_VisionModule::CopyRGBtoGrayImage(int cam_idx, int buf_idx, int img_idx)
{
/*	rgb1_to_gray(&m_VDat->m_HalColorImage[m_iBufIdx][i], m_VDat->m_HalImage[m_iBufIdx][i]);
	decompose3(&m_VDat->m_HalColorImage[m_iBufIdx][i], &m_VDat->HalRedImage[m_iBufIdx][i], 
	&m_VDat->&HalGreenImage[m_iBufIdx][i], &m_VDat->HalBlueImage[m_iBufIdx][i]);*/
			
}


//Get/Set data
Hobject *C_VisionModule::GetHalImage(int cam_idx, int buf_idx, int img_idx)
{
	
	if(-1 == m_iNGViewMode)
	{
		return &m_VDat[cam_idx]->m_HalImage[buf_idx][img_idx];
	}
	else
	{
		return &m_VDat[cam_idx]->m_HalNGImage[m_iNGViewMode][img_idx];
	}

}

Hobject *C_VisionModule::GetHalColorImage(int cam_idx, int buf_idx, int img_idx)
{
	return &m_VDat[cam_idx]->m_HalColorImage[buf_idx][img_idx];
}

Hobject *C_VisionModule::GetHalRedImage(int cam_idx, int buf_idx, int img_idx)
{
	return &m_VDat[cam_idx]->m_HalRedImage[buf_idx][img_idx];
}

Hobject *C_VisionModule::GetHalGreenImage(int cam_idx, int buf_idx, int img_idx)
{
	return &m_VDat[cam_idx]->m_HalGreenImage[buf_idx][img_idx];
}

Hobject *C_VisionModule::GetHalBlueImage(int cam_idx, int buf_idx, int img_idx)
{
	return &m_VDat[cam_idx]->m_HalBlueImage[buf_idx][img_idx];
}

//CHOKI20110510
Hobject *C_VisionModule::GetHalRefRedImage(int cam_idx, int img_idx)
{
	return &m_VDat[cam_idx]->m_HalRefRedImage[img_idx];
}

Hobject *C_VisionModule::GetHalRefGreenImage(int cam_idx, int img_idx)
{
	return &m_VDat[cam_idx]->m_HalRefGreenImage[img_idx];
}

Hobject *C_VisionModule::GetHalRefBlueImage(int cam_idx, int img_idx)
{
	return &m_VDat[cam_idx]->m_HalRefBlueImage[img_idx];
}
//CHOKI20110510


Hobject *C_VisionModule::GetHalNGImage(int cam_idx, int ng_view_idx, int img_idx)
{
	return &m_VDat[cam_idx]->m_HalNGImage[ng_view_idx][img_idx];
}	

void C_VisionModule::SetHalNGImage(int cam_idx, int buf_idx, int ng_view_idx)
{
	int i;

	if(-1 == m_iNGViewMode)
	{
		for(i = 0; (i < m_VDat[cam_idx]->m_InsPara.m_iParaBase[1]) && (i < IMAGE_MAP_MAX_NUM); i++)
		{
		//	copy_image(m_VDat[cam_idx]->m_HalImage[buf_idx][i], &m_VDat[cam_idx]->m_HalNGImage[ng_view_idx][i]);
			copy_image(m_VDat[cam_idx]->m_HalColorImage[buf_idx][i], &m_VDat[cam_idx]->m_HalNGImage[ng_view_idx][i]);
		}
	}
}

Hobject *C_VisionModule::GetHalRsltRgn(int cam_idx, int rgn_idx, int ins_idx)
{
	return &m_VDat[cam_idx]->m_HalRsltRgn[rgn_idx][ins_idx];
}

Hobject *C_VisionModule::GetHalInspectRgn(int cam_idx, int rgn_idx, int ins_idx)
{
	return &m_VDat[cam_idx]->m_HalInsRgn[rgn_idx][ins_idx];
}

Hobject *C_VisionModule::GetHalNGRsltRgn(int cam_idx, int ng_view_idx, int rgn_idx, int ins_idx)
{
	//CHOKI20101031 Test
//	rgn_idx = 2;

	return &m_VDat[cam_idx]->m_HalNGRsltRgn[ng_view_idx][rgn_idx][ins_idx];
}

Hobject *C_VisionModule::GetHalMasterImage(int cam_idx)
{
	return &m_VDat[cam_idx]->m_HalMasterImage;
}

Hobject *C_VisionModule::GetHalSRMasterImage(int cam_idx)
{
	return &m_VDat[cam_idx]->m_HalSRMasterImage;
}

Hobject *C_VisionModule::GetHalLeadMasterImage(int cam_idx)
{
	return &m_VDat[cam_idx]->m_HalLeadMasterImage;
}

Hobject *C_VisionModule::GetHalSROutMasterImage(int cam_idx)
{
	return &m_VDat[cam_idx]->m_HalSROutMasterImage;
}

Hobject *C_VisionModule::GetHalTaughtImage(int cam_idx, int map_idx)
{
	return &m_VDat[cam_idx]->m_HalTaughtImage[map_idx];
}

typeInspectPara C_VisionModule::GetInspectPara(int cam_idx)
{
	return m_VDat[cam_idx]->m_InsPara;
}

void C_VisionModule::SetInspectPara(int cam_idx, typeInspectPara para)
{
	m_VDat[cam_idx]->m_InsPara = para;
}

void C_VisionModule::ResetInspectPara()
{
	for(int i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		memset(&m_VDat[i]->m_InsPara, NULL, sizeof(m_VDat[i]->m_InsPara));
	}
}

typeInspectRslt C_VisionModule::GetInspectRslt(int cam_idx)
{
	return m_VDat[cam_idx]->m_InsRslt;
}

void C_VisionModule::SetInspectRslt(int cam_idx, typeInspectRslt rslt)
{
	m_VDat[cam_idx]->m_InsRslt = rslt;
}

void C_VisionModule::ResetInspectRslt()
{
	for(int i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		memset(&m_VDat[i]->m_InsRslt, NULL, sizeof(m_VDat[i]->m_InsRslt));
	}
}

void C_VisionModule::ResetInspectRsltRgn()
{
	int i, j, k;

	//Variable clear
	for(i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		for(j = 0; j < SUB_RGN_MAX_NUM; j++)
		{
			for(k = 0; k < RESULT_INS_MAX_NUM; k++)
			{
				//clear_obj(m_VDat[i]->m_HalRsltRgn[j][k]); 
				gen_empty_obj(&m_VDat[i]->m_HalRsltRgn[j][k]);
			}
		}
	}
}

void C_VisionModule::ResetInspectRgn()
{
	int i, j, k;

	//Variable clear
	for(i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		for(j = 0; j < SUB_RGN_MAX_NUM; j++)
		{
			for(k = 0; k < INS_RGN_MAX_NUM; k++)
			{
				//clear_obj(m_VDat[i]->m_HalRsltRgn[j][k]); 
				gen_empty_obj(&m_VDat[i]->m_HalInsRgn[j][k]);
			}
		}
	}
}

typeInspectNGRslt C_VisionModule::GetInspectNGRslt(int cam_idx, int ng_view_idx)
{
	return m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx];
}

void C_VisionModule::SetInspectNGRslt(int cam_idx, int ng_view_idx, typeShiftRslt shift_rslt, typeInspectRslt ins_rslt)
{
	m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_ShiftRslt = shift_rslt;
	m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_InsRslt = ins_rslt;
}

BOOL C_VisionModule::SaveInspectNGRslt(int cam_idx, int ng_view_idx, int rgn_idx, CString path)
{
	BOOL rslt = TRUE;

	Hobject SubRgn, TotRgn, UnionSubRgn;
	HTuple Num;
	int num;

	CString temp;
	
	gen_empty_obj(&SubRgn);
	gen_empty_obj(&TotRgn);
	gen_empty_obj(&UnionSubRgn);
	
	//Region/////////////////////////////////////
	for(int i = 0; i < RESULT_INS_MAX_NUM; i++)
	{
		count_obj(*GetHalNGRsltRgn(cam_idx, ng_view_idx, rgn_idx, i), &Num);
		num = (long)Num[0];
		if( 0 == num )
		{
			gen_empty_region(&UnionSubRgn);
		}
		else
		{
			//if XLD
			if( (i == 2) || (i = 43) )//2 : align pattern, 43 : OCV pattern
			{
				SubRgn = *GetHalNGRsltRgn(cam_idx, ng_view_idx, rgn_idx, i);
				//gen_region_contour_xld(SubRgn, &SubRgn, "fill");
				union1(SubRgn, &UnionSubRgn);
			}
			else
			{
				SubRgn = *GetHalNGRsltRgn(cam_idx, ng_view_idx, rgn_idx, i);
				union1(SubRgn, &UnionSubRgn);
			}
		}
		
		concat_obj(TotRgn, UnionSubRgn, &TotRgn);
	}
	
	//Write region
	temp = path + ".rgn";
	write_region(TotRgn, temp);

	//Data///////////////////////////////////////
	m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_iRgnIdx = rgn_idx;

	temp = path + ".dat";
	//NG inspection result
	//typeInspectNGRslt m_InsNGRslt[NG_VIEW_MAX_NUM];
	HANDLE fd=CreateFile(   temp,
							GENERIC_READ|GENERIC_WRITE,
							0,
							NULL,
							CREATE_ALWAYS,
							FILE_ATTRIBUTE_NORMAL,
							NULL
							);
	if(((LONG)fd)<0)
	{
		//AfxMessageBox("Error : Can't save NG result file!" + path_sys);
		rslt = FALSE;
	}
	else
	{
		DWORD len;

		WriteFile(fd, &m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx], sizeof(m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx]), &len, NULL);

		CloseHandle(fd);
	}

	fd=0;
		
	return rslt;	
}

BOOL C_VisionModule::LoadInspectNGRslt(int cam_idx, int ng_view_idx, CString path)
{
	BOOL rslt = TRUE;

	Hobject SubRgn, TotRgn;
	HTuple Num;
	long num;
	CString temp;
	int rgn_idx, i;

	temp = path + ".dat";
	HANDLE fd = CreateFile( temp,
							GENERIC_READ|GENERIC_WRITE,
							0,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL
							);
	if(((LONG)fd)<0)
	{
		//AfxMessageBox("Error : Can't load NG result file!" + path_sys);
		rslt = FALSE;
	}
	else
	{
		DWORD len;

		//Setup
		ReadFile(fd, &m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx], sizeof(m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx]), &len, NULL);

		CloseHandle(fd);
	}

	fd=0;

	if( (0 > m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_iRgnIdx) || (NG_VIEW_MAX_NUM <= m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_iRgnIdx) )
	{
		m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_iRgnIdx = -1;
	}

	rgn_idx = m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_iRgnIdx;

	for(i = 0; i < SUB_RGN_MAX_NUM; i++)
	{
		if(i == rgn_idx)
		{
			m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_InsRslt.m_bRegionSkip[i] = TRUE;
		}
		else
		{
			m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_InsRslt.m_bRegionSkip[i] = FALSE;			
		}
	}
	
	//Region/////////////////////////////////////
	//Read region
	temp = path + ".rgn";
	read_region(&TotRgn, temp);
	count_obj(TotRgn, &Num);
	num = (long)Num[0];
	//Region union
	for(i = 0; (i < RESULT_INS_MAX_NUM) && (i < num); i++)
	{
		select_obj(TotRgn, GetHalNGRsltRgn(cam_idx, ng_view_idx, m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_iRgnIdx, i), i + 1);
		connection(*GetHalNGRsltRgn(cam_idx, ng_view_idx, m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_iRgnIdx, i), 
					GetHalNGRsltRgn(cam_idx, ng_view_idx, m_VDat[cam_idx]->m_InsNGRslt[ng_view_idx].m_iRgnIdx, i));
	}
	
	return rslt;
}

void C_VisionModule::ResetInspectNGRslt()
{
	int i, j;
	for(i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		for(j = 0; j < NG_VIEW_MAX_NUM; j++)
		{
			memset(&m_VDat[i]->m_InsNGRslt[j], NULL, sizeof(m_VDat[i]->m_InsNGRslt[j]));
		}
	}
}

void C_VisionModule::ResetInspectNGRsltRgn()
{
	int i, j, k, l;

	//Variable clear
	for(i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		for(j = 0; j < NG_VIEW_MAX_NUM; j++)
		{
			for(k = 0; k < SUB_RGN_MAX_NUM; k++)
			{
				for(l = 0; l < RESULT_INS_MAX_NUM; l++)
				{
					//clear_obj(m_VDat[i]->m_HalNGRsltRgn[j][k][l]); 
					gen_empty_obj(&m_VDat[i]->m_HalNGRsltRgn[j][k][l]);
					//gen_empty_region(&m_VDat[i]->m_HalNGRsltRgn[j][k][l]);
				}
			}
		}
	}
}

void C_VisionModule::SetInspectNGRsltRgn(int cam_idx, int ng_view_idx)
{
	int i, j, k;
	long num;
	HTuple Num;
	Hobject Region;
	
	for(i = 0; i < SUB_RGN_MAX_NUM; i++)
	{
		for(j = 0; j < RESULT_INS_MAX_NUM; j++)
		{
			//clear_obj(m_VDat[cam_idx]->m_HalNGRsltRgn[ng_view_idx][i][j]); 
			gen_empty_obj(&m_VDat[cam_idx]->m_HalNGRsltRgn[ng_view_idx][i][j]);

			count_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][j], &Num);
			num = (long)Num[0];
			for(k = 0; k < num; k++)
			{
				//copy_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][j], &m_VDat[cam_idx]->m_HalNGRsltRgn[ng_view_idx][i][j], k + 1, 1); 
				copy_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][j], &Region, k + 1, 1); 
				concat_obj(m_VDat[cam_idx]->m_HalNGRsltRgn[ng_view_idx][i][j], 
						   Region, 
						   &m_VDat[cam_idx]->m_HalNGRsltRgn[ng_view_idx][i][j]);
			}
		}
	}

}

typeSystemPara C_VisionModule::GetSystemPara(int cam_idx)
{
	return m_VDat[cam_idx]->m_SysPara;
}

void C_VisionModule::SetSystemPara(int cam_idx, typeSystemPara rslt)
{
	m_VDat[cam_idx]->m_SysPara = rslt;
}

void C_VisionModule::ResetSystemPara()
{
	for(int i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		memset(&m_VDat[i]->m_SysPara, NULL, sizeof(m_VDat[i]->m_SysPara));
	}
}

typeSystemRslt C_VisionModule::GetSystemRslt(int cam_idx)
{
	return m_VDat[cam_idx]->m_SysRslt;
}

typeShiftRslt C_VisionModule::GetShiftRslt(int cam_idx, int buf_idx)
{
	return m_VDat[cam_idx]->m_ShiftRslt[buf_idx];
}

int C_VisionModule::GetCOFNum(int cam_idx)
{
	return m_VDat[cam_idx]->m_InsPara.m_iParaBase[0];
}

int C_VisionModule::GetMapNum(int cam_idx)
{
	return m_VDat[cam_idx]->m_InsPara.m_iParaBase[1];
}

int C_VisionModule::GetPCNum(int cam_idx)
{
	return m_VDat[cam_idx]->m_SysPara.m_iPCIdx;
}

void C_VisionModule::SetSystemRslt(int cam_idx, typeSystemRslt rslt)
{
	m_VDat[cam_idx]->m_SysRslt = rslt;
}

void C_VisionModule::SetShiftRslt(int cam_idx, int buf_idx, typeShiftRslt rslt)
{
	m_VDat[cam_idx]->m_ShiftRslt[buf_idx] = rslt;
}

void C_VisionModule::ResetSystemRslt()
{
	for(int i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		memset(&m_VDat[i]->m_SysRslt, NULL, sizeof(m_VDat[i]->m_SysRslt));
	}
}

void C_VisionModule::ResetShiftRslt()
{
	int i, j;

	for(i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		for(j = 0; j < IMAGE_BUF_NUM; j++)
		{
			memset(&m_VDat[i]->m_ShiftRslt[j], NULL, sizeof(m_VDat[i]->m_ShiftRslt[j]));
		}
	}
}

typeMainSystemPara C_VisionModule::GetMainSysPara()
{
	return m_MainSysPara;
}

void C_VisionModule::SetMainSysPara(typeMainSystemPara rslt)
{
	m_MainSysPara = rslt;
}

void C_VisionModule::ResetMainSysPara()
{
	memset(&m_MainSysPara, NULL, sizeof(m_MainSysPara));
}

typeMainSystemRslt C_VisionModule::GetMainSysRslt()
{
	return m_MainSysRslt;
}

void C_VisionModule::SetMainSysRslt(typeMainSystemRslt rslt)
{
	m_MainSysRslt = rslt;
}

void C_VisionModule::ResetMainSysRslt()
{
	memset(&m_MainSysRslt, NULL, sizeof(m_MainSysRslt));
}

typeLotInfo C_VisionModule::GetLotInfo()
{
	return m_Lot;
}

void C_VisionModule::SetLotInfo(typeLotInfo lot)
{
	m_Lot = lot;
}

void C_VisionModule::ResetLotInfo()
{
	memset(&m_Lot, NULL, sizeof(m_Lot));
}

//Set handle(for test)
void C_VisionModule::SetWindow(int cam_idx, long win)
{
	m_lWindow[cam_idx] = win;
}

BOOL C_VisionModule::LoadInspectPara(CString path)
{
	BOOL rslt = TRUE;
	CString key, dat;
	char temp[DAT_STR_LENG];
	int i, j, k;
	CString file_path, pat_path, extention, master_path;
	Herror Herr;

	file_path = path + "\\Inspection.par";

	//file 존재 확인 
	HANDLE fd = CreateFile( file_path,
							GENERIC_READ|GENERIC_WRITE,
							0,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL
							);
	if(((LONG)fd)<0)
	{
		rslt = FALSE;
	}
	else
	{
		CloseHandle(fd);
		
		for(i = 0; i < IMG_RECT_MAX_NUM; i++)
		{
			switch(i)
			{
			case 0:
				//Base///////////////////////////////
				for(j = 0; j < BOOL_PARA_MAX_NUM_BASE; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_BASE%d", i, j);
					m_VDat[i]->m_InsPara.m_bParaBase[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_BASE; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_BASE%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaBase[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_BASE; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_BASE%d", i, j);
					GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
					m_VDat[i]->m_InsPara.m_dParaBase[j] = atof(temp);
				}
				
				//Align//////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_ALIGN; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_Align%d_%d_InspectRect1_Left", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].left = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Align%d_%d_InspectRect1_Top", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].top = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Align%d_%d_InspectRect1_Right", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].right = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Align%d_%d_InspectRect1_Bottom", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].bottom = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						
						if( (0 >= m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].left) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].top) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].right) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].bottom) )
						{
							m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].left = 100;
							m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].top = 100;
							m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].right = 200;
							m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].bottom = 200;
						}
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_ALIGN; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_Align%d", i, j);
					m_VDat[i]->m_InsPara.m_bParaAlign[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_ALIGN; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Align%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaAlign[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_ALIGN; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_Align%d", i, j);
					GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
					m_VDat[i]->m_InsPara.m_dParaAlign[j] = atof(temp);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_ALIGN; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_Align%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaMapAlign[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				//fixed
				m_VDat[i]->m_InsPara.m_PatParaAlign.m_shType = VISIONHALFUNC_MOD_RECT1;
				m_VDat[i]->m_InsPara.m_PatParaAlign.m_AngleStart = 0;
				m_VDat[i]->m_InsPara.m_PatParaAlign.m_AngleExtend = 0;
				m_VDat[i]->m_InsPara.m_PatParaAlign.m_AngleStep = 0;
				sprintf(m_VDat[i]->m_InsPara.m_PatParaAlign.m_Optimize, "none");
				sprintf(m_VDat[i]->m_InsPara.m_PatParaAlign.m_Matric, "ignore_global_polarity");
				sprintf(m_VDat[i]->m_InsPara.m_PatParaAlign.m_SupPix, "interpolation");
				m_VDat[i]->m_InsPara.m_PatParaAlign.m_Overlap = 0;
				
				m_VDat[i]->m_InsPara.m_PatParaAlign.m_MatchNum = 1;
				m_VDat[i]->m_InsPara.m_PatParaAlign.m_Greed = 0.5;
				m_VDat[i]->m_InsPara.m_PatParaAlign.m_ScaleMin = 1.0;
				m_VDat[i]->m_InsPara.m_PatParaAlign.m_ScaleMax = 1.0;
				m_VDat[i]->m_InsPara.m_PatParaAlign.m_ScaleStep = 0;
				
				//read shape region
				pat_path = path + "\\PatternAlign."; 
				extention.Format("m%d", i);
				pat_path = pat_path + extention;
				set_check("~give_error");
				Herr = read_shape_model(HTuple(((LPCTSTR)pat_path)), &m_VDat[i]->m_InsPara.m_PatIDAlign);
				set_check("give_error");
				if(H_MSG_TRUE == Herr)
				{
					m_VDat[i]->m_InsPara.m_bCreatMdIDAlign = TRUE;

					// 20110531 Dongwhe* BEGIN 2nd Align Mark Shape Load
					// 두개의 마크 정보가 모두 읽히면 TRUE가 되도록 하기 위해
					// 첫번째 마크 정보 로딩에 성공한 경우에 두번째 마크 정보 로딩 시도를 하도록 작성
					// read shape region2
					pat_path = path + "\\PatternAlign2."; 
					extention.Format("m%d", i);
					pat_path = pat_path + extention;
					set_check("~give_error");
					Herr = read_shape_model(HTuple(((LPCTSTR)pat_path)), &m_VDat[i]->m_InsPara.m_PatIDAlign2);
					set_check("give_error");
					if(H_MSG_TRUE == Herr)
					{
						m_VDat[i]->m_InsPara.m_bCreatMdIDAlign = TRUE;	
					}
					else
					{
						m_VDat[i]->m_InsPara.m_bCreatMdIDAlign = FALSE;
					}
					// 20110531 Dongwhe* END
				}
				else
				{
					m_VDat[i]->m_InsPara.m_bCreatMdIDAlign = FALSE;
				}
				
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < PATTERN_INS_NUM; k++)
					{
						key.Empty();
						key.Format("CAM%d_iPosX_Align%d_Pos%d", i, j, k);
						GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
						m_VDat[i]->m_InsPara.m_dPatternPosXAlign[j][k] = atof(temp);
						
						key.Empty();
						key.Format("CAM%d_iPosY_Align%d_Pos%d", i, j, k);
						GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
						m_VDat[i]->m_InsPara.m_dPatternPosYAlign[j][k] = atof(temp);
					}
				}
				/////////////////////////////////////
				
				//Chip///////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_CHIP; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_Chip%d_%d_InspectRect1_Left", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].left = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Chip%d_%d_InspectRect1_Top", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].top = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Chip%d_%d_InspectRect1_Right", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].right = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Chip%d_%d_InspectRect1_Bottom", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].bottom = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						
						if( (0 >= m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].left) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].top) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].right) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].bottom) )
						{
							m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].left = 100;
							m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].top = 100;
							m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].right = 200;
							m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].bottom = 200;
						}
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_CHIP; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_Chip%d", i, j);
					m_VDat[i]->m_InsPara.m_bParaChip[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_CHIP; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Chip%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaChip[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_CHIP; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_Chip%d", i, j);
					GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
					m_VDat[i]->m_InsPara.m_dParaChip[j] = atof(temp);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_CHIP; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_Chip%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaMapChip[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				/////////////////////////////////////
				
				//Lead///////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_LEAD; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_Lead%d_%d_InspectRect1_Left", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].left = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Lead%d_%d_InspectRect1_Top", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].top = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Lead%d_%d_InspectRect1_Right", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].right = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Lead%d_%d_InspectRect1_Bottom", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].bottom = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						
						if( (0 >= m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].left) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].top) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].right) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].bottom) )
						{
							m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].left = 100;
							m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].top = 100;
							m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].right = 200;
							m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].bottom = 200;
						}
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_LEAD; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_Lead%d", i, j);
					m_VDat[i]->m_InsPara.m_bParaLead[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_LEAD; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Lead%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaLead[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_LEAD; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_Lead%d", i, j);
					GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
					m_VDat[i]->m_InsPara.m_dParaLead[j] = atof(temp);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_LEAD; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_Lead%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaMapLead[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				/////////////////////////////////////
				
				//Film///////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_FILM; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_Film%d_%d_InspectRect1_Left", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].left = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Film%d_%d_InspectRect1_Top", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].top = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Film%d_%d_InspectRect1_Right", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].right = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_Film%d_%d_InspectRect1_Bottom", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].bottom = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						
						if( (0 >= m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].left) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].top) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].right) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].bottom) )
						{
							m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].left = 100;
							m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].top = 100;
							m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].right = 200;
							m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].bottom = 200;
						}
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_FILM; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_Film%d", i, j);
					m_VDat[i]->m_InsPara.m_bParaFilm[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_FILM; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Film%d", i, j);
					if(j==20) //CHOKI20110824
					{
						m_VDat[i]->m_InsPara.m_iParaFilm[j] = 100;
					}
					else //CHOKI20110824
					{
						m_VDat[i]->m_InsPara.m_iParaFilm[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
					}
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_FILM; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_Film%d", i, j);
					GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
					m_VDat[i]->m_InsPara.m_dParaFilm[j] = atof(temp);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_FILM; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_Film%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaMapFilm[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
				/*
				//read variation region
				pat_path = path + "\\VarFilm."; 
				extention.Format("v%d_%d", i, j);
				pat_path = pat_path + extention;
				set_check("~give_error");
				Herr = read_variation_model(HTuple(((LPCTSTR)pat_path)), &m_VDat[i]->m_InsPara.m_FilmVarID[j]);
				set_check("give_error");
				if(H_MSG_TRUE == Herr)
				{
				m_VDat[i]->m_InsPara.m_bCreatFilmVarID[j] = TRUE;	
				}
				else
				{
				m_VDat[i]->m_InsPara.m_bCreatFilmVarID[j] = FALSE;
				}
					*/
					m_VDat[i]->m_InsPara.m_bCreatFilmVarID[j] = FALSE;
				}
				
				/////////////////////////////////////
				
				//OCV////////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_OCV; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_OCV%d_%d_InspectRect1_Left", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].left = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_OCV%d_%d_InspectRect1_Top", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].top = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_OCV%d_%d_InspectRect1_Right", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].right = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_OCV%d_%d_InspectRect1_Bottom", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].bottom = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						
						if( (0 >= m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].left) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].top) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].right) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].bottom) )
						{
							m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].left = 100;
							m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].top = 100;
							m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].right = 200;
							m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].bottom = 200;
						}
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_OCV; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_OCV%d", i, j);
					m_VDat[i]->m_InsPara.m_bParaOCV[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_OCV; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_OCV%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaOCV[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_OCV; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_OCV%d", i, j);
					GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
					m_VDat[i]->m_InsPara.m_dParaOCV[j] = atof(temp);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_OCV; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_OCV%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaMapOCV[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < OCV_CHAR_MAX_NUM; j++)
				{
					key.Empty();
					key.Format("CAM%d_Char_OCV%d_InspectRect1_Left", i, j);
					m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].left = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
					key.Empty();
					key.Format("CAM%d_Char_OCV%d_InspectRect1_Top", i, j);
					m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].top = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
					key.Empty();
					key.Format("CAM%d_Char_OCV%d_InspectRect1_Right", i, j);
					m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].right = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
					key.Empty();
					key.Format("CAM%d_Char_OCV%d_InspectRect1_Bottom", i, j);
					m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].bottom = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
					
					if( (0 >= m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].left) || 
						(0 >= m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].top) || 
						(0 >= m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].right) || 
						(0 >= m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].bottom) )
					{
						m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].left = 100;
						m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].top = 100;
						m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].right = 200;
						m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].bottom = 200;
					}
					
					key.Empty();
					key.Format("CAM%d_Char_CenterX_OCV%d", i, j);
					GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
					m_VDat[i]->m_InsPara.m_dCharCenterX[j] = atof(temp);
					
					key.Empty();
					key.Format("CAM%d_Char_CenterY_OCV%d", i, j);
					GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
					m_VDat[i]->m_InsPara.m_dCharCenterY[j] = atof(temp);
					
					//fixed
					m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_shType = VISIONHALFUNC_MOD_RECT1;
					m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_AngleStart = 0;
					m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_AngleExtend = 0;
					m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_AngleStep = 0;
					sprintf(m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_Optimize, "none");
					sprintf(m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_Matric, "use_polarity");
					sprintf(m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_SupPix, "none");
					m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_Overlap = 0;
					
					m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_MatchNum = 1;
					m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_Greed = 0.5;
					m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_ScaleMin = 1.0;
					m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_ScaleMax = 1.0;
					m_VDat[i]->m_InsPara.m_PatParaOCV[j].m_ScaleStep = 0;
					
					//read shape region
					pat_path = path + "\\PatternOCV."; 
					extention.Format("m%d_%d", i, j);
					pat_path = pat_path + extention;
					set_check("~give_error");
					Herr = read_shape_model(HTuple(((LPCTSTR)pat_path)), &m_VDat[i]->m_InsPara.m_PatIDOCV[j]);
					set_check("give_error");
					if(H_MSG_TRUE == Herr)
					{
						m_VDat[i]->m_InsPara.m_bCreatMdIDOCV[j] = TRUE;	
					}
					else
					{
						m_VDat[i]->m_InsPara.m_bCreatMdIDOCV[j] = FALSE;
					}
					
					//read variation region
// 					pat_path = path + "\\VarOCV."; 
// 					extention.Format("v%d_%d", i, j);
// 					pat_path = pat_path + extention;
// 					set_check("~give_error");
// 					Herr = read_variation_model(HTuple(((LPCTSTR)pat_path)), &m_VDat[i]->m_InsPara.m_CharVarID[j]);
// 					set_check("give_error");
// 					if(H_MSG_TRUE == Herr)
// 					{
// 						m_VDat[i]->m_InsPara.m_bCreatCharVarID[j] = TRUE;	
// 					}
// 					else
// 					{
// 						m_VDat[i]->m_InsPara.m_bCreatCharVarID[j] = FALSE;
// 					}
				}
				
				
				/////////////////////////////////////
				
				//SR/////////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_SR; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_SR%d_%d_InspectRect1_Left", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].left = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_SR%d_%d_InspectRect1_Top", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].top = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_SR%d_%d_InspectRect1_Right", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].right = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						key.Empty();
						key.Format("CAM%d_Ins_SR%d_%d_InspectRect1_Bottom", i, j, k);
						m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].bottom = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
						
						if( (0 >= m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].left) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].top) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].right) || 
							(0 >= m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].bottom) )
						{
							m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].left = 100;
							m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].top = 100;
							m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].right = 200;
							m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].bottom = 200;
						}
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_SR; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_SR%d", i, j);
					m_VDat[i]->m_InsPara.m_bParaSR[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_SR; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_SR%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaSR[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_SR; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_SR%d", i, j);
					GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
					m_VDat[i]->m_InsPara.m_dParaSR[j] = atof(temp);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_SR; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_SR%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaMapSR[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					//read variation region
// 					pat_path = path + "\\VarSR."; 
// 					extention.Format("v%d_%d", i, j);
// 					pat_path = pat_path + extention;
// 					set_check("~give_error");
// 					Herr = read_variation_model(HTuple(((LPCTSTR)pat_path)), &m_VDat[i]->m_InsPara.m_SRVarID[j]);
// 					set_check("give_error");
// 					if(H_MSG_TRUE == Herr)
// 					{
// 						m_VDat[i]->m_InsPara.m_bCreatSRVarID[j] = TRUE;	
// 					}
// 					else
// 					{
// 						m_VDat[i]->m_InsPara.m_bCreatSRVarID[j] = FALSE;
// 					}
				}
				
				/////////////////////////////////////
				
				//Read master image
				master_path = path + "\\MasterImage.bmp"; 
				set_check("~give_error");
				Herr= read_image(&m_VDat[i]->m_HalMasterImage, HTuple((LPCTSTR)master_path));
				set_check("give_error");
				if(H_MSG_TRUE == Herr)
				{
					
				}
				else
				{
					gen_image_const(&m_VDat[i]->m_HalMasterImage,HTuple("byte"),2048,2048);
				}
				
				//Read SR master image
				master_path = path + "\\SRMasterImage.bmp"; 
				set_check("~give_error");
				Herr= read_image(&m_VDat[i]->m_HalSRMasterImage, HTuple((LPCTSTR)master_path));
				set_check("give_error");
				if(H_MSG_TRUE == Herr)
				{
					
				}
				else
				{
					gen_image_const(&m_VDat[i]->m_HalSRMasterImage,HTuple("byte"),2048,2048);
				}
				
				//Read Lead master image
				master_path = path + "\\LeadMasterImage.bmp"; 
				set_check("~give_error");
				Herr= read_image(&m_VDat[i]->m_HalLeadMasterImage, HTuple((LPCTSTR)master_path));
				set_check("give_error");
				if(H_MSG_TRUE == Herr)
				{
					
				}
				else
				{
					gen_image_const(&m_VDat[i]->m_HalLeadMasterImage,HTuple("byte"),2048,2048);
				}
				
				//Read SROut master image
				master_path = path + "\\SROutMasterImage.bmp"; 
				set_check("~give_error");
				Herr= read_image(&m_VDat[i]->m_HalSROutMasterImage, HTuple((LPCTSTR)master_path));
				set_check("give_error");
				if(H_MSG_TRUE == Herr)
				{
					
				}
				else
				{
					gen_image_const(&m_VDat[i]->m_HalSROutMasterImage,HTuple("byte"),2048,2048);
				}
				
				//Read Taught image
				for(j = 0; j < IMAGE_MAP_MAX_NUM; j++)
				{
					master_path = path + "\\TaughtImage"; 
					extention.Format("%d.bmp", j);
					master_path = master_path + extention;
					set_check("~give_error");
					Herr= read_image(&m_VDat[i]->m_HalTaughtImage[j], HTuple((LPCTSTR)master_path));
					set_check("give_error");
					if(H_MSG_TRUE == Herr)
					{
						
					}
					else
					{
						gen_image_const(&m_VDat[i]->m_HalTaughtImage[j],HTuple("byte"),2048,2048);
					}
				}
				
				//Read inspection region
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < INS_RGN_MAX_NUM; k++)
					{
						pat_path = path + "\\InsRegion."; 
						extention.Format("%d_%d_%d", i, j, k);
						pat_path = pat_path + extention;
						set_check("~give_error");
						Herr = read_region(&m_VDat[i]->m_HalInsRgn[j][k], pat_path);
						set_check("give_error");
						if(H_MSG_TRUE == Herr)
						{
							
						}
						else
						{
							gen_empty_obj(&m_VDat[i]->m_HalInsRgn[j][k]);
						}
					}
				}
				
				//Light
				for(j = 0; j < IMAGE_MAP_MAX_NUM; j++)
				{
					for(k = 0; k < LIGHT_CH_MAX_NUM; k++)
					{
						key.Empty();
						key.Format("CAM%d_iPara_Map%d_Light%d", i, j, k);
						m_VDat[i]->m_InsPara.m_iLightVar[j][k] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
					}
				}

				//20100702 lss
				//PPunch(펀칭부)/////////////////////
				for(j = 0; j < RECT_PARA_MAX_NUM_PPUNCH; j++)
				{
					key.Empty();
					key.Format("CAM%d_Ins_PPUNCH%d_InspectRect1_Left", i, j);
					m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].left = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
					key.Empty();
					key.Format("CAM%d_Ins_PPUNCH%d_InspectRect1_Top", i, j);
					m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].top = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 100, file_path);
					key.Empty();
					key.Format("CAM%d_Ins_PPUNCH%d_InspectRect1_Right", i, j);
					m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].right = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
					key.Empty();
					key.Format("CAM%d_Ins_PPUNCH%d_InspectRect1_Bottom", i, j);
					m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].bottom = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 200, file_path);
					
					if( (0 >= m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].left) || 
						(0 >= m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].top) || 
						(0 >= m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].right) || 
						(0 >= m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].bottom) )
					{
						m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].left = 100;
						m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].top = 100;
						m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].right = 200;
						m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].bottom = 200;
					}
				}
				
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_PPUNCH; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_PPUNCH%d", i, j);
					m_VDat[i]->m_InsPara.m_bParaPPunch[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_PPUNCH; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_PPUNCH%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaPPunch[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_PPUNCH; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_PPUNCH%d", i, j);
					GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
					m_VDat[i]->m_InsPara.m_dParaPPunch[j] = atof(temp);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_PPUNCH; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_PPUNCH%d", i, j);
					m_VDat[i]->m_InsPara.m_iParaMapPPunch[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);
				}				
				break;
				
			case 1:
				

				
				break;
			}
		}
		
		
	}
	fd=0;
	
	UpdateSRBubPrepare();
	
	return rslt;
}

 //20110513 lee
void C_VisionModule::MakeDefaultInspPara()
{
	int i,j;
	for(i = 0; i < IMG_RECT_MAX_NUM; i++)
	{
		for(j = 0; j < BOOL_PARA_MAX_NUM_BASE; j++)
		{
			m_VDat[i]->m_InsPara.m_iParaBase[0] = 2;
			m_VDat[i]->m_InsPara.m_iParaBase[1] = USE_MAP_CNT;
			m_VDat[i]->m_InsPara.m_iParaBase[2] = 5;
			m_VDat[i]->m_InsPara.m_dParaBase[1] = COF_PF_PITCH;
			m_VDat[i]->m_InsPara.m_dParaBase[2] = COF_WIDTH;	
		}
	}
/* //Tracker 위치 초기값 정의 
	//Align mark
	m_VDat[i]->m_InsPara.m_InsRegionAlign[0][1];

	//Align search
	for(i = 0; (i < m_VDat[i]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
	{
		m_VDat[i]->m_InsPara.m_InsRegionAlign[i][0];
	}

	//Chip///////////////////////////////////
	for(i = 0; (i < m_VDat[i]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
	{
			m_VDat[i]->m_InsPara.m_InsRegionChip[i][0];
	}

	//Film///////////////////////////////////
	for(i = 0; (i < m_VDat[i]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
	{
		m_VDat[i]->m_InsPara.m_InsRegionFilm[i][0];
	}

	//Lead///////////////////////////////////
	for(i = 0; (i < m_VDat[i]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
	{
		//상부
		rect = m_VDat[i]->m_InsPara.m_InsRegionLead[i][0];
		
		//하부
		rect = m_VDat[i]->m_InsPara.m_InsRegionLead[i][1];
	}

	//OCV////////////////////////////////////
	//Align mark
	rect = m_VDat[i]->m_InsPara.m_InsRegionOCV[0][1];

	//Align search
	for(i = 0; (i < m_VDat[i]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
	{
		rect = m_VDat[i]->m_InsPara.m_InsRegionOCV[i][0];
	}

	//SR/////////////////////////////////////
	for(i = 0; (i < m_VDat[i]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
	{
		m_VDat[i]->m_InsPara.m_InsRegionSR[i][0];
		
		switch(m_VDat[i]->GetPCNum(0))
		{
		case 0:
			break;
		case 1:
		default:
			break;
		}
	}		
*/
}
BOOL C_VisionModule::SaveInspectPara(CString path)
{
	BOOL rslt = TRUE;
	CString key, dat;
	int i, j, k;
	CString file_path, pat_path, extention, master_path;
	Herror Herr;

	//Make director
	MakeDirectories(path);

	file_path = path + "\\Inspection.par";

	//file 존재 확인 
	HANDLE fd=CreateFile(   file_path,
							GENERIC_READ|GENERIC_WRITE,
							0,
							NULL,
							CREATE_ALWAYS,
							FILE_ATTRIBUTE_NORMAL,
							NULL
							);
	if(((LONG)fd)<0)
	{
		rslt = FALSE;
	}
	else
	{
		CloseHandle(fd);

		//write INI

		for(i = 0; i < IMG_RECT_MAX_NUM; i++)
		{
			
			switch(i)
			{
			case 0:
				//Base///////////////////////////////
				for(j = 0; j < BOOL_PARA_MAX_NUM_BASE; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_BASE%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_bParaBase[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_BASE; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_BASE%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaBase[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_BASE; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_BASE%d", i, j);
					dat.Empty();
					dat.Format("%f", m_VDat[i]->m_InsPara.m_dParaBase[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				//Align//////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_ALIGN; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_Align%d_%d_InspectRect1_Left", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].left);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Align%d_%d_InspectRect1_Top", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].top);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Align%d_%d_InspectRect1_Right", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].right);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Align%d_%d_InspectRect1_Bottom", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionAlign[j][k].bottom);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_ALIGN; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_Align%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_bParaAlign[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_ALIGN; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Align%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaAlign[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_ALIGN; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_Align%d", i, j);
					dat.Empty();
					dat.Format("%f", m_VDat[i]->m_InsPara.m_dParaAlign[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_ALIGN; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_Align%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaMapAlign[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				
				//write shape region
				if(m_VDat[i]->m_InsPara.m_bCreatMdIDAlign)
				{
					pat_path = path + "\\PatternAlign."; 
					extention.Format("m%d", i);
					pat_path = pat_path + extention;
					set_check("~give_error");
					Herr = write_shape_model(m_VDat[i]->m_InsPara.m_PatIDAlign, HTuple(((LPCTSTR)pat_path)));
					set_check("give_error");
					if(H_MSG_TRUE == Herr)
					{
						// 20110531 Dongwhe* BEGIN 2nd Mark shape Save
						// 두번째 Align Mark도 저장 하도록 작성
						// m_VDat[i]->m_InsPara.m_bCreatMdIDAlign = TRUE;
						pat_path = path + "\\PatternAlign2."; 
						extention.Format("m%d", i);
						pat_path = pat_path + extention;
						set_check("~give_error");
						Herr = write_shape_model(m_VDat[i]->m_InsPara.m_PatIDAlign2, HTuple(((LPCTSTR)pat_path)));
						set_check("give_error");
						if(H_MSG_TRUE == Herr)
						{
							m_VDat[i]->m_InsPara.m_bCreatMdIDAlign = TRUE;	
						}
						else
						{
							m_VDat[i]->m_InsPara.m_bCreatMdIDAlign = FALSE;
						}
						// 20110531 Dongwhe* END
					}
					else
					{
						m_VDat[i]->m_InsPara.m_bCreatMdIDAlign = FALSE;
					}
				}
				
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < PATTERN_INS_NUM; k++)
					{
						key.Empty();
						key.Format("CAM%d_iPosX_Align%d_Pos%d", i, j, k);
						dat.Empty();
						dat.Format("%f", m_VDat[i]->m_InsPara.m_dPatternPosXAlign[j][k]);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_iPosY_Align%d_Pos%d", i, j, k);
						dat.Empty();
						dat.Format("%f", m_VDat[i]->m_InsPara.m_dPatternPosYAlign[j][k]);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					}
				}
				/////////////////////////////////////
				
				//Chip//////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_CHIP; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_Chip%d_%d_InspectRect1_Left", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].left);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Chip%d_%d_InspectRect1_Top", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].top);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Chip%d_%d_InspectRect1_Right", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].right);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Chip%d_%d_InspectRect1_Bottom", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionChip[j][k].bottom);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_CHIP; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_Chip%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_bParaChip[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_CHIP; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Chip%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaChip[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_CHIP; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_Chip%d", i, j);
					dat.Empty();
					dat.Format("%f", m_VDat[i]->m_InsPara.m_dParaChip[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_CHIP; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_Chip%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaMapChip[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				/////////////////////////////////////
				
				//Lead//////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_LEAD; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_Lead%d_%d_InspectRect1_Left", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].left);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Lead%d_%d_InspectRect1_Top", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].top);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Lead%d_%d_InspectRect1_Right", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].right);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Lead%d_%d_InspectRect1_Bottom", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionLead[j][k].bottom);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_LEAD; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_Lead%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_bParaLead[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_LEAD; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Lead%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaLead[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_LEAD; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_Lead%d", i, j);
					dat.Empty();
					dat.Format("%f", m_VDat[i]->m_InsPara.m_dParaLead[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_LEAD; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_Lead%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaMapLead[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				/////////////////////////////////////
				
				//Film//////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_FILM; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_Film%d_%d_InspectRect1_Left", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].left);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Film%d_%d_InspectRect1_Top", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].top);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Film%d_%d_InspectRect1_Right", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].right);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_Film%d_%d_InspectRect1_Bottom", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionFilm[j][k].bottom);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_FILM; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_Film%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_bParaFilm[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_FILM; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Film%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaFilm[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_FILM; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_Film%d", i, j);
					dat.Empty();
					dat.Format("%f", m_VDat[i]->m_InsPara.m_dParaFilm[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_FILM; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_Film%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaMapFilm[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
				/*
				//write variation region
				if(m_VDat[i]->m_InsPara.m_bCreatFilmVarID[j])
				{
				pat_path = path + "\\VarFilm."; 
				extention.Format("v%d_%d", i, j);
				pat_path = pat_path + extention;
				set_check("~give_error");
				Herr = write_variation_model(m_VDat[i]->m_InsPara.m_FilmVarID[j], HTuple(((LPCTSTR)pat_path)));
				set_check("give_error");
				if(H_MSG_TRUE == Herr)
				{
				m_VDat[i]->m_InsPara.m_bCreatFilmVarID[j] = TRUE;	
				}
				else
				{
				m_VDat[i]->m_InsPara.m_bCreatFilmVarID[j] = FALSE;
				}
				}
					*/
				}
				/////////////////////////////////////
				
				//OCV////////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_OCV; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_OCV%d_%d_InspectRect1_Left", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].left);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_OCV%d_%d_InspectRect1_Top", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].top);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_OCV%d_%d_InspectRect1_Right", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].right);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_OCV%d_%d_InspectRect1_Bottom", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionOCV[j][k].bottom);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_OCV; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_OCV%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_bParaOCV[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_OCV; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_OCV%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaOCV[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_OCV; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_OCV%d", i, j);
					dat.Empty();
					dat.Format("%f", m_VDat[i]->m_InsPara.m_dParaOCV[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_OCV; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_OCV%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaMapOCV[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < OCV_CHAR_MAX_NUM; j++)
				{
					key.Empty();
					key.Format("CAM%d_Char_OCV%d_InspectRect1_Left", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].left);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					
					key.Empty();
					key.Format("CAM%d_Char_OCV%d_InspectRect1_Top", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].top);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					
					key.Empty();
					key.Format("CAM%d_Char_OCV%d_InspectRect1_Right", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].right);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					
					key.Empty();
					key.Format("CAM%d_Char_OCV%d_InspectRect1_Bottom", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_InsCharRegionOCV[j].bottom);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					
					key.Empty();
					key.Format("CAM%d_Char_CenterX_OCV%d", i, j);
					dat.Empty();
					dat.Format("%f", m_VDat[i]->m_InsPara.m_dCharCenterX[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					
					key.Empty();
					key.Format("CAM%d_Char_CenterY_OCV%d", i, j);
					dat.Empty();
					dat.Format("%f", m_VDat[i]->m_InsPara.m_dCharCenterY[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					
					//write shape region
					if(m_VDat[i]->m_InsPara.m_bCreatMdIDOCV[j])
					{
						pat_path = path + "\\PatternOCV."; 
						extention.Format("m%d_%d", i, j);
						pat_path = pat_path + extention;
						set_check("~give_error");
						Herr = write_shape_model(m_VDat[i]->m_InsPara.m_PatIDOCV[j], HTuple(((LPCTSTR)pat_path)));
						set_check("give_error");
						if(H_MSG_TRUE == Herr)
						{
							m_VDat[i]->m_InsPara.m_bCreatMdIDOCV[j] = TRUE;	
						}
						else
						{
							m_VDat[i]->m_InsPara.m_bCreatMdIDOCV[j] = FALSE;
						}
					}
					
					//write variation region
// 					if(m_VDat[i]->m_InsPara.m_bCreatCharVarID[j])
// 					{
// 						pat_path = path + "\\VarOCV."; 
// 						extention.Format("v%d_%d", i, j);
// 						pat_path = pat_path + extention;
// 						set_check("~give_error");
// 						Herr = write_variation_model(m_VDat[i]->m_InsPara.m_CharVarID[j], HTuple(((LPCTSTR)pat_path)));
// 						set_check("give_error");
// 						if(H_MSG_TRUE == Herr)
// 						{
// 							m_VDat[i]->m_InsPara.m_bCreatCharVarID[j] = TRUE;	
// 						}
// 						else
// 						{
// 							m_VDat[i]->m_InsPara.m_bCreatCharVarID[j] = FALSE;
// 						}
// 					}
				}
				
				/////////////////////////////////////
				
				//SR//////////////////////////////
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < RECT_PARA_MAX_NUM_SR; k++)
					{
						key.Empty();
						key.Format("CAM%d_Ins_SR%d_%d_InspectRect1_Left", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].left);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_SR%d_%d_InspectRect1_Top", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].top);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_SR%d_%d_InspectRect1_Right", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].right);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
						
						key.Empty();
						key.Format("CAM%d_Ins_SR%d_%d_InspectRect1_Bottom", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionSR[j][k].bottom);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					}
				}
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_SR; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_SR%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_bParaSR[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_SR; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_SR%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaSR[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_SR; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_SR%d", i, j);
					dat.Empty();
					dat.Format("%f", m_VDat[i]->m_InsPara.m_dParaSR[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_SR; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_SR%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaMapSR[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					//write variation region
// 					if(m_VDat[i]->m_InsPara.m_bCreatSRVarID[j])
// 					{
// 						pat_path = path + "\\VarSR."; 
// 						extention.Format("v%d_%d", i, j);
// 						pat_path = pat_path + extention;
// 						set_check("~give_error");
// 						Herr = write_variation_model(m_VDat[i]->m_InsPara.m_SRVarID[j], HTuple(((LPCTSTR)pat_path)));
// 						set_check("give_error");
// 						if(H_MSG_TRUE == Herr)
// 						{
// 							m_VDat[i]->m_InsPara.m_bCreatSRVarID[j] = TRUE;	
// 						}
// 						else
// 						{
// 							m_VDat[i]->m_InsPara.m_bCreatSRVarID[j] = FALSE;
// 						}
// 					}
				}
				/////////////////////////////////////
				
				//Write master image
				master_path = path + "\\MasterImage.bmp"; 
				set_check("~give_error");
				Herr= write_image(m_VDat[0]->m_HalMasterImage, "bmp", 0, HTuple((LPCTSTR)master_path));
				set_check("give_error");
				
				//Write SR master image
				master_path = path + "\\SRMasterImage.bmp"; 
				set_check("~give_error");
				Herr= write_image(m_VDat[0]->m_HalSRMasterImage, "bmp", 0, HTuple((LPCTSTR)master_path));
				set_check("give_error");
				
				//Write Lead master image
				master_path = path + "\\LeadMasterImage.bmp"; 
				set_check("~give_error");
				Herr= write_image(m_VDat[0]->m_HalLeadMasterImage, "bmp", 0, HTuple((LPCTSTR)master_path));
				set_check("give_error");
				
				//Write SROut master image
				master_path = path + "\\SROutMasterImage.bmp"; 
				set_check("~give_error");
				Herr= write_image(m_VDat[0]->m_HalSROutMasterImage, "bmp", 0, HTuple((LPCTSTR)master_path));
				set_check("give_error");
				
				//Write Taught image			
				for(j = 0; j < IMAGE_MAP_MAX_NUM; j++)
				{
					master_path = path + "\\TaughtImage"; 
					extention.Format("%d.bmp", j);
					master_path = master_path + extention;
					set_check("~give_error");
					Herr= write_image(m_VDat[0]->m_HalTaughtImage[j], "bmp", 0, HTuple((LPCTSTR)master_path));
					set_check("give_error");
				}
				
				//Write inspection region
				for(j = 0; j < SUB_RGN_MAX_NUM; j++)
				{
					for(k = 0; k < INS_RGN_MAX_NUM; k++)
					{
						pat_path = path + "\\InsRegion."; 
						extention.Format("%d_%d_%d", i, j, k);
						pat_path = pat_path + extention;
						set_check("~give_error");
						Herr = write_region(m_VDat[i]->m_HalInsRgn[j][k], pat_path);
						set_check("give_error");
					}
				}
				
				//Light
				for(j = 0; j < IMAGE_MAP_MAX_NUM; j++)
				{
					for(k = 0; k < LIGHT_CH_MAX_NUM; k++)
					{
						key.Empty();
						key.Format("CAM%d_iPara_Map%d_Light%d", i, j, k);
						dat.Empty();
						dat.Format("%d", m_VDat[i]->m_InsPara.m_iLightVar[j][k]);
						WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					}
				}
				//20100702
				//PPunch/////////////////////////////
				for(j = 0; j < RECT_PARA_MAX_NUM_PPUNCH; j++)
				{
					key.Empty();
					key.Format("CAM%d_Ins_PPUNCH%d_InspectRect1_Left", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].left);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					
					key.Empty();
					key.Format("CAM%d_Ins_PPUNCH%d_InspectRect1_Top", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].top);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					
					key.Empty();
					key.Format("CAM%d_Ins_PPUNCH%d_InspectRect1_Right", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].right);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
					
					key.Empty();
					key.Format("CAM%d_Ins_PPUNCH%d_InspectRect1_Bottom", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_InsRegionPPunch[j].bottom);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				
				for(j = 0; j < BOOL_PARA_MAX_NUM_PPUNCH; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_PPUNCH%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_bParaPPunch[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAX_NUM_PPUNCH; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_PPUNCH%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaPPunch[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < DBL_PARA_MAX_NUM_PPUNCH; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_PPUNCH%d", i, j);
					dat.Empty();
					dat.Format("%f", m_VDat[i]->m_InsPara.m_dParaPPunch[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				
				for(j = 0; j < INT_PARA_MAP_MAX_NUM_PPUNCH; j++)
				{
					key.Empty();
					key.Format("CAM%d_iParaMap_PPUNCH%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_InsPara.m_iParaMapPPunch[j]);
					WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, file_path);
				}
				break;				
				
			case 1:

				break;
			}
		}
		
	}
	fd=0;
	
	return rslt;
}

//Load/save system parameter
BOOL C_VisionModule::LoadSystemPara(CString path)
{
	char temp[DAT_STR_LENG];
	BOOL rslt = TRUE;
	CString key, dat;
	int i, j;

	path = path + "\\System.par";
	//file 존재 확인 
	HANDLE fd = CreateFile( path,
							GENERIC_READ|GENERIC_WRITE,
							0,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL
							);
	if(((LONG)fd)<0)
	{
		rslt = FALSE;
	}
	else
	{
		CloseHandle(fd);

		//Read INI
		for(i = 0; i < IMG_RECT_MAX_NUM; i++)
		{
			
			key.Empty();
			key.Format("PC_INDEX_CH%d", i);
			m_VDat[i]->m_SysPara.m_iPCIdx = GetPrivateProfileInt("SYSTEM_PARAMETER", key, 0, path);

			for(j = 0; j < BOOL_PARA_MAX_NUM_SYS; j++)
			{
				key.Empty();
				key.Format("CAM%d_bPara_Sys%d", i, j);
				m_VDat[i]->m_SysPara.m_bPara[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, path);
			}

			for(j = 0; j < INT_PARA_MAX_NUM_SYS; j++)
			{
				key.Empty();
				key.Format("CAM%d_iPara_Sys%d", i, j);
				m_VDat[i]->m_SysPara.m_iPara[j] = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, path);
			}

			for(j = 0; j < DBL_PARA_MAX_NUM_SYS; j++)
			{
				key.Empty();
				key.Format("CAM%d_dPara_Sys%d", i, j);
				GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), path);
				m_VDat[i]->m_SysPara.m_dPara[j] = atof(temp);
			}
		}
	}
	fd=0;

	return rslt;
}

BOOL  C_VisionModule::SaveSystemPara(CString path)
{
	BOOL rslt = TRUE;
	CString key, dat;
	int i, j;

	//Make director
	MakeDirectories(path);
	path = path + "\\System.par";
	//file 존재 확인 
	HANDLE fd=CreateFile(   path,
							GENERIC_READ|GENERIC_WRITE,
							0,
							NULL,
							CREATE_ALWAYS,
							FILE_ATTRIBUTE_NORMAL,
							NULL
							);
	if(((LONG)fd)<0)
	{
		rslt = FALSE;
	}
	else
	{
		CloseHandle(fd);

		//Write INI
		for(i = 0; i < IMG_RECT_MAX_NUM; i++)
		{
			key.Empty();
			key.Format("PC_INDEX_CH%d", i);
			dat.Empty();
			dat.Format("%d", m_VDat[i]->m_SysPara.m_iPCIdx);
			WritePrivateProfileString("SYSTEM_PARAMETER", key, dat, path);

			for(j = 0; j < BOOL_PARA_MAX_NUM_SYS; j++)
			{
				key.Empty();
				key.Format("CAM%d_bPara_Sys%d", i, j);
				dat.Empty();
				dat.Format("%d", m_VDat[i]->m_SysPara.m_bPara[j]);
				WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, path);
			}

			for(j = 0; j < INT_PARA_MAX_NUM_SYS; j++)
			{
				key.Empty();
				key.Format("CAM%d_iPara_Sys%d", i, j);
				dat.Empty();
				dat.Format("%d", m_VDat[i]->m_SysPara.m_iPara[j]);
				WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, path);
			}

			for(j = 0; j < DBL_PARA_MAX_NUM_SYS; j++)
			{
				key.Empty();
				key.Format("CAM%d_dPara_Sys%d", i, j);
				dat.Empty();
				dat.Format("%f", m_VDat[i]->m_SysPara.m_dPara[j]);
				WritePrivateProfileString("INSPECTION_PARAMETER", key, dat, path);
			}
		}

	}
	fd=0;

	return rslt;
}


//Load/save system result
BOOL C_VisionModule::LoadSystemRslt(CString path)
{
	BOOL rslt = TRUE;
	CString key;

	path = path + "\\MainSystem.rsl";
	//file 존재 확인 
	HANDLE fd = CreateFile( path,
							GENERIC_READ|GENERIC_WRITE,
							0,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL
							);
	if(((LONG)fd)<0)
	{
		rslt = FALSE;
	}
	else
	{
		CloseHandle(fd);

		for(int i = 0; i < CNT_MAX_NUM; i++)
		{
			key.Format("CNT%d", i);
			m_MainSysRslt.m_lCnt[i] = GetPrivateProfileInt("MAINSYSTEM_RESULT", key, 0, path);
		}
	}
	fd=0;

	return rslt;
}

BOOL C_VisionModule::SaveSystemRslt(CString path)
{
	BOOL rslt = TRUE;
	CString dat, key;

	//Make director
	MakeDirectories(path);
	path = path + "\\MainSystem.rsl";
	//file 존재 확인 
	HANDLE fd=CreateFile(   path,
							GENERIC_READ|GENERIC_WRITE,
							0,
							NULL,
							CREATE_ALWAYS,
							FILE_ATTRIBUTE_NORMAL,
							NULL
							);
	if(((LONG)fd)<0)
	{
		rslt = FALSE;
	}
	else
	{
		CloseHandle(fd);

		for(int i = 0; i < CNT_MAX_NUM; i++)
		{
			dat.Empty();
			dat.Format("%d", m_MainSysRslt.m_lCnt[i]);
			key.Format("CNT%d", i);
			WritePrivateProfileString("MAINSYSTEM_RESULT", key, dat, path);
		}

	}
	fd=0;

	return rslt;
}

//Inspection
int C_VisionModule::Inspection(int cam_idx, int buf_idx)
{
	int tot_rslt = 1;
	int rslt = 1;
	int i;
	CRect rect,rect_chip;
	BOOL punch_err;
	BOOL CheckChipFlg;//CHOKI20110117

	//Variable clear
	ResetInspectRslt();
	ResetInspectRsltRgn();

	int pf_pitch;
/*
	//Check error
	if(m_VDat[cam_idx]->m_SysPara.m_bPara[32])
	{
		write_image(*GetHalImage(cam_idx, buf_idx, 0), "bmp", 0, HTuple("d:\\error0.bmp"));
		write_image(*GetHalImage(cam_idx, buf_idx, 1), "bmp", 0, HTuple("d:\\error1.bmp"));
		write_image(*GetHalImage(cam_idx, buf_idx, 2), "bmp", 0, HTuple("d:\\error2.bmp"));
		write_image(*GetHalImage(cam_idx, buf_idx, 3), "bmp", 0, HTuple("d:\\error3.bmp"));
		write_image(*GetHalImage(cam_idx, buf_idx, 4), "bmp", 0, HTuple("d:\\error4.bmp"));
		write_image(*GetHalImage(cam_idx, buf_idx, 5), "bmp", 0, HTuple("d:\\error5.bmp"));
		write_image(*GetHalImage(cam_idx, buf_idx, 6), "bmp", 0, HTuple("d:\\error6.bmp"));
		//write_image(*GetHalImage(cam_idx, buf_idx, 7), "bmp", 0, HTuple("error7.bmp"));
	}
*/	
	//SR선택이 안되었을때(상부검사만)
	if(!m_VDat[cam_idx]->m_SysPara.m_bPara[28])
	{
		//Check punching chip
		//20100111LSS
		//Punching chip
		for(i = 0; (i < m_VDat[cam_idx]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
		{
			rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].left;
			rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].top;
			rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].right;
			rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].bottom;

			//chip 중심 기준으로 편차를 찾기 위해 검사 위치 넘겨줌. 
			rect_chip.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].left;
			rect_chip.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].top;
			rect_chip.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].right;
			rect_chip.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].bottom;

			pf_pitch = (int)((m_VDat[cam_idx]->m_InsPara.m_dParaBase[1] * 1000.) / m_VDat[cam_idx]->m_SysPara.m_dPara[0]);

			m_VDat[cam_idx]->m_InsRslt.m_iRsltCheckPunch[i] = 0;//CHOKI20110113
			m_VDat[cam_idx]->m_InsRslt.m_iRsltCheckChip[i] = 0;//CHOKI20110117
			m_VDat[cam_idx]->m_InsRslt.m_iRsltCheckAlign[i] = 0;//CHOKI20110119

			//Punching chip
			CheckChipFlg = FALSE;//CHOKI20110117

			//Punching chip
			if( FindPuchingChip(0, GetHalBlueImage(cam_idx, buf_idx, 4),  //20110530 lee
								GetHalImage(cam_idx, buf_idx, 3), 
								rect, rect_chip,
								m_VDat[cam_idx]->m_InsPara.m_iParaFilm[19],
								m_VDat[cam_idx]->m_InsPara.m_iParaFilm[9],
								pf_pitch,
								m_VDat[cam_idx]->m_InsPara.m_iParaFilm[13],
								m_VDat[cam_idx]->m_InsPara.m_iParaFilm[14],
								m_VDat[cam_idx]->m_InsPara.m_iParaFilm[12],
								m_VDat[cam_idx]->m_InsPara.m_iParaFilm[15],
								m_VDat[cam_idx]->m_InsPara.m_iParaFilm[20], //CHOKI20110824
								m_VDat[cam_idx]->m_HalInsRgn[i][7],
								m_VDat[cam_idx]->m_InsPara.m_iParaBase[2], //CHOKI20111104
								&punch_err, &m_VDat[cam_idx]->m_HalRsltRgn[i][19], &CheckChipFlg))
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i] = 2;  //Punching Chip 이면 ...
				m_VDat[cam_idx]->m_InsRslt.m_iRsltCheckPunch[i] = 1;//CHOKI20110113
				Sleep(300); //20100929 lee
			}

			if(CheckChipFlg)
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltCheckChip[i] = 1;//CHOKI20110117
			}
			else
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltCheckChip[i] = 0;//CHOKI20110117
			}

			//Punching chip이라고 할지라도 PF막히면 불량(편집불량)
			if(m_VDat[cam_idx]->m_SysPara.m_bPara[12])
			{
				if(punch_err)
				{
					m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					//편집 불량 ...Punch가 있을 수도 있고 없을 수도 있다. 
					//단 Punch가 안보이더라도 PF가 막히므로 여기서 처리 가능함. 예외 가능성 있음.
					m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i] = 3;  
					gen_rectangle1(&m_VDat[cam_idx]->m_HalRsltRgn[i][19], rect.top, rect.left, rect.bottom, rect.right);//20100413 lee
				}
			}
		}
	}

	//Align
	if(1)
	{
		rslt = InspectionAlign(cam_idx, buf_idx);
	}

	if(1 != rslt)
	{
		tot_rslt = 0;
		Sleep(300);//CHOKI20100929 최소한 피딩시간보다 연산시간이 길어야 에러가 없음.
	}

	//Chip
	if(1)
	{
		rslt = InspectionChip(cam_idx, buf_idx);
	}

	if(1 != rslt)
	{
		tot_rslt = 0;
	}

	//OCV
	if(1)
	{
		rslt = InspectionOCV(cam_idx, buf_idx);
	}

	if(1 != rslt)
	{
		tot_rslt = 0;
	}

	//Film
	if(1)
	{
		rslt = InspectionFilm(cam_idx, buf_idx);
	}

	if(1 != rslt)
	{
		tot_rslt = 0;
	}

	//Lead
	if(1)
	{
		rslt = InspectionLead(cam_idx, buf_idx);
	}

	if(1 != rslt)
	{
		tot_rslt = 0;
	}

	return tot_rslt;
}

//20100702 lss
//펀칭부 검사
BOOL C_VisionModule::InspectionPPunch(long win , Hobject* rslt_rgn)
{
	BOOL rslt = TRUE;
	CRect rect;
	int dat_cam_idx, cam_idx;

	//주의 : 두번째 카메라 지만 첫번째 데이타를 가지고 검사합니다.(두번째 데이타는 사용하지 않습니다)
	dat_cam_idx = 0;

	//주의 : 이미지는 두번째 카메라를 사용합니다.
	cam_idx = 1;

	rect.left = 10;
	rect.top = 10;
	rect.right = 630;
	rect.bottom = 470;
	
	//20110516 lee
//	if( FindPPuchingChip(win, GetHalImage(cam_idx, 0, 0), rect, 
	if( FindPPuchingChip(win, GetHalRedImage(cam_idx, 2, 0), rect, 
		m_VDat[dat_cam_idx]->m_InsPara.m_iParaPPunch[0],
		m_VDat[dat_cam_idx]->m_InsPara.m_iParaPPunch[1],
		m_VDat[dat_cam_idx]->m_InsPara.m_iParaPPunch[2],
		rslt_rgn) )
	{
		rslt = TRUE;
	}
	else
	{
		rslt = FALSE;
	}
	
	
	
	return rslt;
}

//CHOKI20111013
//펀칭부 칩 위치 검사
BOOL C_VisionModule::InspectionPPunchPos(long win , Hobject* rslt_rgn)
{
	BOOL rslt = TRUE;
	CRect rect;
	int dat_cam_idx, cam_idx;

	//주의 : 두번째 카메라 지만 첫번째 데이타를 가지고 검사합니다.(두번째 데이타는 사용하지 않습니다)
	dat_cam_idx = 0;

	//주의 : 이미지는 두번째 카메라를 사용합니다.
	cam_idx = 1;

	rect.left = 240;
	rect.top = 40;
	rect.right = 380;
	rect.bottom = 440;
	
	
	if( FindPPuchingChipPos(win, GetHalRedImage(cam_idx, 2, 0), rect, 
		rslt_rgn) )
	{
		rslt = TRUE;
	}
	else
	{
		rslt = FALSE;
	}
	
	return rslt;
}

//CHOKI20100712
BOOL C_VisionModule::InspectionPunchCheck(int buf_idx)
{
	int tot_rslt = 1;
	int rslt = 1;
	int i=0;
	CRect rect;

//	//Check error
//	if(m_VDat[cam_idx]->m_SysPara.m_bPara[32])
//	{
//		write_image(*GetHalImage(0, 0, 0), "bmp", 0, HTuple("d:\\error0.bmp"));
//		write_image(*GetHalImage(0, 0, 1), "bmp", 0, HTuple("d:\\error1.bmp"));
//		write_image(*GetHalImage(0, 0, 2), "bmp", 0, HTuple("d:\\error2.bmp"));
//		write_image(*GetHalImage(0, 0, 3), "bmp", 0, HTuple("d:\\error3.bmp"));
//		write_image(*GetHalImage(0, 0, 4), "bmp", 0, HTuple("d:\\error4.bmp"));
//		write_image(*GetHalImage(0, 0, 5), "bmp", 0, HTuple("d:\\error5.bmp"));
//		write_image(*GetHalImage(0, 0, 6), "bmp", 0, HTuple("d:\\error6.bmp"));
//		//write_image(*GetHalImage(cam_idx, buf_idx, 7), "bmp", 0, HTuple("error7.bmp"));
//	}
	
		//Check punching chip
		//20100111LSS
		//Punching chip

/*	 //20110731 lee
	rect.left = m_VDat[0]->m_InsPara.m_InsRegionFilm[buf_idx][0].left;
	rect.top = m_VDat[0]->m_InsPara.m_InsRegionFilm[buf_idx][0].top;
	rect.right = m_VDat[0]->m_InsPara.m_InsRegionFilm[buf_idx][0].right;
	rect.bottom = m_VDat[0]->m_InsPara.m_InsRegionFilm[buf_idx][0].bottom;
*/
	rect.left = m_VDat[0]->m_InsPara.m_InsRegionFilm[0][0].left;
	rect.top = m_VDat[0]->m_InsPara.m_InsRegionFilm[0][0].top;
	rect.right = m_VDat[0]->m_InsPara.m_InsRegionFilm[0][0].right;
	rect.bottom = m_VDat[0]->m_InsPara.m_InsRegionFilm[0][0].bottom;
	//Punching chip

	if( CheckPuchingChipAuto(0, GetHalImage(0, buf_idx, m_VDat[0]->m_InsPara.m_iParaMapFilm[1]), rect, 
						m_VDat[0]->m_InsPara.m_iParaFilm[13],
						m_VDat[0]->m_InsPara.m_iParaFilm[14],
						m_VDat[0]->m_InsPara.m_iParaFilm[12],
						&m_VDat[0]->m_HalRsltRgn[i][19]))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
		
	
/*	BOOL rslt = TRUE;

	CRect rect, ins_rect, ins_rect2;
		
	Hobject modimage, shape;
	Hobject reudce_image;
	Hobject line;

	Hobject InsRgn;
	Hobject EmphaImage;

	long wd, ht;

	long rn;
	
	rn = 0;

	get_image_pointer1(*GetHalImage(0, 0, m_VDat[0]->m_InsPara.m_iParaMapAlign[0]), NULL, NULL, &wd, &ht);

	rect.left = m_VDat[0]->m_InsPara.m_InsRegionChip[0][0].left;
	rect.top = m_VDat[0]->m_InsPara.m_InsRegionChip[0][0].top;
	rect.right = m_VDat[0]->m_InsPara.m_InsRegionChip[0][0].right;
	rect.bottom = m_VDat[0]->m_InsPara.m_InsRegionChip[0][0].bottom;

	rslt = CheckPuchingChip(0, GetHalImage(0, 0, m_VDat[0]->m_InsPara.m_iParaMapAlign[0]), rect);//CHOKI20100712

	return rslt;*/
}

int C_VisionModule::InspectionAlign(int cam_idx, int buf_idx)
{
	int rslt = 1;
	CRect rect, ins_rect, ins_rect2;
		
	Hobject modimage, shape,Region, ImageReduced;;
	Hobject reudce_image;
	Hobject line;

	Hobject InsRgn;
	Hobject EmphaImage;
	Hobject InvertHallImage;//CHOKI20100713

	long wd, ht;
	double rx, ry, ra, rs, rscore;   
	long rn;
	int i, j;
	double offset_x, offset_y;
	double pat_score;
	
	rn = 0;
	
	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapAlign[0]), NULL, NULL, &wd, &ht);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_27!");
		WriteErrorList((LPCTSTR)status);
		return 0;
	}

	//CHOKI20100713 //20100715 lee
//	invert_image(*GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapAlign[0]), &InvertHallImage);

	//Check all skip
	BOOL all_skip = TRUE;
	for(i = 0; (i < BOOL_PARA_MAX_NUM_SYS) && (i < 30); i++)
	{
		if(m_VDat[cam_idx]->m_SysPara.m_bPara[i])
		{
			all_skip = FALSE;
		}
	}

	for(i = 0; (i < m_VDat[cam_idx]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
	{
		if(all_skip)
		{
			m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 1;
			m_VDat[cam_idx]->m_InsRslt.m_iRsltAlign[i] = 1;
			continue;
		}

		rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].left;
		rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].top;
		rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].right;
		rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].bottom;
		
		//Punching chip
		if( (m_VDat[cam_idx]->m_SysPara.m_bPara[28] && 
			FindPuchingChipSR(0, GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapAlign[0]), rect)) )
		{
			m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 1;

			//Puching chip
			m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i] = 2;
		}

		//20110629 lee Punch도 align 검사 하기 위해 

/*
		else if( (!m_VDat[cam_idx]->m_SysPara.m_bPara[28]) && (2 == m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i]) || (3 == m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i]))
		{
			if(2 == m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i])
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 1;
			}

		}
*/
		else
		{
			pat_score = (((double)m_VDat[cam_idx]->m_InsPara.m_iParaAlign[1]) * 0.01);

			m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 1;
			m_VDat[cam_idx]->m_InsRslt.m_iRsltAlign[i] = 1;
			
			for(j = 0; j < PATTERN_INS_NUM; j++)
			{
				//PC#1이면 한번만검사 
				if(1 == GetPCNum(0))
				{
					if(1 == j)
					{
						continue;
					}
				}

				//대칭으로 만들어 2번째 align 검사
				// 20110530 Dongwhe* BEGIN
				// 반대쪽 Align Mark도 따로 지정해주도록 변경
				// -> 대칭으로 만들어내지 않음
				
				ins_rect = m_VDat[cam_idx]->m_InsPara.m_InsRegionAlign[i][(j==0?0:2)];
				gen_rectangle1(&InsRgn, ins_rect.top, ins_rect.left, ins_rect.bottom, ins_rect.right);
				
				/*
				switch(j)
				{
				case 0:
				gen_rectangle1(&InsRgn, ins_rect.top, 
				ins_rect.left, 
				ins_rect.bottom, 
				ins_rect.right);
				break;
				case 1:
				default:
				if( ins_rect.left < (wd * 0.5) )
				{
				//Make right
				ins_rect2 = ins_rect;
				ins_rect2.left = wd - ins_rect.left;
				ins_rect2.right = ins_rect2.left + ins_rect.Width();
				
				  ins_rect2.NormalizeRect();
				  
					gen_rectangle1(&InsRgn, ins_rect2.top, 
					ins_rect2.left, 
					ins_rect2.bottom, 
					ins_rect2.right);
					}
					else
					{
					//Make left
					ins_rect2 = ins_rect;
					ins_rect2.left = wd - ins_rect.right;
					ins_rect2.right = ins_rect2.left + ins_rect.Width();
					
					  ins_rect2.NormalizeRect();
					  
						gen_rectangle1(&InsRgn, ins_rect2.top, 
						ins_rect2.left, 
						ins_rect2.bottom, 
						ins_rect2.right);
						}
						break;
						}
				*/
				
				concat_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][0], InsRgn, &m_VDat[cam_idx]->m_HalRsltRgn[i][0]);
				
				if(!m_VDat[cam_idx]->m_InsPara.m_bCreatMdIDAlign)
				{
					//Inspection fail
					m_VDat[cam_idx]->m_InsRslt.m_iRsltAlign[i] = -11;
					m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
					rslt = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					
					continue;
				}
				//20100715 lee
				reduce_domain(*GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapAlign[0]),InsRgn,&ImageReduced);
				emphasize(ImageReduced, &EmphaImage, 5, 5, 3); //20100715 lee
				
				//				reduce_domain(EmphaImage,InsRgn,&reudce_image);
				
				Hal_ShapePatternFind(0, 
					&EmphaImage,  //20100715 lee
					(j==0?m_VDat[cam_idx]->m_InsPara.m_PatIDAlign:m_VDat[cam_idx]->m_InsPara.m_PatIDAlign2), 
					m_VDat[cam_idx]->m_InsPara.m_PatParaAlign, 
					//					m_VDat[cam_idx]->m_InsPara.m_InsRegionAlign[0][1],//model 영역(고정)
					m_VDat[cam_idx]->m_InsPara.m_InsRegionAlign[0][(j==0?1:3)],//model 영역(고정)
					wd, ht,
					//					m_VDat[cam_idx]->m_InsPara.m_dParaAlign[0],//pattern cx 
					//					m_VDat[cam_idx]->m_InsPara.m_dParaAlign[1],//pattern cy
					m_VDat[cam_idx]->m_InsPara.m_dParaAlign[(j==0?0:2)],//pattern cx 
					m_VDat[cam_idx]->m_InsPara.m_dParaAlign[(j==0?1:3)],//pattern cy
					pat_score,//Score
					&modimage, 
					&shape, 
					&rx, 
					&ry, 
					&ra, 
					&rs, 
					&rscore, 
					&rn);
				// 20110530 Dongwhe* END
				if(rn)
				{
					gen_region_line(&line, (long)ry, (long)rx - 10, (long)ry, (long)rx + 10);
					concat_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][1], line, &m_VDat[cam_idx]->m_HalRsltRgn[i][1]);
					gen_region_line(&line, (long)ry - 10, (long)rx, (long)ry + 10, (long)rx);
					concat_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][1], line, &m_VDat[cam_idx]->m_HalRsltRgn[i][1]);
					concat_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][1], modimage, &m_VDat[cam_idx]->m_HalRsltRgn[i][1]);
					
					concat_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][2], shape, &m_VDat[cam_idx]->m_HalRsltRgn[i][2]);
					
					m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][j] = rx;
					m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][j] = ry;
					m_VDat[cam_idx]->m_InsRslt.m_dScoreAlign[i][j] = rscore;
					
					//Pos. limit check
					offset_x = rx - m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][j];
					offset_x = fabs(offset_x);
					if( (m_VDat[cam_idx]->m_InsPara.m_iParaAlign[2] < offset_x) )
					{
						//Limit error
						m_VDat[cam_idx]->m_InsRslt.m_iRsltAlign[i] = -12;
						m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;	
						rslt = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					}
				}
				else
				{
					//Can't find
					m_VDat[cam_idx]->m_InsRslt.m_iRsltAlign[i] = -10;
					m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
					rslt = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
				}
			}

			//둘다 성공했으면
			if(1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltAlign[i])
			{
				//첫번째 가지고 x, y offset을 결정한다.
				offset_x = m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0] - m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0];
				offset_y = m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0] - m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0];
				m_VDat[cam_idx]->m_InsRslt.m_dOffsetX[i] = offset_x;
				m_VDat[cam_idx]->m_InsRslt.m_dOffsetY[i] = offset_y;
			}
		}
	}
	

	return rslt;
	
}

int C_VisionModule::InspectionAlignForAutoOCVTeach(int cam_idx, int buf_idx, Hobject *mod_image, Hobject *shape, 
												   double *rx, double *ry, double *rscore, long *rn,
												   double *offset_x, double *offset_y)
{
	int rslt = 1;

	CRect rect,rect_chip;
		
	Hobject reudce_image, InsRgn;  //20100715 lee
	Hobject line;

	long wd, ht;
	double ra, rs;   
	int i;
	double pat_score;

//	BOOL punch_rslt;

	Hobject EmphaImage;
	
	*rn = 0;
	
	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapAlign[0]), NULL, NULL, &wd, &ht);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_28!");
		WriteErrorList((LPCTSTR)status);
		return 0;
	}
	
	for(i = 0; i < 1; i++)//첫번째것만
	{
			gen_rectangle1(&InsRgn, m_VDat[cam_idx]->m_InsPara.m_InsRegionAlign[i][0].top, 
			m_VDat[cam_idx]->m_InsPara.m_InsRegionAlign[i][0].left, 
			m_VDat[cam_idx]->m_InsPara.m_InsRegionAlign[i][0].bottom, 
			m_VDat[cam_idx]->m_InsPara.m_InsRegionAlign[i][0].right);
		
		if(!m_VDat[cam_idx]->m_InsPara.m_bCreatMdIDAlign)
		{
			//Inspection fail
			rslt = 0;
		}
		

		reduce_domain(*GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapAlign[0]),InsRgn,&reudce_image); //20100715 lee
		emphasize(reudce_image, &EmphaImage, 5, 5, 3); //20100715 lee

		pat_score = (((double)m_VDat[cam_idx]->m_InsPara.m_iParaAlign[1]) * 0.01);
		

		Hal_ShapePatternFind(0, 
			&EmphaImage,  //20100715 lee
			m_VDat[cam_idx]->m_InsPara.m_PatIDAlign, 
			m_VDat[cam_idx]->m_InsPara.m_PatParaAlign, 
			m_VDat[cam_idx]->m_InsPara.m_InsRegionAlign[0][1],//model 영역(고정)
			wd, ht,
			m_VDat[cam_idx]->m_InsPara.m_dParaAlign[0],//pattern cx 
			m_VDat[cam_idx]->m_InsPara.m_dParaAlign[1],//pattern cy
			pat_score,//Score
			mod_image, 
			shape, 
			rx, 
			ry, 
			&ra, 
			&rs, 
			rscore, 
			rn);
		if(*rn)
		{
			rslt = 1;
			
			*offset_x = *rx - m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0];
			*offset_y = *ry - m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0];

			//Check punching chip
			rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].left + *offset_x;
			rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].top + *offset_y;
			rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].right + *offset_x;
			rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].right + *offset_y; //20100715 lee

			//chip 중심에서 편차를 구하기 위해 ..
			rect_chip.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].left + *offset_x;
			rect_chip.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].top + *offset_y;
			rect_chip.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].right + *offset_x;
			rect_chip.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].bottom + *offset_y;

			//Punching chip
/*			if( FindPuchingChip(0, GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapFilm[1]), rect,rect_chip, 0, 0, 0, 
								m_VDat[cam_idx]->m_InsPara.m_iParaFilm[13],
								m_VDat[cam_idx]->m_InsPara.m_iParaFilm[14],
								m_VDat[cam_idx]->m_InsPara.m_iParaFilm[12],
								m_VDat[cam_idx]->m_InsPara.m_iParaFilm[15] + 500,
								&punch_rslt, &m_VDat[cam_idx]->m_HalRsltRgn[i][19]) )
			{
				rslt = 2;
			}
*/
		}
		else
		{
			rslt = 0;
		}

	}
	

	return rslt;
	
}

int C_VisionModule::InspectionChip(int cam_idx, int buf_idx)
{
	int rslt = 1;
	
	Hobject modimage, shape;
	Hobject reudce_image;
	Hobject line;

	long wd, ht;
	long rn;
	int i;
	double offset_x, offset_y;
	CRect rect, film_rect;

	long over_area, under_area;
	
	rn = 0;
	
	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[0]), NULL, NULL, &wd, &ht);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_29!");
		WriteErrorList((LPCTSTR)status);
		return 0;
	}

	//Check all skip
	BOOL all_skip = TRUE;
	for(i = 0; (i < BOOL_PARA_MAX_NUM_SYS) && (i < 30); i++)
	{
		if(m_VDat[cam_idx]->m_SysPara.m_bPara[i])
		{
			all_skip = FALSE;
		}
	}

	for(i = 0; (i < m_VDat[cam_idx]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
	{
		//20110629 lee Punch도 align 검사 하기 위해 
		if(1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltAlign[i] && (!all_skip) && (2 != m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i]) &&
	      (3 != m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i]))
		{
			m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i] = 1;

			//Find chip//////////////////////////////
			
			//Offset
			offset_x = m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0] - m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0];
			offset_y = m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0] - m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0];
			
			rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].left + offset_x;
			rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].top + offset_y;
			rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].right + offset_x;
			rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].bottom + offset_y;

			gen_rectangle1(&m_VDat[cam_idx]->m_HalRsltRgn[i][10], rect.top, rect.left, rect.bottom, rect.right);

			//20100111LSS
			//Punching chip
			if(0)
			{
				//Puching chip
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i] = 2;
			}
			else
			{
				if(m_VDat[cam_idx]->m_SysPara.m_bPara[28] || m_VDat[cam_idx]->m_SysPara.m_bPara[29])//SR검사/찍힘
				{
					if(m_VDat[cam_idx]->m_InsPara.m_bCreatSRVarID[i])
					{
						rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionSR[i][0].left;
						rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionSR[i][0].top;
						rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionSR[i][0].right;
						rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionSR[i][0].bottom;

						film_rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].left;
						film_rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].top;
						film_rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].right;
						film_rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].bottom;

// 						if(m_bSRBubPrepare[i])
// 						{
// 							prepare_variation_model(m_VDat[cam_idx]->m_InsPara.m_SRVarID[i], HTuple(m_VDat[cam_idx]->m_InsPara.m_iParaSR[2]), HTuple(m_VDat[cam_idx]->m_InsPara.m_iParaSR[2] * 0.4));
// 							m_bSRBubPrepare[i] = FALSE;
// 						}

						//0 : sr factor, 1 : sr tol., 2 : sr trsh, 3 : sr cnt., 4 : sr max tol, 5 : pi hall tol, 6 : pi hall thresh
						if( SRBub(0, GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapSR[0]), 
									 GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapSR[1]), 
							rect, 
							film_rect,
							m_VDat[cam_idx]->m_InsPara.m_SRVarID[i], 
							m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
							m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
							m_VDat[cam_idx]->m_InsPara.m_iParaSR[2], m_VDat[cam_idx]->m_InsPara.m_iParaSR[2] * 0.4, 
							m_VDat[cam_idx]->m_InsPara.m_iParaSR[0], m_VDat[cam_idx]->m_InsPara.m_iParaSR[1], 
							m_VDat[cam_idx]->m_InsPara.m_iParaSR[4], 
							m_VDat[cam_idx]->m_InsPara.m_iParaSR[3], 
							m_VDat[cam_idx]->m_InsPara.m_iParaSR[6], 
							m_VDat[cam_idx]->m_InsPara.m_iParaSR[5], 
							m_VDat[cam_idx]->m_InsPara.m_iParaSR[8], 
							m_VDat[cam_idx]->m_InsPara.m_iParaSR[7], 
							&m_VDat[cam_idx]->m_InsRslt.m_iSRBubNum[i], 
							&m_VDat[cam_idx]->m_HalRsltRgn[i][51],
							&m_VDat[cam_idx]->m_HalRsltRgn[i][50],
							&m_VDat[cam_idx]->m_InsRslt.m_iPIHallNum[i], 
							&m_VDat[cam_idx]->m_HalRsltRgn[i][53],
							&m_VDat[cam_idx]->m_HalRsltRgn[i][52]) )
						{
							//OK
							m_VDat[cam_idx]->m_InsRslt.m_iRsltSRBub[i] = 1;
						}
						else
						{
							//SR bubble
							if( (m_VDat[cam_idx]->m_SysPara.m_bPara[28]) && (0 < m_VDat[cam_idx]->m_InsRslt.m_iSRBubNum[i]) )
							{
								m_VDat[cam_idx]->m_InsRslt.m_iRsltSRBub[i] = -61;
							}
							else
							{
								m_VDat[cam_idx]->m_InsRslt.m_iSRBubNum[i] = 0;
								//gen_empty_obj(&m_VDat[i]->m_HalRsltRgn[i][51]);
							}

							//PI 찍힘
							if( (m_VDat[cam_idx]->m_SysPara.m_bPara[29]) && (0 < m_VDat[cam_idx]->m_InsRslt.m_iPIHallNum[i]) )
							{
								m_VDat[cam_idx]->m_InsRslt.m_iRsltSRBub[i] = -71;
							}
							else
							{
								m_VDat[cam_idx]->m_InsRslt.m_iPIHallNum[i] = 0;
								//gen_empty_obj(&m_VDat[i]->m_HalRsltRgn[i][53]);
							}

							if( (0 < m_VDat[cam_idx]->m_InsRslt.m_iSRBubNum[i]) || (0 < m_VDat[cam_idx]->m_InsRslt.m_iPIHallNum[i]) )
							{
								rslt = 0;
								m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
								m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
							}
							else
							{
								//OK
								m_VDat[cam_idx]->m_InsRslt.m_iRsltSRBub[i] = 1;
							}
						}
					}
					else
					{
						//No pattern
						m_VDat[cam_idx]->m_InsRslt.m_iRsltSRBub[i] = -60;
						rslt = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					}

				}
				else
				{
					//Find chip
					if(FindChip(0, GetHalRedImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[0]),  //CHOKI20110504 GetHalImage-> GetHalRedImage
																 rect, 
																 &m_VDat[cam_idx]->m_HalRsltRgn[i][11]))
					{
						//OK
						m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i] = 1;
					}
					else
					{
						//No chip
						m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i] = -20;
						rslt = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					}
				}
			}

			//Chipout////////////////////////////////
			if(1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i] && m_VDat[cam_idx]->m_SysPara.m_bPara[0] && !m_VDat[cam_idx]->m_SysPara.m_bPara[28])
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipOut[i] = 1;
				//0 : out tol., 1 : out threshold, 2 : out high threshold
//				if(ChipOut(0, GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[1]), GetHalImage(cam_idx, buf_idx, 3), GetHalBlueImage(cam_idx, buf_idx, 0), GetHalImage(cam_idx, buf_idx, 5), 
				//20110530 lee green에서 Chip Out이 가장 밝음. 
				if(ChipOut(0, GetHalGreenImage(cam_idx, buf_idx, 3), 
					GetHalImage(cam_idx, buf_idx, 3), 
					GetHalBlueImage(cam_idx, buf_idx, 0), 
					GetHalImage(cam_idx, buf_idx, 5), 
					GetHalGreenImage(cam_idx, buf_idx, 0), 
					m_VDat[cam_idx]->m_HalRsltRgn[i][11], 
					m_VDat[cam_idx]->m_HalInsRgn[i][7],//chip region(셋업시 등록된 영역)
					m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
					m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
					m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
					m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
					m_VDat[cam_idx]->m_InsPara.m_iParaChip[1], 
					m_VDat[cam_idx]->m_InsPara.m_iParaChip[2], 
					m_VDat[cam_idx]->m_InsPara.m_iParaChip[0], 
					m_VDat[cam_idx]->m_InsPara.m_iParaChip[18], //CHOKI20100714
					m_VDat[cam_idx]->m_InsPara.m_iParaChip[19], 
					m_VDat[cam_idx]->m_InsPara.m_iParaChip[17],
					m_VDat[cam_idx]->m_InsPara.m_iParaChip[20],
					&m_VDat[cam_idx]->m_InsRslt.m_iChipOutNum[i], 
					&m_VDat[cam_idx]->m_HalRsltRgn[i][12]))
				{
					//OK
					m_VDat[cam_idx]->m_InsRslt.m_iRsltChipOut[i] = 1;
				}
				else
				{
					//Chipout
					m_VDat[cam_idx]->m_InsRslt.m_iRsltChipOut[i] = -21;
					rslt = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
				}
			}
			else
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipOut[i] = 1;
			}

			/*
			//Broken/////////////////////////////////
			if(1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltChipBroken[i] && m_VDat[cam_idx]->m_SysPara.m_bPara[1])
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipBroken[i] = 1;
				if(ChipMold(0, GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[2]), 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][11], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[1], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[2], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[0], 
															&m_VDat[cam_idx]->m_InsRslt.m_iChipBrokenNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][13]))
				{
					//OK
					m_VDat[cam_idx]->m_InsRslt.m_iRsltChipBroken[i] = 1;
				}
				else
				{
					//Broken
					m_VDat[cam_idx]->m_InsRslt.m_iRsltChipBroken[i] = -22;
					rslt = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
				}
			}
			else
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipBroken[i] = 1;
			}
			*/

			//Chip 이면 결함/////////////////////
			//Broken & Mold//////////////////////
			if(1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i] && m_VDat[cam_idx]->m_SysPara.m_bPara[2] && !m_VDat[cam_idx]->m_SysPara.m_bPara[28])
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipMold[i] = 1;
				//3 : mold tol., 4 : mold threshold, 5 : mold high threshold, 14 : broken threshold
#ifdef AVI_TYPE_1
				if( ChipMold(0, GetHalImage(cam_idx, buf_idx, 0), //CHOKI20110921 //GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[3]), 	//AVI_TYPE_1//
								GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[2]),
															m_VDat[cam_idx]->m_HalInsRgn[i][7],//m_HalRsltRgn[i][11], //CHOKI20110427
															m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
															m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
															m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
															m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[4], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[5], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[3], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[14],
															&m_VDat[cam_idx]->m_InsRslt.m_iChipMoldNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][14],
															&m_VDat[cam_idx]->m_InsRslt.m_iChipBrokenNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][13])
															)
#else
				if( ChipMold(0, GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[3]), 
								GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[2]),
															m_VDat[cam_idx]->m_HalInsRgn[i][7],//m_HalRsltRgn[i][11], //CHOKI20110427
															m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
															m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
															m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
															m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[4], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[5], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[3], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[14],
															&m_VDat[cam_idx]->m_InsRslt.m_iChipMoldNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][14],
															&m_VDat[cam_idx]->m_InsRslt.m_iChipBrokenNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][13])
															)
#endif
				{
					//OK
					m_VDat[cam_idx]->m_InsRslt.m_iRsltChipMold[i] = 1;
					m_VDat[cam_idx]->m_InsRslt.m_iRsltChipBroken[i] = 1;
				}
				else
				{
					//Broken
					if(0 < m_VDat[cam_idx]->m_InsRslt.m_iChipBrokenNum[i])
					{
						m_VDat[cam_idx]->m_InsRslt.m_iRsltChipBroken[i] = -22;
						rslt = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					}

					//Mold
					if(0 < m_VDat[cam_idx]->m_InsRslt.m_iChipMoldNum[i])
					{
						m_VDat[cam_idx]->m_InsRslt.m_iRsltChipMold[i] = -23;
						rslt = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					}
				}
			}
			else
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipBroken[i] = 1;
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipMold[i] = 1;
			}

			//Pot////////////////////////////////////
			if(1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i] && (m_VDat[cam_idx]->m_SysPara.m_bPara[3] || m_VDat[cam_idx]->m_SysPara.m_bPara[4] || m_VDat[cam_idx]->m_SysPara.m_bPara[5]) && !m_VDat[cam_idx]->m_SysPara.m_bPara[28])
			{

			/*	//CHOKI20100906
				HTuple Row0, Col0, Row1, Col1;
				smallest_rectangle1(m_VDat[cam_idx]->m_HalRsltRgn[i][11], &Row0, &Col0, &Row1, &Col1);
				CRect PotRect;
				PotRect.top = (long)Row0[0] - m_VDat[cam_idx]->m_InsPara.m_iParaChip[22];
				PotRect.left = (long)Col0[0] - m_VDat[cam_idx]->m_InsPara.m_iParaChip[21];
				PotRect.bottom = (long)Row1[0] + m_VDat[cam_idx]->m_InsPara.m_iParaChip[24];
				PotRect.right = (long)Col1[0] + m_VDat[cam_idx]->m_InsPara.m_iParaChip[23];
				//21 : POT영역 설정-좌측상단X
				//22 : POT영역 설정-좌측상단Y
				//23 : POT영역 설정-우측하단X
				//24 : POT영역 설정-우측하단Y
				*/



				over_area = m_VDat[cam_idx]->m_InsPara.m_iParaChip[12] * (m_VDat[cam_idx]->m_InsPara.m_iParaChip[6] * 0.01);
				under_area = m_VDat[cam_idx]->m_InsPara.m_iParaChip[12] * (m_VDat[cam_idx]->m_InsPara.m_iParaChip[8] * 0.01);

				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipNPot[i] = 1;
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipDPot[i] = 1;
				//6 : over pot tol., 7 : pot threshold, 8 : no pot tol. 12 : pot area
				if(ChipPot(0, GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[4]), 
															rect, //PotRect//CHOKI20100906
															(int)m_VDat[cam_idx]->m_InsPara.m_iParaChip[12],
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[7], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[8], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[6], 
															&m_VDat[cam_idx]->m_InsRslt.m_iChipPotNum[i],
															&m_VDat[cam_idx]->m_InsRslt.m_iChipPotArea[i],
															&m_VDat[cam_idx]->m_HalRsltRgn[i][15]))
				{
					//OK
					m_VDat[cam_idx]->m_InsRslt.m_iRsltChipDPot[i] = 1;
					m_VDat[cam_idx]->m_InsRslt.m_iRsltChipNPot[i] = 1;
				}
				else
				{
					if(m_VDat[cam_idx]->m_SysPara.m_bPara[4])
					{
						//NO POTTING
						if(under_area > m_VDat[cam_idx]->m_InsRslt.m_iChipPotArea[i])
						{
							m_VDat[cam_idx]->m_InsRslt.m_iRsltChipNPot[i] = -24;
							rslt = 0;
							m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
							m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
						}

						
					}
					
					if(m_VDat[cam_idx]->m_SysPara.m_bPara[3])
					{
						//DOUBLE POTTING
						if(over_area < m_VDat[cam_idx]->m_InsRslt.m_iChipPotArea[i])
						{
							m_VDat[cam_idx]->m_InsRslt.m_iRsltChipDPot[i] = -25;
							rslt = 0;
							m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
							m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
						}


					}

				}
			}
			else
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipDPot[i] = 1;
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipNPot[i] = 1;
			}

			//Chip 이면 결함/////////////////////
			//Pot particle///////////////////////
			if( 1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltChipDPot[i] && 1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltChipNPot[i] &&
				1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i] && 
				(m_VDat[cam_idx]->m_SysPara.m_bPara[5] || m_VDat[cam_idx]->m_SysPara.m_bPara[6]) &&
				!m_VDat[cam_idx]->m_SysPara.m_bPara[28])
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipPotP[i] = 1;
				//9 : pot part tol., 10 : pot part threshold, 11 : pot part high threshold
				//13 : pot 도포범위 tol.

				decompose3(*GetHalTaughtImage(0, 6), 
					GetHalRefRedImage(0, 1),
					GetHalRefGreenImage(0, 1),
					GetHalRefBlueImage(0, 1));

				decompose3(*GetHalTaughtImage(0, 0), //CHOKI20110824
					GetHalRefRedImage(0, 2),
					GetHalRefGreenImage(0, 2),
					GetHalRefBlueImage(0, 2));
#ifdef AVI_TYPE_1
				if(PotPart2(0, GetHalRefRedImage(cam_idx, 1), //CHOKI20100812 //CHOKI20110511
							  GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[5]), 
							  GetHalRedImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[6]),//GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[6]),//CHOKI20110424
							  GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[1]),
							  GetHalGreenImage(cam_idx, buf_idx, 0), //CHOKI20110619
							  GetHalBlueImage(cam_idx, buf_idx, 5), //CHOKI20110710
							  GetHalRefRedImage(cam_idx, 2), //CHOKI20110824
														    m_VDat[cam_idx]->m_HalInsRgn[i][7],//	m_VDat[cam_idx]->m_HalRsltRgn[i][11],//chip region 
															m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0],//m_VDat[cam_idx]->m_HalRsltRgn[i][15],//pot region
															m_VDat[cam_idx]->m_HalRsltRgn[i][15],
															m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
															m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
															m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
															m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
															 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[10], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[15],
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[11], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[9], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[16], 	
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[13], 
															m_VDat[cam_idx]->m_InsPara.m_iParaFilm[1],//Film 수지 tol.
															m_VDat[cam_idx]->m_InsPara.m_iParaFilm[2],//Film 수지 thresh.
															&m_VDat[cam_idx]->m_InsRslt.m_iChipPotPNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][16],
															&m_VDat[cam_idx]->m_InsRslt.m_iChipPotRNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][17],	
															&m_VDat[cam_idx]->m_HalRsltRgn[i][18]//인식기 영역
															)  &&
						PotPart(0, GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[5]), 
							  GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[6]),
							  GetHalGreenImage(cam_idx, buf_idx, 1), //CHOKI20110928 m_iParaMapChip[1] -> 1		//AVI_TYPE_1//
							  GetHalGreenImage(cam_idx, buf_idx, 0), //CHOKI20110926 2->0						//AVI_TYPE_1//
															m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0],
															m_VDat[cam_idx]->m_HalRsltRgn[i][11],//chip region 
															m_VDat[cam_idx]->m_HalRsltRgn[i][15],//pot region
															m_VDat[cam_idx]->m_HalInsRgn[i][0],//SR region

						m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
						m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
						m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
						m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
															 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[10], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[15],
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[11], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[9], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[16], 	
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[13], 
															m_VDat[cam_idx]->m_InsPara.m_iParaFilm[1],//Film 수지 tol.
															m_VDat[cam_idx]->m_InsPara.m_iParaFilm[2],//Film 수지 thresh.
															&m_VDat[cam_idx]->m_InsRslt.m_iChipPotPNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][16],
															&m_VDat[cam_idx]->m_InsRslt.m_iChipPotRNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][17],	
															&m_VDat[cam_idx]->m_HalRsltRgn[i][18]//인식기 영역
															))
#else
				if(PotPart2(0, GetHalRefRedImage(cam_idx, 1), //CHOKI20100812 //CHOKI20110511
							  GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[5]), 
							  GetHalRedImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[6]),//GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[6]),//CHOKI20110424
							  GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[1]),
							  GetHalGreenImage(cam_idx, buf_idx, 0), //CHOKI20110619
							  GetHalBlueImage(cam_idx, buf_idx, 5), //CHOKI20110710
							  GetHalRefRedImage(cam_idx, 2), //CHOKI20110824
														    m_VDat[cam_idx]->m_HalInsRgn[i][7],//	m_VDat[cam_idx]->m_HalRsltRgn[i][11],//chip region 
															m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0],//m_VDat[cam_idx]->m_HalRsltRgn[i][15],//pot region
															m_VDat[cam_idx]->m_HalRsltRgn[i][15],
															m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
															m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
															m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
															m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
															 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[10], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[15],
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[11], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[9], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[16], 	
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[13], 
															m_VDat[cam_idx]->m_InsPara.m_iParaFilm[1],//Film 수지 tol.
															m_VDat[cam_idx]->m_InsPara.m_iParaFilm[2],//Film 수지 thresh.
															&m_VDat[cam_idx]->m_InsRslt.m_iChipPotPNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][16],
															&m_VDat[cam_idx]->m_InsRslt.m_iChipPotRNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][17],	
															&m_VDat[cam_idx]->m_HalRsltRgn[i][18]//인식기 영역
															)  &&
						PotPart(0, GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[5]), 
							  GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[6]),
							  GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapChip[1]),
							  GetHalGreenImage(cam_idx, buf_idx, 2),
															m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0],
															m_VDat[cam_idx]->m_HalRsltRgn[i][11],//chip region 
															m_VDat[cam_idx]->m_HalRsltRgn[i][15],//pot region
															m_VDat[cam_idx]->m_HalInsRgn[i][0],//SR region

						m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
						m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
						m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
						m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
															 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[10], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[15],
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[11], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[9], 
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[16], 	
															m_VDat[cam_idx]->m_InsPara.m_iParaChip[13], 
															m_VDat[cam_idx]->m_InsPara.m_iParaFilm[1],//Film 수지 tol.
															m_VDat[cam_idx]->m_InsPara.m_iParaFilm[2],//Film 수지 thresh.
															&m_VDat[cam_idx]->m_InsRslt.m_iChipPotPNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][16],
															&m_VDat[cam_idx]->m_InsRslt.m_iChipPotRNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][17],	
															&m_VDat[cam_idx]->m_HalRsltRgn[i][18]//인식기 영역
															))
#endif
				{
					//OK
					m_VDat[cam_idx]->m_InsRslt.m_iRsltChipPotP[i] = 1;
					m_VDat[cam_idx]->m_InsRslt.m_iRsltChipPotR[i] = 1;
				}
				else
				{
					//Particle
					if( m_VDat[cam_idx]->m_SysPara.m_bPara[5] && (0 < m_VDat[cam_idx]->m_InsRslt.m_iChipPotPNum[i]) )
					{
						m_VDat[cam_idx]->m_InsRslt.m_iRsltChipPotP[i] = -26;
						rslt = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					}

					//Pot range
					if( m_VDat[cam_idx]->m_SysPara.m_bPara[6] && (0 < m_VDat[cam_idx]->m_InsRslt.m_iChipPotRNum[i]) )
					{
						m_VDat[cam_idx]->m_InsRslt.m_iRsltChipPotR[i] = -27;
						rslt = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					}
				}
			}
			else
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltChipPotP[i] = 1;
			}
		}
	}
	
	return rslt;
}

int C_VisionModule::InspectionFilm(int cam_idx, int buf_idx)
{
	int rslt = 1;
		
	Hobject modimage, shape;
	Hobject reudce_image;
	Hobject line;

	long wd, ht;
	long rn;
	int i;
	double offset_x, offset_y;
	CRect rect, chip_rect, ocv_rect, chip_rect_insp, ocv_rect_insp;
	
	rn = 0;
	
	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapFilm[0]), NULL, NULL, &wd, &ht);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_30!");
		WriteErrorList((LPCTSTR)status);
		return 0;
	}

	for(i = 0; (i < m_VDat[cam_idx]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
	{
		if((2 != m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i]) && (3 != m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i]) && !m_VDat[cam_idx]->m_SysPara.m_bPara[28] && 1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltAlign[i])//if not no chip and puching chip
		{
			//Y offset
			offset_x = m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0] - m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0];
			offset_y = m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0] - m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0];
			
			//For display
			//Film-mold inspection region
			rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].left + offset_x;
			rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].top + offset_y;
			rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].right + offset_x;
			rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].bottom + offset_y;
			
			//Chip inspection region
			chip_rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].left + offset_x;
			chip_rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].top + offset_y;
			chip_rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].right + offset_x;
			chip_rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].bottom + offset_y;

			//20100720 lee
			chip_rect_insp = chip_rect;

			//OCV inspection region
			ocv_rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].left + offset_x;
			ocv_rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].top + offset_y;
			ocv_rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].right + offset_x;
			ocv_rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].bottom + offset_y;

			//20100720 lee
			ocv_rect_insp = ocv_rect;

			gen_rectangle1(&m_VDat[cam_idx]->m_HalRsltRgn[i][20], rect.top, rect.left, rect.bottom, rect.right);
			gen_rectangle1(&m_VDat[cam_idx]->m_HalRsltRgn[i][21], chip_rect.top, chip_rect.left, chip_rect.bottom, chip_rect.right);
			gen_rectangle1(&m_VDat[cam_idx]->m_HalRsltRgn[i][22], ocv_rect.top, ocv_rect.left, ocv_rect.bottom, ocv_rect.right);		

			//For inspection
			//Film-mold inspection region
			rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].left;
			rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].top;
			rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].right;
			rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].bottom;
			
			//Chip inspection region
			chip_rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].left;
			chip_rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].top;
			chip_rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].right;
			chip_rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionChip[i][0].bottom;	

			 //20100720 lee  //영상 보정된 영역을 사용하기 위해 
			//OCV inspection region
			ocv_rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].left;
			ocv_rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].top;
			ocv_rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].right;
			ocv_rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].bottom;

			//Mold////////////////////////////////
			if(m_VDat[cam_idx]->m_SysPara.m_bPara[10] && 
			  (-50 != m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i]) &&
			  (-51 != m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i]) &&
			  (-52 != m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i]) &&
			  (-53 != m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i]) 
			 )
			{
				//if(m_VDat[cam_idx]->m_InsPara.m_bCreatFilmVarID[i])
				if(1)
				{
					//0 : mold factor(mean_image), 1 : mold tol., 2 : mold thrsh.
					decompose3(*GetHalTaughtImage(0, 0), 
						GetHalRefRedImage(0, 0),
						GetHalRefGreenImage(0, 0),
						GetHalRefBlueImage(0, 0));

					decompose3(*GetHalTaughtImage(0, 6), 
						GetHalRefRedImage(0, 1),
						GetHalRefGreenImage(0, 1),
						GetHalRefBlueImage(0, 1));
					
					if( FilmMold(0, 
						//GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapAlign[0]),//map 0
						//20100315 lss
						GetHalRedImage(cam_idx, buf_idx, 0),//0번이미지와 1번이미지를 더해서 부각 시킨다.
						GetHalRefRedImage(cam_idx, 1),
						GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapFilm[0]), //map 1 1
						GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapFilm[2]), //map 3 3
						GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapFilm[1]), //map 4 4
				//		GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapFilm[3]), //map 1 
						GetHalRedImage(cam_idx, buf_idx, 1), 
						GetHalGreenImage(cam_idx, buf_idx, 3), //CHOKI20101102
						GetHalRefRedImage(cam_idx, 0),//GetHalRedImage(cam_idx, buf_idx, 0), //CHOKI20110510
						GetHalGreenImage(cam_idx, buf_idx, 0), //CHOKI20110802
						rect, chip_rect, ocv_rect, m_VDat[cam_idx]->m_HalRsltRgn[i][41],//OCV chars region
						m_VDat[cam_idx]->m_HalInsRgn[i][0],//SR region
						m_VDat[cam_idx]->m_HalInsRgn[i][4],//user region
						m_VDat[cam_idx]->m_HalInsRgn[i][5],//sr out region
						m_VDat[cam_idx]->m_InsPara.m_FilmVarID[i], 
						m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
						m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
						m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
						m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
						m_VDat[cam_idx]->m_InsPara.m_iParaFilm[2], m_VDat[cam_idx]->m_InsPara.m_iParaFilm[2] * 0.4, 
						m_VDat[cam_idx]->m_InsPara.m_iParaFilm[0], m_VDat[cam_idx]->m_InsPara.m_iParaFilm[1], 
						m_VDat[cam_idx]->m_InsPara.m_iParaFilm[6],
						m_VDat[cam_idx]->m_InsPara.m_iParaFilm[8],
						m_VDat[cam_idx]->m_InsPara.m_iParaFilm[7],
						m_VDat[cam_idx]->m_InsPara.m_iParaFilm[16],
						m_VDat[cam_idx]->m_InsPara.m_iParaFilm[17],
						m_VDat[cam_idx]->m_InsPara.m_iParaFilm[18],
						&m_VDat[cam_idx]->m_InsRslt.m_iFilmMoldNum[i], 
						&m_VDat[cam_idx]->m_HalRsltRgn[i][23],
						&m_VDat[cam_idx]->m_HalRsltRgn[i][24],
						&m_VDat[cam_idx]->m_HalRsltRgn[i][27],
						&m_VDat[cam_idx]->m_HalRsltRgn[i][28],
						&m_VDat[cam_idx]->m_HalRsltRgn[i][29]) )
					{
						//OK
						m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmMold[i] = 1;
					}
					else
					{
						//Film mold
						m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmMold[i] = -31;
						rslt = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					}
				}
				else
				{
					//No pattern
					m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmMold[i] = -30;
					rslt = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
				}
			}
			else
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmMold[i] = 1;
			}

			//PF hall////////////////////////////
			if(m_VDat[cam_idx]->m_SysPara.m_bPara[11])
			{

				//CHOKI20110717
				decompose3(*GetHalTaughtImage(0, 4), 
					GetHalRefRedImage(0, 4),
					GetHalRefGreenImage(0, 4),
					GetHalRefBlueImage(0, 4));

				//CHOKI20110722
				decompose3(*GetHalTaughtImage(0, 6), 
					GetHalRefRedImage(0, 6),
					GetHalRefGreenImage(0, 6),
					GetHalRefBlueImage(0, 6));

				//3 : pf tol., 4 : pf thresh., 5 : pf high thresh.
				if( FilmPF(0, GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapFilm[4]), 
						    GetHalRedImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapFilm[5]),
							GetHalRefRedImage(cam_idx, 4), //CHOKI20110717
							GetHalRefRedImage(cam_idx, 6), //CHOKI20110722
							rect, chip_rect, 
							m_VDat[cam_idx]->m_HalInsRgn[i][1],//PF region
							m_VDat[cam_idx]->m_HalInsRgn[i][6],//vaccum region

							m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0],
							m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1],
							m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],							
							m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
							m_VDat[cam_idx]->m_InsPara.m_iParaFilm[4], 
							m_VDat[cam_idx]->m_InsPara.m_iParaFilm[5], 
							m_VDat[cam_idx]->m_InsPara.m_iParaFilm[3],  
							&m_VDat[cam_idx]->m_InsRslt.m_iFilmPFNum[i], 
							&m_VDat[cam_idx]->m_HalRsltRgn[i][25],
							&m_VDat[cam_idx]->m_HalRsltRgn[i][26]) )
				{
					//OK
					m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmPF[i] = 1;
				}
				else
				{
					//Film mold
					m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmPF[i] = -32;
					rslt = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
				}
			}
			else
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmPF[i] = 1;
			}

			//Metal particle/////////////////////
			if(m_VDat[cam_idx]->m_SysPara.m_bPara[13])
			{
#ifdef AVI_TYPE_1
				decompose3(*GetHalTaughtImage(0, 6), //CHOKI20111004 0->6		//AVI_TYPE_1//
					GetHalRefRedImage(0, 0),
					GetHalRefGreenImage(0, 0),
					GetHalRefBlueImage(0, 0));
#else
				decompose3(*GetHalTaughtImage(0, 0), 
					GetHalRefRedImage(0, 0),
					GetHalRefGreenImage(0, 0),
					GetHalRefBlueImage(0, 0));
#endif
				m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmMetal[i] = 1; //CHOKI20110427 GetHalImage -> GetHalRedImage
				if(FilmMetal(0, GetHalRedImage(cam_idx, buf_idx, 2), //CHOKKI20110427 m_VDat[cam_idx]->m_InsPara.m_iParaMapFilm[6]), 
					GetHalRefRedImage(cam_idx, 0), //CHOKI20110728
															m_VDat[cam_idx]->m_HalInsRgn[i][0],//SR region
//															m_VDat[cam_idx]->m_HalInsRgn[i][7],//chip region(셋업시 등록된 영역)
//															m_VDat[cam_idx]->m_HalRsltRgn[i][42],//OCV chars region
															chip_rect_insp, //20100720 lee
															ocv_rect_insp, //20100720 lee
															m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
															m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
															m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
															m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
															m_VDat[cam_idx]->m_InsPara.m_iParaFilm[11], 
															m_VDat[cam_idx]->m_InsPara.m_iParaFilm[10], 
															&m_VDat[cam_idx]->m_InsRslt.m_iFilmMetalNum[i], 
															&m_VDat[cam_idx]->m_HalRsltRgn[i][50]))
				{
					//OK
					m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmMetal[i] = 1;
				}
				else
				{
					//Chipout
					m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmMetal[i] = -33;
					rslt = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
				}
			}
			else
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmMetal[i] = 1;
			}

		}
		else
		{
			m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmMold[i] = 1;
			m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmPF[i] = 1;
			m_VDat[cam_idx]->m_InsRslt.m_iRsltFilmMetal[i] = 1;
		}
		
	}
	
	return rslt;
}

int C_VisionModule::InspectionLead(int cam_idx, int buf_idx)
{
	int rslt = 1;
		
	Hobject modimage, shape;
	Hobject reudce_image;
	Hobject line;

	long wd, ht;
	long rn;
	int i;
	double offset_x, offset_y;
	CRect trect, brect, lrect, rrect, SrRect;
	
	rn = 0;
	
	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapFilm[0]), NULL, NULL, &wd, &ht);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_31!");
		WriteErrorList((LPCTSTR)status);
		return 0; 
	}

	for(i = 0; (i < m_VDat[cam_idx]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
	{
		if((2 != m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i]) && (3 != m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i]) && !m_VDat[cam_idx]->m_SysPara.m_bPara[28] && 1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltAlign[i])//if not no chip and puching chip
		{
			//Y offset
			offset_x = m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0] - m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0];
			offset_y = m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0] - m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0];
			
			//Top Lead inspection region
			trect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][0].left + offset_x;
			trect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][0].top + offset_y;
			trect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][0].right + offset_x;
			trect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][0].bottom + offset_y;

			//Bottom Lead inspection region
			brect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][1].left + offset_x;
			brect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][1].top + offset_y;
			brect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][1].right + offset_x;
			brect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][1].bottom + offset_y;

			//20100621 lss
			if(m_VDat[cam_idx]->m_SysPara.m_bPara[22])
			{
				//Top Left Lead inspection region
				lrect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][2].left + offset_x;
				lrect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][2].top + offset_y;
				lrect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][2].right + offset_x;
				lrect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][2].bottom + offset_y;

				//Top Right Lead inspection region
				rrect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][3].left + offset_x;
				rrect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][3].top + offset_y;
				rrect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][3].right + offset_x;
				rrect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionLead[i][3].bottom + offset_y;
			}
			else
			{
				//Top Left Lead inspection region
				lrect.left = 0;
				lrect.top = 0;
				lrect.right = 0;
				lrect.bottom = 0;

				//Top Right Lead inspection region
				rrect.left = 0;
				rrect.top = 0;
				rrect.right = 0;
				rrect.bottom = 0;
			}

			
			//gen_rectangle1(&m_VDat[cam_idx]->m_HalRsltRgn[i][30], trect.top, trect.left, trect.bottom, trect.right);
			//gen_rectangle1(&m_VDat[cam_idx]->m_HalRsltRgn[i][31], brect.top, brect.left, brect.bottom, brect.right);
			
			//Top Lead///////////////////////////
			//double 0 : top factor, int 1 : top tol, 2 : top trsh, 6 : top-dirty tol, 7 : top-dirty trsh
			if(m_VDat[cam_idx]->m_SysPara.m_bPara[20] /*&& (-20 != m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i])*/ )
			{
				if(10 < trect.top)
				{
#ifdef AVI_TYPE_1
					if(UpLead(0, GetHalRedImage(cam_idx, buf_idx, 3), //CHOKI20101028
							GetHalBlueImage(cam_idx, buf_idx, 3),//CHOKI20101031
							GetHalGreenImage(cam_idx, buf_idx, 1), //CHOKI20101102						
							GetHalRedImage(cam_idx, buf_idx, 5),      //20110601 lee
							GetHalGreenImage(cam_idx, buf_idx, 3), //CHOKI20101116
							GetHalGreenImage(cam_idx, buf_idx, 5), //CHOKI20110511
						    GetHalBlueImage(cam_idx, buf_idx, 5), //CHOKI20110511
							GetHalGreenImage(cam_idx, buf_idx, 2), //CHOKI20110703		//AVI_TYPE_1//
							GetHalGreenImage(cam_idx, buf_idx, 4), //CHOKI20110831
						   trect, lrect, rrect,
						   m_VDat[cam_idx]->m_HalRsltRgn[i][27],//not sr black mold result
						   m_VDat[cam_idx]->m_HalInsRgn[i][2],//up lead region
						   m_VDat[cam_idx]->m_HalInsRgn[i][3],//dn lead region//CHOKI20100911
						   m_VDat[cam_idx]->m_HalInsRgn[i][8],//up left lead region
						   m_VDat[cam_idx]->m_HalInsRgn[i][9],//up right lead region
						   m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
						   m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
						   m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
						   m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
						   m_VDat[cam_idx]->m_InsPara.m_iParaLead[2],
						   m_VDat[cam_idx]->m_InsPara.m_dParaLead[0], 
						   m_VDat[cam_idx]->m_InsPara.m_iParaLead[1],
						   m_VDat[cam_idx]->m_InsPara.m_iParaLead[7], 
						   m_VDat[cam_idx]->m_InsPara.m_iParaLead[6],
						   &m_VDat[cam_idx]->m_InsRslt.m_iLeadTopNum[i], 
						   &m_VDat[cam_idx]->m_HalRsltRgn[i][32],
						   &m_VDat[cam_idx]->m_InsRslt.m_iLeadTopNum2[i], 
						   &m_VDat[cam_idx]->m_HalRsltRgn[i][34],
						   &m_VDat[cam_idx]->m_HalRsltRgn[i][30]) )
#else
					if(UpLead(0, GetHalRedImage(cam_idx, buf_idx, 3), //CHOKI20101028
							GetHalBlueImage(cam_idx, buf_idx, 3),//CHOKI20101031
							GetHalGreenImage(cam_idx, buf_idx, 1), //CHOKI20101102						
							GetHalRedImage(cam_idx, buf_idx, 5),      //20110601 lee
							GetHalGreenImage(cam_idx, buf_idx, 3), //CHOKI20101116
							GetHalGreenImage(cam_idx, buf_idx, 5), //CHOKI20110511
						    GetHalBlueImage(cam_idx, buf_idx, 5), //CHOKI20110511
							GetHalRedImage(cam_idx, buf_idx, 2), //CHOKI20110703
							GetHalGreenImage(cam_idx, buf_idx, 4), //CHOKI20110831
						   trect, lrect, rrect,
						   m_VDat[cam_idx]->m_HalRsltRgn[i][27],//not sr black mold result
						   m_VDat[cam_idx]->m_HalInsRgn[i][2],//up lead region
						   m_VDat[cam_idx]->m_HalInsRgn[i][3],//dn lead region//CHOKI20100911
						   m_VDat[cam_idx]->m_HalInsRgn[i][8],//up left lead region
						   m_VDat[cam_idx]->m_HalInsRgn[i][9],//up right lead region
						   m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
						   m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
						   m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
						   m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
						   m_VDat[cam_idx]->m_InsPara.m_iParaLead[2],
						   m_VDat[cam_idx]->m_InsPara.m_dParaLead[0], 
						   m_VDat[cam_idx]->m_InsPara.m_iParaLead[1],
						   m_VDat[cam_idx]->m_InsPara.m_iParaLead[7], 
						   m_VDat[cam_idx]->m_InsPara.m_iParaLead[6],
						   &m_VDat[cam_idx]->m_InsRslt.m_iLeadTopNum[i], 
						   &m_VDat[cam_idx]->m_HalRsltRgn[i][32],
						   &m_VDat[cam_idx]->m_InsRslt.m_iLeadTopNum2[i], 
						   &m_VDat[cam_idx]->m_HalRsltRgn[i][34],
						   &m_VDat[cam_idx]->m_HalRsltRgn[i][30]) )
#endif
					{
						//OK
						m_VDat[cam_idx]->m_InsRslt.m_iRsltLeadTop[i] = 1;
					}
					else
					{
						//Top error
						m_VDat[cam_idx]->m_InsRslt.m_iRsltLeadTop[i] = -40;
						rslt = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					}

					//CHOKI20101028
			/*		if(UpLeadScratch(0, GetHalImage(cam_idx, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapLead[4]), 
									 m_VDat[cam_idx]->m_HalRsltRgn[i][30], 
									 m_VDat[cam_idx]->m_InsPara.m_iParaLead[9], 
									 m_VDat[cam_idx]->m_InsPara.m_iParaLead[8],
									 &m_VDat[cam_idx]->m_InsRslt.m_iLeadTopNum3[i], &m_VDat[cam_idx]->m_HalRsltRgn[i][36]) )
					{

					}
					else
					{
						//Top error
						m_VDat[cam_idx]->m_InsRslt.m_iRsltLeadTop[i] = -40;
						rslt = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					}*/
				}
				else
				{
					m_VDat[cam_idx]->m_InsRslt.m_iRsltLeadTop[i] = 1;
				}
			}
			else
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltLeadTop[i] = 1;
			}

			//Bot Lead///////////////////////////
			if(m_VDat[cam_idx]->m_SysPara.m_bPara[21] /*&& (-20 != m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i])*/ )
			{
				
				//20110626 lee
				//검사 영역이 SR 검사 영역 내부에 있지 않으면 검사 PASS한다.
				
				SrRect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].left;
				SrRect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].top;
				SrRect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].right;
				SrRect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionFilm[i][0].bottom;


				if(10 < brect.top)
				{
					//20110626 lee
					//검사 영역이 SR 검사 영역 내부에 있지 않으면 검사 PASS한다.
					if(brect.left > SrRect.left && brect.right < SrRect.right)
					{	
						//double 1 : bot factor, int 4 : bot tol, 5 : bot trsh
						if(DnLead(0, GetHalRedImage(cam_idx, buf_idx, 2),//CHOKI20101102
									 GetHalGreenImage(cam_idx, buf_idx, 3),
									 GetHalRedImage(cam_idx, buf_idx, 3),
									 GetHalBlueImage(cam_idx, buf_idx, 3),
									 GetHalRedImage(cam_idx, buf_idx, 5),
									 GetHalGreenImage(cam_idx, buf_idx, 6),
									 GetHalBlueImage(cam_idx, buf_idx, 5),
									 GetHalGreenImage(cam_idx, buf_idx, 4),
							   brect,	
							   m_VDat[cam_idx]->m_HalRsltRgn[i][27],
							   m_VDat[cam_idx]->m_HalInsRgn[i][3],//dn lead region
							   m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0], 
							   m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][1], m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][1], 
							   m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0],
							   m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][1], m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][1],
							   m_VDat[cam_idx]->m_InsPara.m_iParaLead[5],
							   m_VDat[cam_idx]->m_InsPara.m_dParaLead[1], 
							   m_VDat[cam_idx]->m_InsPara.m_iParaLead[4],
							   &m_VDat[cam_idx]->m_InsRslt.m_dLeadBotWAVG[i], 
							   &m_VDat[cam_idx]->m_InsRslt.m_iLeadBotNum[i], 
							   &m_VDat[cam_idx]->m_HalRsltRgn[i][33],
							   &m_VDat[cam_idx]->m_InsRslt.m_iLeadBotNum2[i], 
							   &m_VDat[cam_idx]->m_HalRsltRgn[i][35],
							   &m_VDat[cam_idx]->m_HalRsltRgn[i][31]))
						{
							//OK
							m_VDat[cam_idx]->m_InsRslt.m_iRsltLeadBot[i] = 1;
						}
						else
						{
							//Bottom error
							m_VDat[cam_idx]->m_InsRslt.m_iRsltLeadBot[i] = -41;
							rslt = 0;
							m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
							m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
						}
					}
				}
				else
				{
					m_VDat[cam_idx]->m_InsRslt.m_iRsltLeadBot[i] = 1;
				}
			}
			else
			{
				m_VDat[cam_idx]->m_InsRslt.m_iRsltLeadBot[i] = 1;
			}

		}
		else
		{
			m_VDat[cam_idx]->m_InsRslt.m_iRsltLeadTop[i] = 1;
			m_VDat[cam_idx]->m_InsRslt.m_iRsltLeadBot[i] = 1;
		}
	}
	
	return rslt;
}

int C_VisionModule::InspectionOCV(int cam_idx, int buf_idx)
{
	int rslt = 1;

	Hobject modimage, shape, Region, ReducedImage, RegionDiff, TransImage, CropImage;
	HTuple HomMat2D;
	long wd, ht;
	double rx, ry, ra, rs, rscore, dx, dy, char_dx[SUB_RGN_MAX_NUM][OCV_CHAR_MAX_NUM], char_dy[SUB_RGN_MAX_NUM][OCV_CHAR_MAX_NUM];   
	long rn;
	int i, j;
	int idx;
	double offset_x, offset_y;
	CRect rect;
	HTuple Num;
	Hobject PatternRegion[SUB_RGN_MAX_NUM][OCV_CHAR_MAX_NUM];

	double pat_score;
	
	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*GetHalImage(0, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapOCV[0]), NULL, NULL, &wd, &ht);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_32!");
		WriteErrorList((LPCTSTR)status);
		return 0;
	}
	
	rn = 0;

	for(i = 0; (i < m_VDat[cam_idx]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM); i++)
	{
		m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i] = 1;
	}
	
	for(i = 0; (i < m_VDat[cam_idx]->m_InsPara.m_iParaBase[0]) && (i < SUB_RGN_MAX_NUM) && (m_VDat[cam_idx]->m_SysPara.m_bPara[25]); i++)
	{
		if((2 != m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i]) && (3 != m_VDat[cam_idx]->m_InsRslt.m_iRsltChipFind[i]) &&
			!m_VDat[cam_idx]->m_SysPara.m_bPara[28] && 1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltAlign[i])//if not no chip and puching chip
		{
			m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i] = 1;
			
			pat_score = (((double)m_VDat[cam_idx]->m_InsPara.m_iParaOCV[1]) * 0.01);

			//Y offset
			offset_x = m_VDat[cam_idx]->m_InsRslt.m_dCXAlign[i][0] - m_VDat[cam_idx]->m_InsPara.m_dPatternPosXAlign[i][0];
			offset_y = m_VDat[cam_idx]->m_InsRslt.m_dCYAlign[i][0] - m_VDat[cam_idx]->m_InsPara.m_dPatternPosYAlign[i][0];
			
			//For display
			rect.left = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].left + offset_x;
			rect.top = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].top + offset_y;
			rect.right = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].right + offset_x;
			rect.bottom = m_VDat[cam_idx]->m_InsPara.m_InsRegionOCV[i][0].bottom + offset_y;
			
			gen_rectangle1(&Region, rect.top, rect.left, rect.bottom, rect.right); 
			
			gen_rectangle1(&m_VDat[cam_idx]->m_HalRsltRgn[i][40], rect.top, rect.left, rect.bottom, rect.right);
			
			reduce_domain(*GetHalImage(0, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapOCV[0]), Region, &ReducedImage);
						
			dx = 0;
			dy = 0;
			if(0 < m_VDat[cam_idx]->m_InsPara.m_iParaOCV[2])
			{
				//Total//////////////////////////////
				idx = m_VDat[cam_idx]->m_InsPara.m_iParaOCV[2];
				
				modimage.Reset();
				shape.Reset();
				
				//0 : pat threshold, 1 : pat score, 2 : Taught character num, 3 : var threshold, 4 : var tol
				if(m_VDat[cam_idx]->m_InsPara.m_bCreatMdIDOCV[idx])
				{
					Hal_ShapePatternFind(0, 
						&ReducedImage, 
						m_VDat[cam_idx]->m_InsPara.m_PatIDOCV[idx], 
						m_VDat[cam_idx]->m_InsPara.m_PatParaOCV[idx], 
						m_VDat[cam_idx]->m_InsPara.m_InsCharRegionOCV[idx], 
						wd, ht,
						m_VDat[cam_idx]->m_InsPara.m_dCharCenterX[idx],
						m_VDat[cam_idx]->m_InsPara.m_dCharCenterY[idx],
						pat_score,//Score
						&m_VDat[cam_idx]->m_HalRsltRgn[i][41], 
						&shape, 
						&rx, 
						&ry, 
						&ra, 
						&rs, 
						&rscore, 
						&rn);
					if(rn)
					{
						//OK
						dx = rx - m_VDat[cam_idx]->m_InsPara.m_dCharCenterX[idx];
						dy = ry - m_VDat[cam_idx]->m_InsPara.m_dCharCenterY[idx];
					}
					else
					{
						rslt = 0;
						
						//Can't find total pattern
						m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i] = -50;
						rslt = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
						m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
					}
				}
				else
				{
					rslt = 0;
					
					//No pattern
					m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i] = -51;
					rslt = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
					m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
				}

				m_VDat[cam_idx]->m_InsRslt.m_iOCVPatNum[i] = 0;

				for(j = 0; j < m_VDat[cam_idx]->m_InsPara.m_iParaOCV[2]; j++)
				{
					modimage.Reset();
					shape.Reset();
				
					if(1 == m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i])
					{
						//Sub////////////////////////////////
						//세부영역조정
						gen_rectangle1(&Region, m_VDat[cam_idx]->m_InsPara.m_InsCharRegionOCV[j].top + dy, 
							m_VDat[cam_idx]->m_InsPara.m_InsCharRegionOCV[j].left + dx, 
							m_VDat[cam_idx]->m_InsPara.m_InsCharRegionOCV[j].bottom + dy, 
							m_VDat[cam_idx]->m_InsPara.m_InsCharRegionOCV[j].right + dx);
						reduce_domain(*GetHalImage(0, buf_idx, m_VDat[cam_idx]->m_InsPara.m_iParaMapOCV[0]), Region, &ReducedImage);
						

						if(m_VDat[cam_idx]->m_InsPara.m_bCreatMdIDOCV[j])
						{
							modimage.Reset();
							shape.Reset();
							//0 : pat threshold, 1 : pat score, 2 : Taught character num, 3 : var threshold, 4 : var tol
							Hal_ShapePatternFind(0, 
								&ReducedImage, 
								m_VDat[cam_idx]->m_InsPara.m_PatIDOCV[j], 
								m_VDat[cam_idx]->m_InsPara.m_PatParaOCV[j], 
								m_VDat[cam_idx]->m_InsPara.m_InsCharRegionOCV[j], 
								wd, ht,
								m_VDat[cam_idx]->m_InsPara.m_dCharCenterX[j],
								m_VDat[cam_idx]->m_InsPara.m_dCharCenterY[j],
								pat_score,//Score
								&modimage, 
								&shape, 
								&rx, 
								&ry, 
								&ra, 
								&rs, 
								&rscore, 
								&rn);
							if(rn)
							{
								char_dx[i][j] = rx - m_VDat[cam_idx]->m_InsPara.m_dCharCenterX[j];
								char_dy[i][j] = ry - m_VDat[cam_idx]->m_InsPara.m_dCharCenterY[j];
								
								concat_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][42], modimage, &m_VDat[cam_idx]->m_HalRsltRgn[i][42]);
								concat_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][43], shape, &m_VDat[cam_idx]->m_HalRsltRgn[i][43]);

								copy_obj(shape, &PatternRegion[i][j], 1, -1);
							}
							else
							{
								char_dx[i][j] = 0;
								char_dy[i][j] = 0;
								
								concat_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][44], Region, &m_VDat[cam_idx]->m_HalRsltRgn[i][44]);
								m_VDat[cam_idx]->m_InsRslt.m_iOCVPatNum[i]++;
								rslt = 0;
						
								//No can't find char pattern
								m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i] = -52;
								rslt = 0;
								m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
								m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
							}
						}
						else
						{
							char_dx[i][j] = 0;
							char_dy[i][j] = 0;
							
							concat_obj(m_VDat[cam_idx]->m_HalRsltRgn[i][44], Region, &m_VDat[cam_idx]->m_HalRsltRgn[i][44]);
							m_VDat[cam_idx]->m_InsRslt.m_iOCVPatNum[i]++;

							rslt = 0;
							
							//No char pattern
							m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i] = -53;
							rslt = 0;
							m_VDat[cam_idx]->m_InsRslt.m_iRslt[i] = 0;
							m_VDat[cam_idx]->m_InsRslt.m_iRsltErrNum[i]++;
						}
					}
				}
			}
		}
		else
		{
			m_VDat[cam_idx]->m_InsRslt.m_iRsltOCV[i] = 1;
		}
	}
	
	return rslt;
}

void C_VisionModule::SetNGViewMode(BOOL mode, int ng_view_idx)
{
	if(mode)
	{
		m_iNGViewMode = ng_view_idx;
		if( (0 > m_iNGViewMode) && (NG_VIEW_MAX_NUM <= m_iNGViewMode) )
		{
			m_iNGViewMode = -1;
		}
	}
	else
	{
		m_iNGViewMode = -1;
	}
}

void C_VisionModule::UpdateSRBubPrepare()
{
	int i;

	for(i = 0; i < SUB_RGN_MAX_NUM; i++)
	{
		m_bSRBubPrepare[i] = TRUE;
	}
}

//CHOKI20100628 //CHOKI20100708( Hal_FilmMold2() -> _Hal_FilmMold() )  //0/1/3/4/1
BOOL C_VisionModule::_Hal_FilmMold(long win, Hobject *align_image, Hobject *align_image2, 
								   Hobject *mold_image, Hobject *ink_image, 
								   Hobject *user_image, Hobject *scratch_image, 
								   Hobject *particle_image, Hobject *ref_imageRed0,  Hobject *Green_image0, //CHOKI20110802
     							  RECT ins_region, RECT chip_region, RECT ocv_region, 
								  Hobject ocv_chars_region, Hobject sr_region, Hobject user_region, Hobject sr_out_region,
								  long var_id, 
								  double offset_ox, double offset_oy, 
								  double offset_ox2, double offset_oy2, 
								  double offset_rx, double offset_ry,
								  double offset_rx2, double offset_ry2,
								  int abs_thresh, int var_thresh, int mold_fact, int tolerance, int tolerance_light, int user_thresh, int user_tol,
								  int sr_thresh, int sr_hi_thresh, int sr_tol,
								  long *rslt_num, Hobject *rslt_region, Hobject *rslt_sr_region, Hobject *rslt_notsr_region, Hobject *rslt_user_region, Hobject *rslt_sr_out_region,
								  long min_area, long min_width, long min_height,
								  long min_area_sr, long min_width_sr, long min_height_sr)
{
	Hobject Image, ImageLight, ImageTrans, RegionDiff, ImageReduced, ImageReducedFine, ImageReducedLight, ImageReducedLight2, ImageReducedLight3;//CHOKI20100724
	Hobject	RegionRect, ChipRect, OCVRect;
	HTuple HomMat2D, Num;
	Hobject select_object;
	Hobject ins_rgn, ins_rgn_fine, OCVRegion, ins_rgn_srout, ins_rgn_srout2;//CHOKI20100726
	HTuple DiffAng;

	Hobject RsltSRRegion, RsltNotSRRegion, RsltUserRegion, RsltSROutRegion;

	gen_empty_obj(&RsltSRRegion);
	gen_empty_obj(&RsltNotSRRegion);
	gen_empty_obj(&RsltUserRegion);
	gen_empty_obj(&RsltSROutRegion);

	int i;

	Hobject OutRgn, IntRgn, SelectRgn, ResultRgn;
	//CHOKI20101103추가
	HTuple Mean, OutMean, IntMean, Mean2, OutMean2;
	int diff_var;
	Hobject ComplRgn;
	
	//CHOKI20100724
	Hobject Dark, DarkFine, DarkSROut, UserDark, Light, Light2, MaskImage, MaskRegion, MaskRegion1, MaskRegion2;
	Hobject ImageReducedNotSR, ImageNotSR, ImageReducedUser, ImageReducedSROut;

	double offset_x, offset_y;

	long max, num;
	HTuple Max;
	Hobject MeanImage, ImageLight2, ImageLight3, SROutImage;//CHOKI20100724 ImageLight3추가
	HTuple Area;
	HTuple CircleVar;
	HTuple LightMean;
	Hobject RegionDilation2, RegionErosion2, SelectRgn2;//CHOKI20101103

	//CHOKI20110510
	Hobject RefReducedSR, RefTransRgn;
	reduce_domain(*ref_imageRed0, sr_region, &RefReducedSR);

	Hobject RefImageTrans; //CHOKI20110728

	HTuple GreenImageInt; //CHOKI20110802

	//CHOKI20110426
	Hobject ReducedGreenSR, DiffRgnGreenSR, ThreshGreenSR, ResultGreenSR;

	angle_ll(offset_ry, offset_rx, offset_ry2, offset_rx2, offset_oy, offset_ox, offset_oy2, offset_ox2, &DiffAng);

	offset_x = offset_rx - offset_ox;
	offset_y = offset_ry - offset_oy;
	ins_region.top = ins_region.top + offset_y;
	ins_region.left = ins_region.left + offset_x;	
	ins_region.bottom = ins_region.bottom + offset_y;
	ins_region.right = ins_region.right + offset_x;

	gen_rectangle1(&RegionRect, (long)(ins_region.top), 
								(long)(ins_region.left), 
								(long)(ins_region.bottom), 
								(long)(ins_region.right));

	gen_rectangle1(&ChipRect, (long)(chip_region.top + offset_y), 
							  (long)(chip_region.left + offset_x), 
							  (long)(chip_region.bottom + offset_y), 
							  (long)(chip_region.right + offset_x));

	gen_rectangle1(&OCVRect, (long)(ocv_region.top + offset_y), 
							  (long)(ocv_region.left + offset_x), 
							  (long)(ocv_region.bottom + offset_y), 
							  (long)(ocv_region.right + offset_x));

	vector_angle_to_rigid(offset_oy, offset_ox, DiffAng, offset_ry, offset_rx, HTuple(0), &HomMat2D);
	affine_trans_region(sr_region, &RsltSRRegion, HomMat2D, HTuple("false"));
	affine_trans_region(user_region, &RsltUserRegion, HomMat2D, HTuple("false"));
	affine_trans_region(sr_out_region, &RsltSROutRegion, HomMat2D, HTuple("false"));

	affine_trans_region(RefReducedSR, &RefTransRgn, HomMat2D, HTuple("false")); //CHOKI20110510
#ifdef AVI_TYPE_1
	affine_trans_image(*align_image2, &RefImageTrans, HomMat2D, HTuple("constant"), HTuple("false")); //CHOKI20110728		//AVI_TYPE_1//
#else
	affine_trans_image(*ref_imageRed0, &RefImageTrans, HomMat2D, HTuple("constant"), HTuple("false")); //CHOKI20110728
#endif
	//CHOKI20110509
//	affine_trans_region(sr_out_region, &RsltSROutRegion, HomMat2D, HTuple("false"));
//	affine_trans_region(sr_out_region, &RsltSROutRegion, HomMat2D, HTuple("false"));
	

	//Dark image/////////////////////////////////
	//Mask image(테두리 둔감하게)
	gen_image_proto(*mold_image, &MaskImage, HTuple(0));
	for(i = 0 ; i < 10; i++)
	{
		if(0 == i)
		{
			erosion_circle(RsltSRRegion, &MaskRegion1, i + 1);
			difference(RsltSRRegion, MaskRegion1, &MaskRegion);
		}
		else if(i % 2)
		{
			erosion_circle(RsltSRRegion, &MaskRegion2, i + 1);
			difference(MaskRegion1, MaskRegion2, &MaskRegion);
		}
		else
		{
			erosion_circle(RsltSRRegion, &MaskRegion1, i + 1);
			difference(MaskRegion2, MaskRegion1, &MaskRegion);
		}
		paint_region(MaskRegion, MaskImage, &MaskImage, (10 - i) * 1 + 5, HTuple("fill"));
	}

	if(win)
	{
		disp_obj(MaskImage, win);
	}

	//SR/////////////////////////////////////////
	add_image(*align_image, *mold_image, &Image, HTuple(0.9), HTuple(0));  //20100719 lee 1.0 ->0.9
	mean_image(Image, &Image, HTuple(mold_fact), HTuple(mold_fact));

	//Not SR(for lead////////////////////////////
	add_image(*align_image, *mold_image, &ImageNotSR, HTuple(0.7), HTuple(0));

	//Light image////////////////////////////////
	mean_image(*ink_image, &ImageLight, HTuple(mold_fact), HTuple(mold_fact));

	if(win)
	{
		disp_obj(Image, win);
	}
	
	//SR 전영역 검사영역, 어두운 불량////////////
	erosion_circle(RsltSRRegion, &ins_rgn, 1.5);
	difference(ins_rgn, ChipRect, &ins_rgn);
	dilation_circle(ocv_chars_region, &OCVRegion, 7.5);
	difference(ins_rgn, OCVRegion, &ins_rgn);
	reduce_domain(Image, ins_rgn, &ImageReduced);

	//CHOKI20110426
//	difference(ReducedGreenSR, ChipRect, &DiffRgnGreenSR);
//	difference(ReducedGreenSR, OCVRect, &DiffRgnGreenSR);

	reduce_domain(*particle_image, ins_rgn, &ReducedGreenSR);
	//CHOKI20110426
 //CHOKI20110509 Test
	//SR 정밀영역////////////////////////////////
	//SR 영역에서 테두리 제외 하고 검사(더 세밀히게)영역, 어두운 불량
	fill_up(ins_rgn, &ins_rgn_fine);
	erosion_circle(ins_rgn_fine, &ins_rgn_fine, 55.5);
	intersection(ins_rgn, ins_rgn_fine, &ins_rgn_fine);
	reduce_domain(Image, ins_rgn_fine, &ImageReducedFine);
	
	//Lead검사용 영역(여기서는 사용않는다 나중에 lead검사부에서 이영역을 사용한다.
	reduce_domain(ImageNotSR, RegionRect, &ImageReducedNotSR);//Lead 검사영역

	//밝은 불량//////////////////////////////////
	//ink image : map 3
	reduce_domain(ImageLight, ins_rgn, &ImageReducedLight);//긁힘같은 밝은불량  검사영역

	//밝은 불량2/////////////////////////////////
	//mold image : map 1
	reduce_domain(*mold_image, ins_rgn, &ImageReducedLight2);//밝은불량 검사영역

	//User area검사//////////////////////////////
	reduce_domain(*user_image, RsltUserRegion, &ImageReducedUser);//user area검사영역

	difference(RsltSROutRegion, ChipRect, &RsltSROutRegion);//CHOKI20110424 RsltSROutRegion 지워버려야됨
	difference(RsltSROutRegion, OCVRegion, &ins_rgn_srout);

	difference(RsltSROutRegion, OCVRect, &ins_rgn_srout2);//CHOKI20100726

//	reduce_domain(*scratch_image, RegionRect, &ImageReducedSROut);//SR out검사영역
	reduce_domain(*align_image, RegionRect, &ImageReducedSROut);//SR out검사영역//CHOKI20101102
	//reduce_domain(*mold_image, RegionRect, &ImageReducedSROut);//SR out검사영역

	emphasize(ImageReducedSROut, &ImageReducedSROut, 7, 7, 5);//흐린 이미지 강조//CHOKI20100629 7,7,6->7,7,5
	gray_erosion_rect(ImageReducedSROut, &ImageReducedSROut, 1, 1);//CHOKI20100629 3.5->3.0
	reduce_domain(ImageReducedSROut, ins_rgn_srout, &ImageReducedSROut);//SR out검사영역

//	reduce_domain(*ink_image, ins_rgn_srout2, &ImageReducedLight3);//CHOKI20100724 //CHOKI20100726 
	reduce_domain(*scratch_image, ins_rgn_srout2, &ImageReducedLight3);//CHOKI20101103
	
	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(ins_rgn, win);
		set_color(win, HTuple("blue"));
		disp_obj(RsltSROutRegion, win);
	}

	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(RsltSRRegion, win);
	}

	gen_empty_obj(&ResultRgn);

	/////////////////////////////////////////////
	//Dark///////////////////////////////////////
	//
	//For SR/////////////////////////////////////
	min_max_gray(ins_rgn, Image, HTuple(5), _, &Max, _);
	max = (long)Max[0];
	max = max - abs_thresh + 10;
	if(0 >= max) //CHOKI20110705 threshold error관련
	{
		max = 230;
	}
	if(255 < max)
	{
		max = 255;
	}

	//고정(전체)<-emphasize로 극대화 시킨 영상으로 극명하게 포화된다. 살아 남는것만 취함.
	//max = 240;
	max = 160;  //230->200 //20100719 lee

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = threshold(ImageReduced, &Dark, 0, max);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_47!... %ld", (long)max);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	//For Lead(여기 필름 검사하고는 상관없음 나중에 lead검사에 사용하려고 시행 한것임)
	set_check("~give_error");
	herr = threshold(ImageReducedNotSR, &RsltNotSRRegion, 0, max);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_48!... %ld", (long)max);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}		

	//고정(전체 줄임 fine)
	//max = 254;
	max = 160;  //230->200 //20100719 lee

	set_check("~give_error");
	herr = threshold(ImageReducedFine, &DarkFine, 0, max);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_49!... %ld", (long)max);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	
//CHOKI20100628 SR뭉침관련 수치입력
	closing_circle(Dark, &Dark, 3);//10.5->1
	connection(Dark, &Dark);
	fill_up(Dark, &Dark);
	closing_circle(Dark, &Dark, 3);//10.5->1

	closing_circle(DarkFine, &DarkFine, 3);//5.5->1
	closing_rectangle1(DarkFine, &DarkFine, 3, 3);//30.5->1
	connection(DarkFine, &DarkFine);
	fill_up(DarkFine, &DarkFine);
	closing_circle(DarkFine, &DarkFine, 3);//5.5->1
	closing_rectangle1(DarkFine, &DarkFine, 3, 3);//30.5->1
	//shape_trans(Dark, &Dark,HTuple("convex"));

	select_shape(Dark, &Dark, HTuple("area"), HTuple("and"), HTuple(min_area_sr), HTuple("max"));
	select_shape(Dark, &Dark, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width_sr).Concat(min_height_sr), HTuple("max").Concat("max"));
	select_shape(Dark, &Dark, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));

	select_shape(DarkFine, &DarkFine, HTuple("area"), HTuple("and"), HTuple(min_area_sr), HTuple("max"));
	select_shape(DarkFine, &DarkFine, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width_sr).Concat(min_height_sr), HTuple("max").Concat("max"));
	select_shape(DarkFine, &DarkFine, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));


	//주변값을 중간값으로 채운다.
//	paint_region(ChipRect, Image, &Image, 255, HTuple("fill"));

	//경계값과 비교
	count_obj(Dark, &Num);

	concat_obj(RsltSRRegion, Dark, &RsltSRRegion);
	num = (long)Num[0];
	for(i = 0; i < num; i++)
	{
		select_obj(Dark, &SelectRgn, i + 1);
		dilation_circle(SelectRgn, &OutRgn, 10.5);
		difference(OutRgn, SelectRgn, &OutRgn);
		intensity(SelectRgn, Image, &Mean, _);
		intensity(OutRgn, Image, &OutMean, _);
		intensity(SelectRgn, *Green_image0, &GreenImageInt, _); //CHOKI20110705
		diff_var = ((long)OutMean[0]) - ((long)Mean[0]);

		//크기가 크면 섬세하게 검사
		area_center(SelectRgn, &Area, _, _);
#ifdef AVI_TYPE_1
		if(300 < (long)Area[0])
		{
			//밝기
			if(0 < diff_var)
			{
				//Dark(+)
				diff_var = abs(diff_var);
				if(abs_thresh < (diff_var + 10) && (long)GreenImageInt[0] < 110) //CHOKI20110705		//AVI_TYPE_1//
				{
					concat_obj(ResultRgn, SelectRgn, &ResultRgn);
				}
			}
		}
		else
		{
			//밝기
			if(0 < diff_var)
			{
				//Dark(+)

				diff_var = abs(diff_var);
				if(abs_thresh < diff_var && (long)GreenImageInt[0] < 100) //CHOKI20110705		// 110821 ytlee 110 -> 100	//AVI_TYPE_1//
				{
					concat_obj(ResultRgn, SelectRgn, &ResultRgn);
				}
			}
		}
#else
		if(300 < (long)Area[0])
		{
			//밝기
			if(0 < diff_var)
			{
				//Dark(+)
				diff_var = abs(diff_var);
				if(abs_thresh < (diff_var + 10) && (long)GreenImageInt[0] < 110 && (long)OutMean[0] < 180) //CHOKI20110705
				{
					concat_obj(ResultRgn, SelectRgn, &ResultRgn); //CHOKI20111102 OutMean검사추가 -> 주변이  밝아 평균값이 올라감
				}
			}
		}
		else
		{
			//밝기
			if(0 < diff_var)
			{
				//Dark(+)

				diff_var = abs(diff_var);
				if(abs_thresh < diff_var && (long)GreenImageInt[0] < 100 && (long)OutMean[0] < 180) //CHOKI20110705		// 110821 ytlee 110 -> 100
				{
					concat_obj(ResultRgn, SelectRgn, &ResultRgn); //CHOKI20111102 OutMean검사추가 -> 주변이  밝아 평균값이 올라감
				}
			}
		}
#endif
	}

	//경계값과 비교
	count_obj(DarkFine, &Num);

	concat_obj(RsltSRRegion, DarkFine, &RsltSRRegion);
	num = (long)Num[0];
	for(i = 0; i < num; i++)
	{
		select_obj(DarkFine, &SelectRgn, i + 1);
		dilation_circle(SelectRgn, &OutRgn, 10.5);
		difference(OutRgn, SelectRgn, &OutRgn);
		intensity(SelectRgn, *mold_image, &Mean, _);
		intensity(OutRgn, *mold_image, &OutMean, _);
		intensity(SelectRgn, *Green_image0, &GreenImageInt, _); //CHOKI20110705
		diff_var = ((long)OutMean[0]) - ((long)Mean[0]);

		//크기가 크면 그냥 불량으로 뺀다.
		area_center(SelectRgn, &Area, _, _);


		if(300 < (long)Area[0])
		{
			//밝기
			if(0 < diff_var)
			{
				//Dark(+)
				diff_var = abs(diff_var);
				if(abs_thresh < (diff_var + 10) && (long)GreenImageInt[0] < 110) //CHOKI20110705
				{
					concat_obj(ResultRgn, SelectRgn, &ResultRgn);//CHOKI20100727 Check Point
				}
			}
		}
		else
		{
			//밝기
			if(0 < diff_var)
			{
				//Dark(+)
				diff_var = abs(diff_var);
				if(abs_thresh < diff_var && (long)GreenImageInt[0] < 110) //CHOKI20110705
				{
					concat_obj(ResultRgn, SelectRgn, &ResultRgn);
				}
			}
		}
	}

	//CHOKI20110426
	set_check("~give_error");
	herr = threshold(ReducedGreenSR, &ThreshGreenSR, HTuple(1), HTuple(40));		// 110821 ytlee 60 ->40
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_50!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	closing_circle(ThreshGreenSR,&ThreshGreenSR,HTuple(15));
//	erosion_rectangle1(ThreshGreenSR, &ThreshGreenSR, 2, 2);
//	dilation_rectangle1(ThreshGreenSR, &ThreshGreenSR, 2, 2);
	select_shape(ThreshGreenSR, &ThreshGreenSR, HTuple("area"), HTuple("and"), HTuple(10), HTuple("max"));
	select_shape(ThreshGreenSR, &ThreshGreenSR, HTuple("width").Concat("height"), HTuple("and"), HTuple(4).Concat(4), HTuple("max").Concat("max"));
	connection(ThreshGreenSR, &ThreshGreenSR);
	count_obj(ThreshGreenSR, &Num);
	num = (long)Num[0];
	if(num>0)
	{
		for(int i = 0; i < (long)Num[0]; i++)
		{
			select_obj(ThreshGreenSR, &SelectRgn2, i + 1);
			area_center(SelectRgn2, &Area, _, _);

			if((long)Area[0] > 5 )
			{
				union2(ResultRgn, SelectRgn2, &ResultRgn);
			//	concat_obj(ResultRgn, ThreshGreenSR, &ResultRgn);		
			}
		}
	
	}

	/////////////////////////////////////////////
	//For User area//////////////////////////////
	//
	min_max_gray(RsltUserRegion, *user_image, HTuple(20), _, &Max, _);
	max = (long)Max[0];
	max = max - abs_thresh;
	if(0 >= max) //CHOKI20110705 threshold error관련
	{
		max = 230;
	}

	set_check("~give_error");
	herr = threshold(ImageReducedUser, &UserDark, 0, max);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_51!... %ld", (long)max);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	closing_circle(UserDark, &Dark, 5.5);
	connection(Dark, &Dark);
	fill_up(Dark, &Dark);

	select_shape(Dark, &Dark, HTuple("area"), HTuple("and"), HTuple(min_area_sr), HTuple("max"));
	select_shape(Dark, &Dark, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width_sr).Concat(min_height_sr), HTuple("max").Concat("max"));
	select_shape(Dark, &Dark, HTuple("width").Concat("height"), HTuple("and"), HTuple(user_tol).Concat(user_tol), HTuple("max").Concat("max"));

	//경계값과 비교
	count_obj(Dark, &Num);

	concat_obj(RsltSRRegion, Dark, &RsltSRRegion);
	num = (long)Num[0];
	for(i = 0; i < num; i++)
	{
		select_obj(Dark, &SelectRgn, i + 1);
		dilation_circle(SelectRgn, &OutRgn, 10.5);
		difference(OutRgn, SelectRgn, &OutRgn);
		intensity(SelectRgn, *user_image, &Mean, _);
		intensity(OutRgn, *user_image, &OutMean, _);
		diff_var = ((long)OutMean[0]) - ((long)Mean[0]);

		if(0 < diff_var)
		{
			//Dark(+)
			diff_var = abs(diff_var);
			if(user_thresh < diff_var)
			{
			//	concat_obj(ResultRgn, SelectRgn, &ResultRgn);
				concat_obj(ResultRgn, SelectRgn, &ResultRgn);
			}
		}
	}
	//
	//
	/////////////////////////////////////////////

	HTuple MeanRefFunch; //CHOKI20110728	

	max = 255 - ( (50 - abs_thresh) );
	if(0 >= max) //CHOKI20110705 threshold error관련
	{
		max = 230;
	}

	set_check("~give_error");
	herr = threshold(ImageReducedLight, &Light, max, 255);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_52!... %ld", (long)max);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	closing_circle(Light, &Light, 5.5);
	connection(Light, &Light);
	fill_up(Light, &Light);

	select_shape(Light, &Light, HTuple("area"), HTuple("and"), HTuple(min_area_sr * 2), HTuple("max"));
	select_shape(Light, &Light, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width_sr * 2).Concat(min_height_sr * 2), HTuple("max").Concat("max"));
	select_shape(Light, &Light, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance_light).Concat(tolerance_light), HTuple("max").Concat("max"));

	//경계값과 비교
	count_obj(Light, &Num);

	concat_obj(RsltSRRegion, Light, &RsltSRRegion);
	num = (long)Num[0];
	for(i = 0; i < num; i++)
	{
		select_obj(Light, &SelectRgn, i + 1);
		dilation_circle(SelectRgn, &OutRgn, 10.5);
		difference(OutRgn, SelectRgn, &OutRgn);
		intensity(SelectRgn, ImageLight, &Mean, _);
		intensity(OutRgn, ImageLight, &OutMean, _);
		intensity(SelectRgn, RefImageTrans, &MeanRefFunch, _); //CHOKI20110728
		diff_var = ((long)OutMean[0]) - ((long)Mean[0]);

		if(0 >= diff_var && (long)MeanRefFunch[0] < 230)
		{
			//Light(-)
			diff_var = abs(diff_var);
			if( (abs_thresh) < diff_var)
			{
				concat_obj(ResultRgn, SelectRgn, &ResultRgn);
			}
		}
	
	}
	//
	//
	/////////////////////////////////////////////

/* //CHOKI20110510
	//CHOKI20101103 긁힘 변경 ///////////////////////////////////////
	threshold(ImageReducedLight3,&Light2,HTuple(sr_thresh),HTuple(sr_hi_thresh));

	dilation_rectangle1(Light2, &RegionDilation2, HTuple(2), HTuple(2));
	erosion_rectangle1(RegionDilation2, &RegionErosion2, HTuple(2), HTuple(2));

	connection(RegionErosion2, &RegionErosion2);

	select_shape(RegionErosion2, &SelectRgn2, HTuple("width").Concat("height"), HTuple("or"), HTuple(sr_tol).Concat(sr_tol), HTuple("max").Concat("max"));

	count_obj(SelectRgn2, &Num);

	num = (long)Num[0];

	for(i = 0; i < num; i++)
	{
		select_obj(SelectRgn2, &SelectRgn, i + 1);
		dilation_circle(SelectRgn, &OutRgn, 10);
		difference(OutRgn, SelectRgn, &OutRgn);
//		intensity(SelectRgn, *align_image, &Mean, _);//CHOKI20100726 스크래치의 경우 3번에서 밝고 0번에서 어두움. scratch_image
		intensity(SelectRgn, *mold_image, &Mean, _);//CHOKI20101102
//		intensity(OutRgn, *align_image, &OutMean, _);
		intensity(OutRgn, *mold_image, &OutMean, _);//CHOKI20101102

		intensity(SelectRgn, *scratch_image, &Mean2, _);//CHOKI20101103
		intensity(OutRgn, *scratch_image, &OutMean2, _);//CHOKI20101103

		circularity(SelectRgn, &CircleVar);	

		diff_var = ((long)Mean[0]) - ((long)OutMean[0]);
		diff_var2 = ((long)Mean2[0]) - ((long)OutMean2[0]);

		if(10 < diff_var && 0.5 > (double)CircleVar[0] && 10 < diff_var2)//CHOKI20101103 진원도가 크면 원형의 코팅불량
		{
			concat_obj(ResultRgn, SelectRgn, &ResultRgn);
		}
	}
	//CHOKI20101103 긁힘 변경 ///////////////////////////////////////
*/ //CHOKI20110510


	/////////////////////////////////////////////
	//Light2/////////////////////////////////////
	//긁힘(ink image==crack image)<--crack image에서 밝은 긁힘, 밝은 이물
	set_check("~give_error");
#ifdef AVI_TYPE_1
	herr = hysteresis_threshold(ImageReducedLight2,&Light,HTuple(210),HTuple(220),HTuple(10)); //CHOKI20111004 190->210 200 -> 220		//AVI_TYPE_1//
#else
	herr = hysteresis_threshold(ImageReducedLight2,&Light,HTuple(210),HTuple(230),HTuple(10));
#endif
	set_check("give_error"); 
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_11!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}
	
#ifdef AVI_TYPE_1
	closing_circle(Light, &Light, 30);// 20110530 lee  //CHOKI20111006 80->30 영역을 확장하는 값이 너무 커지면 필터링이 되지 않음. 		//AVI_TYPE_1//
#else
	closing_circle(Light, &Light, 80);// 20110530 lee
#endif
	connection(Light, &Light);
	fill_up(Light, &Light);
#ifndef AVI_TYPE_1
	select_shape(Light, &Light, HTuple("area"), HTuple("and"), HTuple(min_area_sr * 2), HTuple("max"));
	select_shape(Light, &Light, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width_sr * 2).Concat(min_height_sr * 2), HTuple("max").Concat("max"));
#endif
	select_shape(Light, &Light, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance_light).Concat(tolerance_light), HTuple("max").Concat("max"));

	//경계값과 비교
	count_obj(Light, &Num);

	concat_obj(RsltSRRegion, Light, &RsltSRRegion);
	num = (long)Num[0];
	for(i = 0; i < num; i++)
	{
		select_obj(Light, &SelectRgn, i + 1);
		dilation_circle(SelectRgn, &OutRgn, 7); //20110530 lee
		difference(OutRgn, SelectRgn, &OutRgn);
		intensity(SelectRgn, *mold_image, &Mean, _);
		intensity(SelectRgn, RefImageTrans, &MeanRefFunch, _); //CHOKI20110728
		intensity(OutRgn, *mold_image, &OutMean, _);
		diff_var = ((long)OutMean[0]) - ((long)Mean[0]);

		if(0 >= diff_var && (long)MeanRefFunch[0] < 230)
		{
			//Light(-)
			diff_var = abs(diff_var);
			if( (abs_thresh) < diff_var) //CHOKI20110921 결함밝기차가 30에서 20으로 변경해야 검출 가능
			{
				concat_obj(ResultRgn, SelectRgn, &ResultRgn);
			}
		}
	
	}
	//
	//
	/////////////////////////////////////////////


	/* //CHOKI20110510
	/////////////////////////////////////////////
	//Dark-SR out////////////////////////////////
	//긁힘(밝은 back light image에서 검게 나온다. 검은 영역만 잡는다. SR out pattern에서만 검사)
	intensity(ins_rgn_srout, ImageReducedSROut, &Mean, _);
	max = (long)Mean[0];
	max = abs_thresh + 10;
	if(0 > max)
	{
		max = 30;
	}
	if(255 < max)
	{
		max = 255;
	}
	threshold(ImageReducedSROut,&DarkSROut,HTuple(0),HTuple(max));

	closing_circle(DarkSROut, &DarkSROut, 10.5);
	connection(DarkSROut, &DarkSROut);
	//fill_up(DarkSROut, &DarkSROut);



	select_shape(DarkSROut, &DarkSROut, HTuple("area"), HTuple("and"), HTuple(min_area_sr), HTuple("max"));
	select_shape(DarkSROut, &DarkSROut, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width_sr).Concat(min_height_sr), HTuple("max").Concat("max"));
//	select_shape(DarkSROut, &DarkSROut, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));
	
	//경계값과 비교
	count_obj(DarkSROut, &Num);

	concat_obj(RsltSRRegion, DarkSROut, &RsltSRRegion);
	num = (long)Num[0];

	for(i = 0; i < num; i++)
	{
		select_obj(DarkSROut, &SelectRgn, i + 1);
		dilation_circle(SelectRgn, &OutRgn, 7.5);
		dilation_circle(SelectRgn, &IntRgn, 2.5);
		difference(OutRgn, IntRgn, &OutRgn);
		intensity(SelectRgn, ImageReducedSROut, &Mean, _);
		intensity(OutRgn, ImageReducedSROut, &OutMean, _);
		intensity(SelectRgn, ImageLight, &LightMean, _);
		diff_var = ((long)OutMean[0]) - ((long)Mean[0]);
		circularity(SelectRgn, &CircleVar);		
		//크기가 크면 섬세하게 검사
		area_center(SelectRgn, &Area, _, _);

		if(300 < (long)Area[0])
		{
			//밝기
			if(0 < diff_var)
			{
				//Dark(+)
				diff_var = abs(diff_var);
				if(abs_thresh < (diff_var + 10))
				{
					concat_obj(ResultRgn, SelectRgn, &ResultRgn);
				}
			}
		}
		else
		{
			//여기서만 백색 이물 제거 필요(강조를 하다 보니 흰색은 흐리게 나오는데 잡힌다.->오버킬)
			//밝기
			if(0 < diff_var)
			{
				//Dark(+)

				diff_var = abs(diff_var);
				if(abs_thresh < diff_var)
				{
					//진원도가 0.5보다 크면서 백색 이물성이면 오버킬로 간주
					if(0.5 < (double)CircleVar[0] )
					{
						//잉크이미지(크랙이미지)에서 밝값이 밝으면 
						lightvar = (long)LightMean[0];
						if(70 > lightvar)//CHOKI20101103 150->70
						{
							concat_obj(ResultRgn, SelectRgn, &ResultRgn);
						}
					}
					else
					{
						if(70 > lightvar)//CHOKI20101103
						{
							concat_obj(ResultRgn, SelectRgn, &ResultRgn);
						}
					}
				}
			}
		}
	
	}

  */  //CHOKI20110510


//CHOKI20110510 긁힘
	Hobject ReducedRedSR, Sub_RedSR, DiffChipRgnSR, DiffOcvRgnSR, ThreshRedSR, closingRed, dilationRed, ResultRed1, ResultRed2;
	Hobject PatternRgnSR, TransPatternRgn, InvertRgnSR, ThreshPatternRgnSR, dilationPatternSR, DiffPatternSR;	
	reduce_domain(*align_image, ins_rgn_srout2, &ReducedRedSR); //CHOKI20110516 RsltSRRegion -> RsltSROutRegion		110801 cho
	reduce_domain(*align_image2, ins_rgn_srout2, &PatternRgnSR); //CHOKI20110516 RsltSRRegion -> RsltSROutRegion	

//	sub_image(ReducedRedSR, RefReducedSR, &Sub_RedSR, HTuple(0.7), HTuple(10));
	sub_image(ReducedRedSR, RefReducedSR, &Sub_RedSR, HTuple(0.4), HTuple(10)); //20110618 lee SR면 미세한 OVK 발생 

//	difference(Sub_RedSR, ChipRect, &DiffChipRgnSR);
//	difference(DiffChipRgnSR, OCVRegion, &DiffOcvRgnSR);
	set_check("~give_error");
	herr = threshold(Sub_RedSR,&ThreshRedSR,HTuple(45),HTuple(100)); //CHOKI20110511 35->40 //CHOKI20110512 40->45
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_53!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	invert_image(PatternRgnSR, &InvertRgnSR);

	set_check("~give_error");
	herr = threshold(InvertRgnSR,&ThreshPatternRgnSR,HTuple(120),HTuple(255)); //20110516 lee 140 ->120으로 우선 변경 확인 필요 
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_54!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	dilation_circle(ThreshPatternRgnSR, &dilationPatternSR,HTuple(15)); 

//CHOKI20110511 
	dilation_rectangle1(dilationPatternSR, &dilationPatternSR,HTuple(20),HTuple(10));
	dilation_circle(dilationPatternSR, &dilationPatternSR,HTuple(15)); //CHOKI20110513 9->12
	fill_up(dilationPatternSR, &dilationPatternSR);
//CHOKI20110511  
	difference(ThreshRedSR, ChipRect, &DiffChipRgnSR);
	difference(DiffChipRgnSR, OCVRegion, &DiffOcvRgnSR);
	affine_trans_region(dilationPatternSR, &TransPatternRgn, HomMat2D, HTuple("false"));
	difference(DiffOcvRgnSR, TransPatternRgn, &DiffPatternSR);
//	closing_circle(DiffOcvRgnSR, &closingRed, 9.5)
//	dilation_rectangle1(closingRed, &dilationRed, HTuple(3),HTuple(3));
	connection(DiffPatternSR, &DiffPatternSR);
	select_shape(DiffPatternSR, &ResultRed1, HTuple("area"), HTuple("and"), HTuple(10), HTuple("max"));
	select_shape(ResultRed1, &ResultRed1, HTuple("width"), HTuple("and"), HTuple(3), HTuple("max"));
	connection(ResultRed1, &ResultRed1);
	count_obj(ResultRed1, &Num);	
	num = (long)Num[0];
//	concat_obj(ResultRgn, dilationPatternSR, &ResultRgn);//CHOKI20110511 Test
	if(num>0)
	{
		for(i = 0; i < num; i++)
		{
			select_obj(ResultRed1, &SelectRgn, i + 1);
			area_center(SelectRgn, &Area, _, _);
			if(15 < (long)Area[0])
			{
				concat_obj(ResultRgn, SelectRgn, &ResultRgn);		
			}
		}
	}

//CHOKI20110510 긁힘


   //CHOKI20110509 Test
/*
	//CHOKI20110509 긁힘추가 
	Hobject sc_Image, ReducedRedSR, ThreshRedSR, closingRed, dilationRed, ResultRed1, ResultRed2;
	add_image(*align_image, *align_image2, &sc_Image, HTuple(0.5), HTuple(0));  //20100719 lee 1.0 ->0.9
	reduce_domain(sc_Image, ins_rgn, &ReducedRedSR);//reduce_domain(sc_Image, RsltSRRegion, &ReducedRedSR);//ins_rgn
	emphasize(ReducedRedSR, &ReducedRedSR, 3, 3, 3);
	threshold(ReducedRedSR,&ThreshRedSR,HTuple(200),HTuple(210));
	closing_circle(ThreshRedSR, &closingRed, 9.5);
	dilation_rectangle1(closingRed, &dilationRed, HTuple(3),HTuple(3));
	select_shape(dilationRed, &ResultRed1, HTuple("area"), HTuple("and"), HTuple(10), HTuple("max"));
//	select_shape(ResultRed1, &ResultRed2, HTuple("width").Concat("height"), HTuple("and"), HTuple(3).Concat(3), HTuple("max").Concat("max")); 
	connection(ResultRed1, &ResultRed1);
	count_obj(ResultRed1, &Num);	
	num = (long)Num[0];
	if(num>0)
	{
		for(i = 0; i < num; i++)
		{
			select_obj(ResultRed1, &SelectRgn, i + 1);
			area_center(SelectRgn, &Area, _, _);
			if(10 < (long)Area[0])
			{
				concat_obj(ResultRgn, SelectRgn, &ResultRgn);		
			}
		}
	}
	//CHOKI20110509 긁힘추가 
*/
	/////////////////////////////////////////////
	copy_obj(RsltSRRegion, rslt_sr_region, 1, -1);
	copy_obj(RsltNotSRRegion, rslt_notsr_region, 1, -1);
	copy_obj(RsltUserRegion, rslt_user_region, 1, -1);
	copy_obj(ins_rgn_srout2, rslt_sr_out_region, 1, -1);		// 110801 cho

	union1(ResultRgn, &ResultRgn);
	connection(ResultRgn, &ResultRgn);
	count_obj(ResultRgn, &Num);
	*rslt_num = (long)Num[0];
	if(0 < *rslt_num)
	{

		copy_obj(ResultRgn, rslt_region, 1, -1);
		
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(*rslt_region, win);
		}

		return FALSE;
	}

	return TRUE;
}

//CHOKI20100708
BOOL C_VisionModule::_Hal_FindChip(long win, Hobject *image, RECT ins_region, Hobject *rslt_chip_region,
			  long min_area, long min_width, long min_height)
{
	HTuple Width, Height, Row1, Column1, Row2, Column2, Num, Row11, Column11, Row21, Column21;
	HTuple RowBeginT, ColBeginT, RowEndT, ColEndT, Nr, Nc, Dist, RowBeginB, ColBeginB;
	HTuple RowEndB, ColEndB, RowBeginL, ColBeginL, RowEndL, ColEndL, RowBeginR, ColBeginR, RowEndR, ColEndR;
	HTuple RowTL, ColumnTL, IsParallel, RowTR, ColumnTR, RowBL, ColumnBL, RowBR, ColumnBR;

	Hobject Region, ImageReduced, RegionClosing, RegionFillUp, ConnectedRegions, SelectedRegions,SelectedRegions1, RegionUnion;
	Hobject RegionClosing1, RegionGrid, Rectangle1, RegionIntersection, RegionIntersectionVert, Contour;
	Hobject RegionIntersectionHorz, RegionT, RegionB, RegionL, RegionR, RegionTot, ChipRegion;

//	long min;
	HTuple Max, ChipMean;
	CRect rect;

	Hobject RsltChipRgn;
	
	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*image, NULL, NULL, &Width, &Height);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_33!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	gen_rectangle1(&Region, ins_region.top, 
		                    ins_region.left, 
							ins_region.bottom, 
							ins_region.right);

//	reduce_domain(*image,Region,&ImageReduced);

	if(win)
	{
		set_color(win, HTuple("red"));//yellow
		disp_obj(Region, win);
	}


	//Find suitable threshold
	/*
	min_max_gray(Region, *image, HTuple(0), _, &Max, _);
	min = (long)Max[0];
	min = min - 35;
	if( (0 > min) || (255 < min) )
	{
	min = 220;
	}
	*/
	//min = 180;//20110521 lee Chip 못찾으면 아래 fit_line_contour_xld에서 죽는다. 210->190으로 조정 
	intensity(Region, *image, &ChipMean, _);//CHOKI20110527 칩 찾는 밝기값을 가변형으로

	/*
	threshold(ImageReduced,&Region,HTuple(0),HTuple(40));
	closing_circle(Region,&RegionClosing,HTuple(50));
	fill_up(RegionClosing,&RegionFillUp);
	reduce_domain(*image,RegionFillUp,&ImageReduced);
	*/

	long ChipOffset;

	ChipOffset = 100 - (long)ChipMean[0] + 10;

	//20110528 lee
	reduce_domain(*image,Region,&ImageReduced);

	if((long)ChipMean[0] > 140)
	{

		set_check("~give_error");
		herr = threshold(ImageReduced,&Region,HTuple((long)ChipMean[0]+5),HTuple(255)); //20110530 lee
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_55!... %ld", (long)ChipMean[0]);
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}	
	}	
	else
	{
		set_check("~give_error");
		herr = threshold(ImageReduced,&Region,HTuple((long)ChipMean[0]+ ChipOffset),HTuple(255));
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_56!... %ld, %ld", (long)ChipMean[0], (long)ChipOffset);
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}		
	}

	connection(Region,&ConnectedRegions);

	//20110528 lee
	erosion_rectangle1(ConnectedRegions, &ConnectedRegions,5,5); //칩 외각으로 함께 찾아진 SR영역을 분리 

	 //20100713 lee 10000->5000
	select_shape(ConnectedRegions,&SelectedRegions,HTuple("area"),HTuple("and"),HTuple(5000),HTuple("max"));
	select_shape(SelectedRegions,&SelectedRegions1,HTuple("rectangularity"),HTuple("and"),HTuple(0.4),HTuple("max")); //20110605 lee

	//20110528 lee
	dilation_rectangle1(SelectedRegions1, &SelectedRegions1,5,5);//칩 외각으로 함께 찾아진 SR영역을 분리한 만큼 다시 복원 

	union1(SelectedRegions1,&RegionUnion);

	closing_circle(RegionUnion,&RegionClosing1,HTuple(17.5));


	//20100107
	shape_trans(RegionClosing1,&RegionClosing1,HTuple("convex"));

	//Vertical///////////////////////////////////
	gen_grid_region(&RegionGrid,Height,HTuple(2),HTuple("lines"),Width,Height); //CHOKI20110531 5->2

	smallest_rectangle1(RegionClosing1,&Row1,&Column1,&Row2,&Column2);

	count_obj(RegionClosing1, &Num);
	if(1 > (long)Num[0])
	{
		return FALSE;
	}
	
	rect.top = (long)Row1[0];
	rect.left = (long)Column1[0];
	rect.bottom = (long)Row2[0];
	rect.right = (long)Column2[0];
	rect.top = rect.top;// - 50; //CHOKI20110531
	rect.left = rect.left;// + 50;
	rect.bottom = rect.bottom;// + 50;
	rect.right = rect.right;// - 50;

	if( (0 > rect.top) || ((long)Height[0] < rect.top) || (0 > rect.left) || ((long)Width[0] < rect.left) ||
		(0 > rect.bottom) || ((long)Height[0] < rect.bottom) || (0 > rect.right) || ((long)Width[0] < rect.right) )
	{
		return FALSE;
	}

	rect.NormalizeRect();

	gen_rectangle1(&Rectangle1,rect.top, rect.left, rect.bottom, rect.right);
	intersection(RegionGrid,Rectangle1,&RegionIntersection);
	intersection(RegionIntersection,RegionClosing1,&RegionIntersectionVert);
	connection(RegionIntersectionVert,&RegionIntersectionVert);
	select_shape(RegionIntersectionVert,&RegionIntersectionVert,HTuple("area"),HTuple("and"),HTuple(2),HTuple("max"));

	
	count_obj(RegionIntersectionVert, &Num);
	if(1 > (long)Num[0])
	{
		return FALSE;
	}

	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(RegionClosing1, win);
	}

	if(win)
	{
		set_color(win, HTuple("red"));
		disp_obj(RegionIntersectionVert, win);
	}

	smallest_rectangle1(RegionIntersectionVert,&Row11,&Column11,&Row21,&Column21);

	gen_contour_polygon_xld(&Contour,Row11,Column11);
	fit_line_contour_xld(Contour,HTuple("drop"),HTuple(-1),HTuple(0),HTuple(5),HTuple(1.0),&RowBeginT,&ColBeginT,&RowEndT,&ColEndT,&Nr,&Nc,&Dist);

	gen_contour_polygon_xld(&Contour,Row21,Column21);
	fit_line_contour_xld(Contour,HTuple("drop"),HTuple(-1),HTuple(0),HTuple(5),HTuple(1.0),&RowBeginB,&ColBeginB,&RowEndB,&ColEndB,&Nr,&Nc,&Dist);
	
	//Horizental/////////////////////////////////
	gen_grid_region(&RegionGrid,HTuple(2),Width,HTuple("lines"),Width,Height); //20100713 lee 3->2
	smallest_rectangle1(RegionClosing1,&Row1,&Column1,&Row2,&Column2);

	count_obj(RegionClosing1, &Num);
	if(1 > (long)Num[0])
	{
		return FALSE;
	}

	gen_rectangle1(&Rectangle1,Row1+1,Column1,Row2-1,Column2);  //20100713 lee 10->3->5 //CHOKI20110531 Offset 0

	intersection(RegionGrid,Rectangle1,&RegionIntersection);
	intersection(RegionIntersection,RegionClosing1,&RegionIntersectionHorz);
	connection(RegionIntersection,&RegionIntersectionHorz);
	select_shape(RegionIntersectionHorz,&RegionIntersectionHorz,HTuple("area"),HTuple("and"),HTuple(5),HTuple("max"));


	if(win)
	{
		set_color(win, HTuple("cyan"));
		disp_obj(RegionClosing1, win);
	}

	if(win)
	{
		set_color(win, HTuple("blue"));
		disp_obj(RegionIntersectionHorz, win);
	}

	smallest_rectangle1(RegionIntersectionHorz,&Row11,&Column11,&Row21,&Column21);

	gen_contour_polygon_xld(&Contour,Row11,Column11);
	fit_line_contour_xld(Contour,HTuple("drop"),HTuple(-1),HTuple(0),HTuple(5),HTuple(1.0),&RowBeginL,&ColBeginL,&RowEndL,&ColEndL,&Nr,&Nc,&Dist);

	gen_contour_polygon_xld(&Contour,Row21,Column21);
	fit_line_contour_xld(Contour,HTuple("drop"),HTuple(-1),HTuple(0),HTuple(5),HTuple(1.0),&RowBeginR,&ColBeginR,&RowEndR,&ColEndR,&Nr,&Nc,&Dist);

	intersection_ll(RowBeginT,ColBeginT,RowEndT,ColEndT,RowBeginL,ColBeginL,RowEndL,ColEndL,&RowTL,&ColumnTL,&IsParallel);
	intersection_ll(RowBeginT,ColBeginT,RowEndT,ColEndT,RowBeginR,ColBeginR,RowEndR,ColEndR,&RowTR,&ColumnTR,&IsParallel);
	intersection_ll(RowBeginB,ColBeginB,RowEndB,ColEndB,RowBeginL,ColBeginL,RowEndL,ColEndL,&RowBL,&ColumnBL,&IsParallel);
	intersection_ll(RowBeginB,ColBeginB,RowEndB,ColEndB,RowBeginR,ColBeginR,RowEndR,ColEndR,&RowBR,&ColumnBR,&IsParallel);

	if( (0 >= (long)RowTL[0]) || (0 >= (long)ColumnTL[0]) || (0 >= (long)RowTR[0]) || (0 >= (long)ColumnTR[0]) )
	{
		return FALSE;
	}

	if( (0 >= (long)RowBL[0]) || (0 >= (long)ColumnBL[0]) || (0 >= (long)RowBR[0]) || (0 >= (long)ColumnBR[0]) )
	{
		return FALSE;
	}

	if( (((long)Height[0]) <= (long)RowTL[0]) || (((long)Width[0]) <= (long)ColumnTL[0]) || (((long)Height[0]) <= (long)RowTR[0]) || (((long)Width[0]) <= (long)ColumnTR[0]) )
	{
		return FALSE;
	}

	if( (((long)Height[0]) <= (long)RowBL[0]) || (((long)Width[0]) <= (long)ColumnBL[0]) || (((long)Height[0]) <= (long)RowBR[0]) || (((long)Width[0]) <= (long)ColumnBR[0]) )
	{
		return FALSE;
	}

	gen_region_line(&RegionT,RowTL,ColumnTL,RowTR,ColumnTR);
	gen_region_line(&RegionB,RowBL,ColumnBL,RowBR,ColumnBR);
	gen_region_line(&RegionL,RowTL,ColumnTL,RowBL,ColumnBL);
	gen_region_line(&RegionR,RowTR,ColumnTR,RowBR,ColumnBR);
	
	if(win)
	{
		set_color(win, HTuple("orange"));
		disp_obj(RegionT, win);
		disp_obj(RegionB, win);
		disp_obj(RegionL, win);
		disp_obj(RegionR, win);
	}

	union2(RegionT,RegionB,&RegionTot);
	union2(RegionL,RegionTot,&RegionTot);
	union2(RegionR,RegionTot,&RegionTot);
	shape_trans(RegionTot,&RsltChipRgn,HTuple("convex"));//CHOKI20110509
	HTuple AreaChip;
	area_center(RsltChipRgn, &AreaChip, _, _);

//	erosion_circle(RegionTot, &RsltChipRgn, HTuple(1.5));

	if(win)
	{
		set_color(win, HTuple("green"));
		disp_obj(RsltChipRgn, win);
	}

	copy_obj(RsltChipRgn, rslt_chip_region, 1, -1);
	
	return TRUE;
}

//CHOKI20100708
BOOL C_VisionModule::_Hal_ChipPot(long win, Hobject *image, RECT ins_region, long pot_area, int thresh, int under_tol, int over_tol, long *rslt_num, long *rslt_area, Hobject *rslt_region,
			 long min_area, long min_width, long min_height)
{
	Hobject ImageReduced, Region, RegionClosing, InsRegion, RsltRegion;
	HTuple Num;
	long over_area, under_area;

	over_area = pot_area * (over_tol * 0.01);
	under_area = pot_area * (under_tol * 0.01);

	gen_empty_obj(&RsltRegion);

	gen_rectangle1(&InsRegion, ins_region.top, ins_region.left, ins_region.bottom, ins_region.right);

	reduce_domain(*image, InsRegion, &ImageReduced);

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = threshold(ImageReduced,&Region,0,HTuple(thresh));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_57!... %ld", (long)thresh);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	connection(Region, &Region);
	union1(Region, &Region);

	select_shape(Region, &RsltRegion, HTuple("area"), HTuple("and"), HTuple(1), HTuple("max"));

	Hobject select_object;
	HTuple Row1, Column1, Row2, Column2, Area;
	
	*rslt_area = 0;
	count_obj(RsltRegion, &Num);

	*rslt_num = (long)Num[0];
	if(0 < *rslt_num)
	{
		area_center(RsltRegion, &Area, _, _);
		*rslt_area = (long)Area[0];
		if( (over_area > *rslt_area) && (under_area < *rslt_area))
		{
			if(win)
			{
				set_color(win, HTuple("green"));
				disp_obj(RsltRegion, win);
			}
			*rslt_num = 0;

			copy_obj(RsltRegion, rslt_region, 1, -1);
		}
		else
		{
			if(win)
			{
				set_color(win, HTuple("red"));
				disp_obj(RsltRegion, win);
			}

			copy_obj(RsltRegion, rslt_region, 1, -1);
			return FALSE;
		}
	}
	else
	{
		//Chip region
		copy_obj(InsRegion, rslt_region, 1, -1);

		*rslt_num = 1;
		return FALSE;  //CHOKI20110523 FALSE -> TRUE
	}

	return TRUE;
}

//CHOKI20100708
BOOL C_VisionModule::_Hal_FilmPF(long win, Hobject *image, Hobject *image2,  Hobject *Ref_image,//image : back light이미지->전체찢김검사 , image2 : 좀더 밝은 back light이미지->PF영역에서만 검사 //CHOKI20110717 기준이미지와 비교를 위하여 Ref_image 추가
						   Hobject *Ref_image2, //CHOKI20110722
							RECT ins_region, RECT chip_region, Hobject pf_region, Hobject vacc_region,
						   double offset_ox, double offset_oy, 
						   double offset_ox2, double offset_oy2, 
						   double offset_rx, double offset_ry,
						   double offset_rx2, double offset_ry2,
						   int thresh, int high_thresh, int tolerance,
						   long *rslt_num, Hobject *rslt_region, Hobject *rslt_pf_region,
						   long min_area, long min_width, long min_height,
						   long min_area_sr, long min_width_sr, long min_height_sr) 
{
	Hobject Region, SubImage, ImageReduced, RsltRegion, DontCare, ChipRgn, AffineRegion, InsRgn;
	Hobject ImageReduced2, Region2, InsRgn2, RsltRegion2;
	Hobject RefAffinImage, TempResult, SelectRgn; //CHOKI20110717
	HTuple  MeanRef;//CHOKI20110717
	long TempNum;//CHOKI20110717
	Hobject RefAffinImage2; //CHOKI20110722
	HTuple Num, HomMat2D;
	double offset_x, offset_y;
	HTuple DiffAng;
	int threshold, high_threshold;
	HTuple Mean;
	BOOL ResultFlag = TRUE; //CHOKI20110703

	Hobject RsltPFRegion;

	//CHOKI20110727
	Hobject TempRsltRegion1, TempRsltRegion2; 
	long TempRsltRegion1Count, TempRsltRegion2Count;
	TempRsltRegion1Count=0;
	TempRsltRegion2Count=0;
	gen_empty_obj(&TempRsltRegion1);
	gen_empty_obj(&TempRsltRegion2);
	//CHOKI20110727

	gen_empty_obj(&RsltRegion);
	gen_empty_obj(&RsltPFRegion);

	*rslt_num = 0;

	angle_ll(offset_oy, offset_ox, offset_oy2, offset_ox2, offset_ry, offset_rx, offset_ry2, offset_rx2, &DiffAng);

	high_threshold = 255 - thresh;
	threshold = high_threshold - 10; 
	if(0 > threshold)
	{
		threshold = 0;
		high_threshold = 10;
	}
	else if(255 < threshold)
	{
		threshold = 245;
		high_threshold = 255;
	}
	if(0 >= high_threshold) //CHOKI20110705 threshold error관련
	{
		threshold = 0;
		high_threshold = 10;
	}
	else if(255 < high_threshold)
	{
		threshold = 245;
		high_threshold = 255;
	}

	//Offset
	offset_x = offset_rx - offset_ox;
	offset_y = offset_ry - offset_oy;

	gen_rectangle1(&Region, (long)(ins_region.top + offset_y), 
		                    (long)(ins_region.left + offset_x), 
							(long)(ins_region.bottom + offset_y), 
							(long)(ins_region.right + offset_x));

	gen_rectangle1(&ChipRgn, (long)(chip_region.top + offset_y), 
		                    (long)(chip_region.left + offset_x), 
							(long)(chip_region.bottom + offset_y), 
							(long)(chip_region.right + offset_x));

	difference(Region, ChipRgn, &Region);

	vector_angle_to_rigid(offset_oy, offset_ox, HTuple(0), offset_ry, offset_rx, DiffAng, &HomMat2D);
	affine_trans_region(pf_region, &AffineRegion, HomMat2D, HTuple("false"));
	affine_trans_image(*Ref_image, &RefAffinImage, HomMat2D, HTuple("constant"), HTuple("false")); //CHOKI20110717
	affine_trans_image(*Ref_image2, &RefAffinImage2, HomMat2D, HTuple("constant"), HTuple("false")); //CHOKI20110722

	//PF for image///////////////////////////////
	difference(Region, AffineRegion, &RsltPFRegion);
	erosion_circle(RsltPFRegion, &InsRgn, 7.5);
	erosion_rectangle1(InsRgn, &InsRgn, 1, 3.5);

	difference(InsRgn, vacc_region, &InsRgn);

	reduce_domain(*image, InsRgn, &ImageReduced);

	if(threshold >= high_threshold) threshold = high_threshold -10; //20110616 lee //CHOKI20110705

	Herror herr;
	CString status;	
	
	set_check("~give_error");
	herr = hysteresis_threshold(ImageReduced, &TempResult, HTuple(threshold), HTuple(high_threshold), HTuple(30));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_12!... %ld, %ld", (long)threshold, (long)high_threshold);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	closing_circle(TempResult,&TempResult,HTuple(3.5));


	connection(TempResult, &TempResult);
	select_shape(TempResult, &TempResult, HTuple("area"), HTuple("and"), HTuple(tolerance),  HTuple("max"));


	Hobject select_object;
	HTuple Row1, Column1, Row2, Column2;
#ifndef AVI_TYPE_1
	HTuple MeanRed6; //CHOKI20111024


	count_obj(TempResult, &Num);
	//CHOKI20110717
//	*rslt_num = (long)Num[0];
	TempNum = (long)Num[0];
//	if(0 < *rslt_num)
	
	if(0 < TempNum)
	{
		for(int i = 0; i < TempNum; i++)
		{
			select_obj(TempResult, &SelectRgn, i + 1);
			intensity(SelectRgn, RefAffinImage, &MeanRef, _);
#ifdef AVI_TYPE_1
			if((long)MeanRef[0] < 220)		//AVI_TYPE_1//
#else
			intensity(SelectRgn, *image2, &MeanRed6, _); //CHOKI20111024
			if((long)MeanRef[0] < 220 && (long)MeanRed6[0] > 150) //CHOKI20111024 6번 이미지 PF 찢김 기준밝기 150으로 우선 설정됨. 차후변경 가능
#endif
			{
			//	union2(RsltRegion, SelectRgn, &RsltRegion);
				union2(TempRsltRegion1, SelectRgn, &TempRsltRegion1);
				TempRsltRegion1Count++;
			//	if(win)
			//	{
			//		set_color(win, HTuple("red"));
			//		set_draw(win, HTuple("margin"));
			//		disp_obj(RsltRegion, win);
			//	}
			//	ResultFlag = FALSE; //CHOKI20110703
			//	*rslt_num = *rslt_num + 1;
			}
		}
		//if(*rslt_num > 0)
		if(TempRsltRegion1Count >2) //CHOKI20110727 PF찢김관련 수량조건 추가
		{
			union2(RsltRegion, TempRsltRegion1, &RsltRegion);
			connection(RsltRegion, &RsltRegion);
			if(win)
			{
				set_color(win, HTuple("red"));
				set_draw(win, HTuple("margin"));
				disp_obj(RsltRegion, win);
			}
			ResultFlag = FALSE; 
			count_obj(RsltRegion, &Num);
			*rslt_num = (long)Num[0];
		}
	}
	//CHOKI20110717

	//CHOKI20110703
	Hobject DilationTemp, PFinsRgn2, ReducePFinsRgn2, ThreshPFinsRgn2, ConnectPFinsRgn2;
	HTuple  MeanRef2;//CHOKI20110722
	long TempNum2;//CHOKI20110722
	
	dilation_rectangle1(AffineRegion, &DilationTemp, 1, 30);  //CHOKI20110722 50->30
	intersection(DilationTemp, InsRgn, &PFinsRgn2);
	erosion_rectangle1(PFinsRgn2, &PFinsRgn2, 1, 5); //CHOKI20110704

	reduce_domain(*image2, PFinsRgn2, &ReducePFinsRgn2);
//	threshold(ReducePFinsRgn2,&ThreshPFinsRgn2,HTuple(100),HTuple(255));
	set_check("~give_error");
	herr = hysteresis_threshold(ReducePFinsRgn2,&ThreshPFinsRgn2, HTuple(60), HTuple(90), HTuple(30));
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at hysteresis_threshold_13!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	closing_circle(ThreshPFinsRgn2,&ThreshPFinsRgn2,HTuple(3.5));
	connection(ThreshPFinsRgn2, &ConnectPFinsRgn2);
	select_shape(ConnectPFinsRgn2, &ConnectPFinsRgn2, HTuple("area"), HTuple("and"), HTuple(tolerance),  HTuple("max"));
	select_shape(ConnectPFinsRgn2, &ConnectPFinsRgn2, HTuple("height"), HTuple("and"), HTuple(tolerance),  HTuple("max"));

	count_obj(ConnectPFinsRgn2, &Num);

	TempNum2 = (long)Num[0];
	//Hobject TempRsltRegion1, TempRsltRegion2; 
	//long TempRsltRegion1Count, TempRsltRegion2Count;

	if(0 < TempNum2)
	{
		for(int i = 0; i < TempNum2; i++)
		{
			select_obj(ConnectPFinsRgn2, &SelectRgn, i + 1);
			intensity(SelectRgn, RefAffinImage2, &MeanRef2, _);
			if((long)MeanRef2[0] < 100)
			{
				union2(TempRsltRegion2, SelectRgn, &TempRsltRegion2);
				TempRsltRegion2Count++;
			}
		}

		if(TempRsltRegion2Count >2) //CHOKI20110727 PF찢김관련 수량조건 추가
		{
			union2(RsltRegion, TempRsltRegion2, &RsltRegion);
			connection(RsltRegion, &RsltRegion);
			if(win)
			{
				set_color(win, HTuple("red"));
				set_draw(win, HTuple("margin"));
				disp_obj(RsltRegion, win);
			}
			ResultFlag = FALSE; 
			count_obj(RsltRegion, &Num);
			*rslt_num = (long)Num[0];
		}
//		connection(RsltRegion, &RsltRegion); //CHOKI20110727 전단계에서 이미 진행됨.
	}
	
	//CHOKI20110703
	
	copy_obj(RsltRegion, rslt_region, 1, -1);
	copy_obj(RsltPFRegion, rslt_pf_region, 1, -1);
//	return TRUE;
	return ResultFlag; //CHOKI20110703
}

/*
if(GetHalRedImage(cam_idx, buf_idx, 2),//CHOKI20101102
GetHalGreenImage(cam_idx, buf_idx, 3),2
GetHalRedImage(cam_idx, buf_idx, 3),3
GetHalBlueImage(cam_idx, buf_idx, 3),4
GetHalRedImage(cam_idx, buf_idx, 5),5
GetHalGreenImage(cam_idx, buf_idx, 6),6
GetHalBlueImage(cam_idx, buf_idx, 5),7
GetHalGreenImage(cam_idx, buf_idx, 4),8
*/

BOOL C_VisionModule::_Hal_DnLead2(long win, Hobject *image, Hobject *image2, Hobject *image3, 
								  Hobject *image4,   Hobject *image5, Hobject *image6, Hobject *image7,
								  Hobject *image8,
								  RECT ins_region, Hobject not_sr_region,	
								  Hobject dn_region,
								  double offset_ox, double offset_oy, 
								  double offset_ox2, double offset_oy2, 
								  double offset_rx, double offset_ry,
								  double offset_rx2, double offset_ry2,
								  int thres, double factor, int tolerance, 
								  double* line_width_avg, 
								  long *rslt_num, Hobject *rslt_region,  
								  long *rslt_num2, Hobject *rslt_region2,
								  Hobject *rslt_dn_region,
						   long min_area, long min_width, long min_height)
{

	HTuple   Pointer, Type, Width, Height, WindowHandle, Row1;
	HTuple   Column1, Row2, Column2, Row, Sum, Column, Diff;
	HTuple   Length1, UntilHeight, Start, MeasureHandle0, MeasureHandle1;
	HTuple   RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond;
	HTuple   ColumnEdgeSecond, AmplitudeSecond, IntraDistance;
	HTuple   InterDistance, End, Time;
	Hobject  I, InsRegion, Line, TotLine;
	HTuple	 Distance;
//	long idx;
	BOOL rslt = TRUE;
	HTuple HomMat2D;


	HTuple Num;
	Hobject select_object, NotSRRgn , addimage;

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*image,&Pointer,&Type,&Width,&Height);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_34!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}
	
	long row = (ins_region.top + ins_region.bottom) * 0.5;
	long col = ins_region.left + 1;
	long leng1 = (ins_region.bottom - ins_region.top) * 0.5;
	long height = (ins_region.right - ins_region.left) - 1;

	HTuple DiffAng, Area;

	Hobject ImageReduced, SelectRgn;
	Hobject ThreshReduced, ErosionRgn, DilationRgn, ConnectionRgn;

	//CHOKI20101102
	Hobject ImageReduced2, ImageEmphasize, ThreshReduced2, DilationRgn2, RegionClosing, RgnSelect, ConnectionRgn2, SelectRgn2;
	HTuple Mean, MeanG;


//	long i, num;

	Hobject RsltRegion, RsltRegion2, RsltDNRegion;

	gen_empty_obj(&RsltRegion);
	gen_empty_obj(&RsltRegion2);
	gen_empty_obj(&RsltDNRegion);

	//20100718 lee 


	angle_ll(offset_oy, offset_ox, offset_oy2, offset_ox2, offset_ry, offset_rx, offset_ry2, offset_rx2, &DiffAng);
	
	vector_angle_to_rigid(offset_oy, offset_ox, HTuple(0), offset_ry, offset_rx, DiffAng, &HomMat2D);
	affine_trans_region(dn_region, &RsltDNRegion, HomMat2D, HTuple("false"));
	
//	if(0.4 > factor)
//	{
//		factor = 0.4;
//	}
	
	gen_rectangle1(&InsRegion, ins_region.top, ins_region.left, ins_region.bottom, ins_region.right);
	
	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(InsRegion, win);
	}

	gen_empty_obj(&TotLine);
	long line_width = 0;
	long line_idx = 0;
	double dist = 0;


	//CHOKI20101027 image3 : RedImage
	HTuple	MeanRed3; //CHOKI20110712

	reduce_domain(*image3, RsltDNRegion, &ImageReduced);

	set_check("~give_error");
	herr = threshold(ImageReduced,&ThreshReduced,HTuple(0),HTuple(120));//20110611 lee 160 - > 140	// 110802 160 -> 120
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_58!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	erosion_rectangle1(ThreshReduced, &ErosionRgn, 1, 1);
	dilation_rectangle1(ErosionRgn, &DilationRgn, 1, 1);

	connection(DilationRgn, &ConnectionRgn);

	select_shape(ConnectionRgn, &ConnectionRgn, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));
	select_shape(ConnectionRgn, &ConnectionRgn, HTuple("area"), HTuple("and"), HTuple(tolerance), HTuple("max"));

	connection(ConnectionRgn, &ConnectionRgn);	

	count_obj(ConnectionRgn, &Num);

	if(0 < (long)Num[0])
	{
		for(int i = 0; i < (long)Num[0]; i++)
		{
			select_obj(ConnectionRgn, &SelectRgn2, i + 1);
			area_center(SelectRgn2, &Area, _, _);
			intensity(SelectRgn2, *image3, &MeanRed3, _); //CHOKI20110712
			if((long)Area[0] > tolerance && (long)MeanRed3[0] < 110)
			{
				union2(RsltRegion, SelectRgn2, &RsltRegion);
			}
		}	

		connection(RsltRegion, &RsltRegion);
		count_obj(RsltRegion, &Num);

		if(0 < (long)Num[0])			
		{
			if(win)
			{
				set_color(win, HTuple("red"));
				disp_obj(RsltRegion, win);
			}
			rslt = FALSE;
			*rslt_num = (long)Num[0]; 
		}	
	}

	Hobject ErosionRgn7, DilationRgn7;
	Hobject ImageEmphaLeadArea, ImageReducedLeadArea, ImageReducedScratch, RsltRegionScratch,SelectRgnScratch,SelectShapeRgn;
	Hobject ImageReduced8, InvertImage8, ThreshReduced8, ErosionRgn8, DilationRgn8, ClosingRgn8, RsltRegion8, AddImage;
	HTuple MeanG2,DeviG2,Min,Max, MeanR3; //CHOKI20110516
	long ResultCount;
//	long Maxthres;

	//Green 6번에서 리드 영역만 추출 
	
//	emphasize(*image6, &ImageEmphaLeadArea,4,4,1); //20110528 lee //리드 경계를 확실하게 만들자! //CHOKI20110603 ///CHOKI20110603 5->1 empasize 수치가 너무 높을 경우 주변 영역까지 검사범위가 침범됨
//	reduce_domain(ImageEmphaLeadArea, RsltDNRegion, &ImageReduced8);
	
	reduce_domain(*image6, RsltDNRegion, &ImageReduced8);
	emphasize(ImageReduced8, &ImageEmphaLeadArea,4,4,1); //20110528 lee //리드 경계를 확실하게 만들자! //CHOKI20110603 ///CHOKI20110603 5->1 empasize 수치가 너무 높을 경우 주변 영역까지 검사범위가 침범됨

	set_check("~give_error");
	herr = threshold(ImageEmphaLeadArea,&ImageReducedLeadArea,HTuple(0),HTuple(50));  //20110530 lee
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_59!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}	

	erosion_rectangle1(ImageReducedLeadArea, &ImageReducedLeadArea, HTuple(2), HTuple(1));//CHOKI20110604 리드근처에 이물이 발생될 경우 검사영역으로 인식함.
	dilation_rectangle1(ImageReducedLeadArea, &ImageReducedLeadArea, HTuple(1), HTuple(1)); //CHOKI20110801 2,1->1,1

	//리드 긁힘 검출  
	//Green 3번에서 Lead영역만 빼서 검출 한다. //20110525 lee
	reduce_domain(*image2, ImageReducedLeadArea, &ImageReducedScratch); 
	min_max_gray(ImageReducedLeadArea,*image2,HTuple(1),&Min,&Max,_);
	intensity(ImageReducedLeadArea, *image2, &Mean, _);

	long MeanStandard(240); //CHOKI20110818 long MeanStandard(230);
	
	//검사할 Lead의 평균 발기 기준 //리드 영역이 어두운 제품이 있다.
	if(MeanStandard > (long)Mean[0]) 
	{
		//어두우면 Blue 3번으로 검사 한다. 
		add_image(*image2, *image4, &AddImage, 0.5,0);
		reduce_domain(AddImage, ImageReducedLeadArea, &ImageReducedScratch); 
		erosion_rectangle1(ImageReducedLeadArea, &ImageReducedLeadArea, HTuple(1), HTuple(5));
		min_max_gray(ImageReducedLeadArea,ImageReducedScratch,HTuple(0),&Min,&Max,_);
		intensity(ImageReducedLeadArea, ImageReducedScratch, &Mean, _);
		if((long)Mean[0] < 76) //CHOKI20110810 검사를 진행하지 않고 지나감
		{
			//이미지 합성으로 스크레치가 약간 더 어두울 수 있다. 
			set_check("~give_error");
			herr = threshold(ImageReducedScratch,&ImageReducedScratch,HTuple(5),HTuple(10)); //CHOKI20110801 60->70
			set_check("give_error");		
		}
		else
		{
			set_check("~give_error");
			herr = threshold(ImageReducedScratch,&ImageReducedScratch,HTuple(5),HTuple((long)Mean[0] - 70)); //CHOKI20110801 60->70
			set_check("give_error");
		}
		
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_60!... %ld", (long)Mean[0]);
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}		
	}
	else
	{
		set_check("~give_error");
		herr = threshold(ImageReducedScratch,&ImageReducedScratch,HTuple(5),HTuple(170)); //20110618 lee
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_61!");
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}		
	}

	dilation_rectangle1(ImageReducedScratch, &ImageReducedScratch, HTuple(2), HTuple(4)); //CHOKI20110720 4->2
	select_shape(ImageReducedScratch, &ImageReducedScratch, HTuple("area"), HTuple("and"), HTuple(4), HTuple("max"));
	select_shape(ImageReducedScratch, &ImageReducedScratch, HTuple("width"), HTuple("and"), HTuple(2), HTuple("max")); //CHOKI20110720
	connection(ImageReducedScratch, &RsltRegionScratch);
	count_obj(RsltRegionScratch, &Num);

	HTuple lCenterX, lCenterY, lPi, lWidth, lHeight;
	ResultCount = (long)Num[0];
	if(0 < ResultCount)
	{
		for(int i = 0; i < (long)Num[0]; i++)
		{
			select_obj(RsltRegionScratch, &SelectRgnScratch, i + 1);
			smallest_rectangle2(SelectRgnScratch,&lCenterX, &lCenterY,&lPi,&lWidth, &lHeight);  //CHOKI20110603 smallest_rectangle2의 인자값이 반지름이므로 *2해줘야 직ㅁ이 됨
			intensity(SelectRgnScratch, *image3, &Mean, _); //CHOKI20110603 레드3번 이미지에서 한번더 확인함.

			if((double)lWidth[0] > (double)lHeight[0])
			{
				if((double)lWidth[0]*2 > 3 && (long)Mean[0] < 230)
					union2(RsltRegion, SelectRgnScratch, &RsltRegion);
			}
			else if((double)lWidth[0] < (double)lHeight[0])
			{
				if((double)lHeight[0]*2 > 3 && (long)Mean[0] < 230)
					union2(RsltRegion, SelectRgnScratch, &RsltRegion);
			}
			else
			{
				//20110611 lee 3이상으로 변경 
				if((double)lWidth[0]*2 > 3 && (double)lHeight[0]*2 > 3 && (long)Mean[0] < 230)
					union2(RsltRegion, SelectRgnScratch, &RsltRegion);
			}	
		}
		connection(RsltRegion, &RsltRegion);
		count_obj(RsltRegion, &Num);
		if(0 < (long)Num[0])			
		{
			rslt = FALSE;
			*rslt_num += (long)Num[0]; 
		}
	}
	//AVI_TYPE_1//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#ifdef AVI_TYPE_1
	//CHOKI20110928 긁힘 추가
	Hobject ImageReducedLeadArea10, ImageReduced10, ThreshReduced10, ErosionRgn10, ClosingRgn10, RsltRegion10;
	HTuple MeanB10; 
	long ResultCount10;

//	dilation_rectangle1(ImageReducedLeadArea, &ImageReducedLeadArea10, HTuple(3), HTuple(1));

//	reduce_domain(*image7, ImageReducedLeadArea10, &ImageReduced10); 
	reduce_domain(*image7, RsltDNRegion, &ImageReduced10);

	set_check("~give_error");
	herr = threshold(ImageReduced10,&ThreshReduced10,HTuple(210),HTuple(255)); 
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at threshold_62_2!... %ld", (long)thres);
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}

	connection(ThreshReduced10, &ThreshReduced10);

//	closing_rectangle1(ThreshReduced10, &ClosingRgn10, 5, 10);

//	connection(ClosingRgn10, &ClosingRgn10);

	select_shape(ThreshReduced10, &RsltRegion10, HTuple("area"), HTuple("and"), HTuple(tolerance), HTuple("max"));

	connection(RsltRegion10, &RsltRegion10);
	count_obj(RsltRegion10, &Num);
	
	ResultCount10 = (long)Num[0];

	if(0 < ResultCount10)
	{
		for(int i = 0; i < ResultCount10; i++)
		{
			select_obj(RsltRegion10, &SelectRgnScratch, i + 1);
			intensity(SelectRgnScratch, *image3, &Mean, _); 

			if((long)Mean[0] < 180) //CHOKI20111005 230->215		// 111010 ytlee 210 -> 205 //CHOKI20111023 200->180 테스트자국이 1~2개만 검출될경우
			{
				union2(RsltRegion, SelectRgnScratch, &RsltRegion);
			}
		}
		connection(RsltRegion, &RsltRegion);
		count_obj(RsltRegion, &Num);
		if(0 < (long)Num[0])			
		{
			rslt = FALSE;
			*rslt_num += (long)Num[0]; 
		}
	}

	//CHOKI20110928 긁힘 추가
	//AVI_TYPE_1// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#endif
	//리드 오염 검출 
	//Lead영역만 추출한 부분에서만 검사한다. 
	//Blue 5번에서 찾는다. 
//	reduce_domain(*image7, ImageReducedLeadArea, &ImageReduced8); //
	//20110621 lee Green 3번으로 이미지 변경! 필터링 조건 보강으로 Green 3번이 검출 하기 좋음. 
	//Green 3 번에서 찾는다. 
	erosion_rectangle1(ImageReducedLeadArea, &ImageReducedLeadArea, HTuple(2), HTuple(1));
//	reduce_domain(*image8, ImageReducedLeadArea, &ImageReduced8); //CHOKI20110921
	reduce_domain(*image2, ImageReducedLeadArea, &ImageReduced8); 
	intensity(ImageReducedLeadArea, ImageReduced8, &Mean, _);

//	invert_image(ImageReduced8, &InvertImage8);
//	threshold(InvertImage8,&ThreshReduced8,HTuple(thres + 50),HTuple(255));
	if((long)Mean[0] < 220) //CHOKI20110818 형식 정리
	{
		set_check("~give_error");
#ifdef AVI_TYPE_1
		herr = threshold(ImageReduced8,&ThreshReduced8,HTuple(0),HTuple(thres+30)); //CHOKI20110822 50->30 리드부분의 밝기가 떨어짐으로 인한 과검으로 인하여 기준을 낮춤	//AVI_TYPE_1//
#else
		herr = threshold(ImageReduced8,&ThreshReduced8,HTuple(0),HTuple(thres+50)); //CHOKI20110822 60->50 리드부분의 밝기가 떨어짐으로 인한 과검으로 인하여 기준을 낮춤

		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_62!... %ld", (long)thres);
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}		
	}
	else
	{
		set_check("~give_error");
		herr = threshold(ImageReduced8,&ThreshReduced8,HTuple(0),HTuple(thres+70)); //20110621 lee 미검 발생 조건 상승 
		set_check("give_error");
		if(H_MSG_TRUE == herr)
		{
		}
		else
		{
			status.Format("Halcon Error Occured at threshold_63!... %ld", (long)thres);
			WriteErrorList((LPCTSTR)status);
			return FALSE;
		}		
	}
#ifdef AVI_TYPE_1
	erosion_rectangle1(ThreshReduced8, &ErosionRgn8, HTuple(2), HTuple(2)); //CHOKI20110818 2->1 //CHOKI20110822 X 1->2	//CHOKI20111018 1->2	//AVI_TYPE_1//
#else
	erosion_rectangle1(ThreshReduced8, &ErosionRgn8, HTuple(1), HTuple(2)); //CHOKI20110818 2->1 //CHOKI20110822 X 1->2
#endif
	dilation_rectangle1(ErosionRgn8, &DilationRgn8, HTuple(1), HTuple(2));  //CHOKI20110715 2->1

	connection(DilationRgn8, &DilationRgn8);
	
	select_shape(DilationRgn8, &RsltRegion8, HTuple("area"), HTuple("and"), HTuple(tolerance), HTuple("max"));

	connection(RsltRegion8, &RsltRegion8);
	count_obj(RsltRegion8, &Num);
	
	ResultCount = (long)Num[0];

	HTuple Devi2, Mean3, Devi3;
	
	if(0 < ResultCount)
	{
		for(int i = 0; i < (long)Num[0]; i++)
		{
			select_obj(RsltRegion8, &SelectRgn2, i + 1);

		//	intensity(SelectRgn2, *image5, &MeanG2, &Devi2); //CHOKI20110818 검사 조건에서 일단 제거
			intensity(SelectRgn2, *image7, &Mean3, &Devi3);  //CHOKI20110818 *image->*image7
			intensity(SelectRgn2, *image3, &MeanR3, _);
			area_center(SelectRgn2, &Area, _, _);

			//20110621 lee 미검 발생 
			//if((long)Area[0] > 40 && (long)MeanG2[0] < 180 && (long)Mean3[0] < 160 && (long)MeanR3[0] < 185) //CHOKI20110608 //CHOKI220616 Mean3 추가
#ifdef AVI_TYPE_1
			if((long)Area[0] > 30 && (long)Mean3[0] < 130 && (long)MeanR3[0] < 190) //CHOKI20110818 //CHOKI20110820 190->200	// 110821 ytlee 200 ->170	//111007 ytlee 210 -> 190	//AVI_TYPE_1//
#else
			if((long)Area[0] > 30 && (long)Mean3[0] < 150 && (long)MeanR3[0] < 170) //CHOKI20110818 //CHOKI20110820 190->200	// 110821 ytlee 200 ->170

			{ //CHOKI20110921 ((long)MeanR3[0] < 170)제거, 150->140 //CHOKI20110923 ((long)MeanR3[0] < 210) 다시 추가 	//111024 ytlee 140 -> 130
				union2(RsltRegion, SelectRgn2, &RsltRegion); //CHOKI20110925 (long)Mean3[0] < 140->160
			}
			//CHOKI20111012 리드의 변색과 비슷하나 원자재성 불량으로 양품수준으로 여사원판단됨.
		//	else if((long)Area[0] > 50 && (long)Mean3[0] < 220 && (long)MeanR3[0] > 205) //CHOKI20110818 //CHOKI20110820 190->200	// 110821 ytlee 200 ->170	//111007 ytlee 210 -> 190
		//	{ //CHOKI20110921 ((long)MeanR3[0] < 170)제거, 150->140 //CHOKI20110923 ((long)MeanR3[0] < 210) 다시 추가
		//		union2(RsltRegion, SelectRgn2, &RsltRegion); //CHOKI20110925 (long)Mean3[0] < 140->160
		//	}
		}	
		connection(RsltRegion, &RsltRegion);
		count_obj(RsltRegion, &Num);
		if(0 < (long)Num[0])			
		{
			rslt = FALSE;
			*rslt_num += (long)Num[0]; 
		}	
	}
	
	copy_obj(RsltRegion, rslt_region, 1, -1);
	copy_obj(RsltDNRegion, rslt_dn_region, 1, -1);
		
	return rslt;

}

//CHOKI20100708
//BOOL C_VisionModule::_Hal_DnLead(long win, Hobject *image, Hobject *image2, RECT ins_region, Hobject not_sr_region,	
BOOL C_VisionModule::_Hal_DnLead(long win, Hobject *image, Hobject *image2, Hobject *image3, RECT ins_region, Hobject not_sr_region,	
							Hobject dn_region,
							double offset_ox, double offset_oy, 
							double offset_ox2, double offset_oy2, 
							double offset_rx, double offset_ry,
							double offset_rx2, double offset_ry2,
						   int thres, double factor, int tolerance, 
						   double* line_width_avg, 
						   long *rslt_num, Hobject *rslt_region,  
						   long *rslt_num2, Hobject *rslt_region2,
						   Hobject *rslt_dn_region,
						   long min_area, long min_width, long min_height)
{

	HTuple   Pointer, Type, Width, Height, WindowHandle, Row1;
	HTuple   Column1, Row2, Column2, Row, Sum, Column, Diff;
	HTuple   Length1, UntilHeight, Start, MeasureHandle0, MeasureHandle1;
	HTuple   RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond;
	HTuple   ColumnEdgeSecond, AmplitudeSecond, IntraDistance;
	HTuple   InterDistance, End, Time;
	Hobject  I, InsRegion, Line, TotLine;
	HTuple	 Distance;
	long idx;
	BOOL rslt = TRUE;
	HTuple HomMat2D;

	HTuple Num;
	Hobject select_object, NotSRRgn , addimage;

	Herror herr;
	CString status;

	set_check("~give_error");
	herr = get_image_pointer1(*image,&Pointer,&Type,&Width,&Height);
	set_check("give_error");
	if(H_MSG_TRUE == herr)
	{
	}
	else
	{
		status.Format("Halcon Error Occured at get_image_pointer1_35!");
		WriteErrorList((LPCTSTR)status);
		return FALSE;
	}
	
	long row = (ins_region.top + ins_region.bottom) * 0.5;
	long col = ins_region.left + 1;
	long leng1 = (ins_region.bottom - ins_region.top) * 0.5;
	long height = (ins_region.right - ins_region.left) - 1;

	HTuple DiffAng, Area;

	Hobject InterRgn, SelectRgn;

	long i, num;

	Hobject RsltRegion, RsltRegion2, RsltDNRegion;

	gen_empty_obj(&RsltRegion);
	gen_empty_obj(&RsltRegion2);
	gen_empty_obj(&RsltDNRegion);

	//20100718 lee 
//	add_image(*image, *image2, &addimage, HTuple(1.0), HTuple(0));
//	invert_image(addimage,&addimage);

	angle_ll(offset_oy, offset_ox, offset_oy2, offset_ox2, offset_ry, offset_rx, offset_ry2, offset_rx2, &DiffAng);
	
	vector_angle_to_rigid(offset_oy, offset_ox, HTuple(0), offset_ry, offset_rx, DiffAng, &HomMat2D);
	affine_trans_region(dn_region, &RsltDNRegion, HomMat2D, HTuple("false"));
	
	if(0.4 > factor)
	{
		factor = 0.4;
	}
	
	gen_rectangle1(&InsRegion, ins_region.top, ins_region.left, ins_region.bottom, ins_region.right);
	
	if(win)
	{
		set_color(win, HTuple("yellow"));
		disp_obj(InsRegion, win);
	}

	gen_empty_obj(&TotLine);
	long line_width = 0;
	long line_idx = 0;
	double dist = 0;


	//Image//////////////////////////////////////
	gen_measure_rectangle2(row,col,HTuple(1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
	gen_measure_rectangle2(row,col,HTuple(-1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);

	for(idx=1; idx<=height; idx+=1)
	{
		translate_measure(MeasureHandle0, row, col + idx);
		//gen_measure_rectangle2(row,col + idx,HTuple(1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
		//합성 이미지로 검사 
		measure_pos(*image, MeasureHandle0, HTuple(factor), HTuple(thres), HTuple("all"), HTuple("all"),
			            &RowEdgeFirst,&ColumnEdgeFirst,&AmplitudeFirst,&InterDistance);
		
		translate_measure(MeasureHandle1, row, col + idx);
		//gen_measure_rectangle2(row,col + idx,HTuple(-1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);
		measure_pos(*image, MeasureHandle1, HTuple(factor), HTuple(thres), HTuple("all"), HTuple("all"),
			            &RowEdgeSecond,&ColumnEdgeSecond,&AmplitudeFirst,&InterDistance);

		if(0 < RowEdgeFirst.Num())
		{
			gen_region_points(&Line, RowEdgeFirst,ColumnEdgeFirst);
			
			//concat_obj(TotLine, Line, &TotLine);
			union2(TotLine, Line, &TotLine);

			if(win)
			{
				set_color(win, HTuple("green"));
				disp_obj(Line, win);
			}
		}

		if(0 < RowEdgeSecond.Num())
		{
			gen_region_points(&Line, RowEdgeSecond,ColumnEdgeSecond);

			//concat_obj(TotLine, Line, &TotLine);
			union2(TotLine, Line, &TotLine);

			if(win)
			{
				set_color(win, HTuple("blue"));
				disp_obj(Line, win);
			}
		}
	}

	close_measure(MeasureHandle0);
	close_measure(MeasureHandle1);

	connection(TotLine, &TotLine);

	dilation_rectangle1(RsltDNRegion, &RsltDNRegion, 1, 2.5);
	intersection(TotLine, RsltDNRegion, &TotLine);




	//이진화 방식으로 얻은 영역과 에지측정으로 얻은 영역의 교집합이 존재하는 조건
	count_obj(TotLine, &Num);
	num = (long)Num[0];
	if(0 < num)
	{
		union1(TotLine, &TotLine);
		intersection(not_sr_region, RsltDNRegion, &NotSRRgn);
		connection(NotSRRgn, &NotSRRgn);
		count_obj(NotSRRgn, &Num);
		gen_empty_obj(&InterRgn);
		num = (long)Num[0];
		for(i = 0; i < num; i++)
		{
			select_obj(NotSRRgn, &SelectRgn, i + 1);
			intersection(TotLine, SelectRgn, &InterRgn);
			area_center(InterRgn, &Area, _, _);
			if(1 < (long)Area[0])
			{
				union2(TotLine, NotSRRgn, &TotLine);
			}
		}
	}


	union1(TotLine, &TotLine);
	//union2(TotLine, DynRegion, &TotLine);

//	closing_circle(TotLine, &TotLine, HTuple(5.5));
	closing_circle(TotLine, &TotLine, HTuple(3));
	//closing_rectangle1(TotLine, &TotLine, 1, 25.5);

	connection(TotLine, &TotLine);
	select_shape(TotLine, &TotLine, HTuple("area"), HTuple("and"), HTuple(min_area), HTuple("max"));
	select_shape(TotLine, &TotLine, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width).Concat(min_height), HTuple("max").Concat("max"));
	select_shape(TotLine, &RsltRegion, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));


	//Image2/////////////////////////////////////
	gen_empty_obj(&Line);
	gen_empty_obj(&TotLine);

	gen_measure_rectangle2(row,col,HTuple(1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
	gen_measure_rectangle2(row,col,HTuple(-1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);

	for(idx=1; idx<=height; idx+=1)
	{
		translate_measure(MeasureHandle0, row, col + idx);
		//gen_measure_rectangle2(row,col + idx,HTuple(1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle0);
		measure_pos(*image2, MeasureHandle0, HTuple(factor), HTuple(thres), HTuple("all"), HTuple("all"),
			            &RowEdgeFirst,&ColumnEdgeFirst,&AmplitudeFirst,&InterDistance);
		
		translate_measure(MeasureHandle1, row, col + idx);
		//gen_measure_rectangle2(row,col + idx,HTuple(-1.57079632679),leng1,HTuple(1),Width,Height,HTuple("nearest_neighbor"),&MeasureHandle1);
		measure_pos(*image2, MeasureHandle1, HTuple(factor), HTuple(thres), HTuple("all"), HTuple("all"),
			            &RowEdgeSecond,&ColumnEdgeSecond,&AmplitudeFirst,&InterDistance);

		if(0 < RowEdgeFirst.Num())
		{
			gen_region_points(&Line, RowEdgeFirst,ColumnEdgeFirst);
			
			//concat_obj(TotLine, Line, &TotLine);
			union2(TotLine, Line, &TotLine);

			if(win)
			{
				set_color(win, HTuple("green"));
				disp_obj(Line, win);
			}
		}

		if(0 < RowEdgeSecond.Num())
		{
			gen_region_points(&Line, RowEdgeSecond,ColumnEdgeSecond);

			//concat_obj(TotLine, Line, &TotLine);
			union2(TotLine, Line, &TotLine);

			if(win)
			{
				set_color(win, HTuple("blue"));
				disp_obj(Line, win);
			}
		}
	}

	close_measure(MeasureHandle0);
	close_measure(MeasureHandle1);

	connection(TotLine, &TotLine);

	intersection(TotLine, RsltDNRegion, &TotLine);



	//이진화 방식으로 얻은 영역과 에지측정으로 얻은 영역의 교집합이 존재하는 조건
	count_obj(TotLine, &Num);
	num = (long)Num[0];
	if(0 < num)
	{
		union1(TotLine, &TotLine);
		intersection(not_sr_region, RsltDNRegion, &NotSRRgn);
		connection(NotSRRgn, &NotSRRgn);
		count_obj(NotSRRgn, &Num);
		gen_empty_obj(&InterRgn);
		num = (long)Num[0];
		for(i = 0; i < num; i++)
		{
			select_obj(NotSRRgn, &SelectRgn, i + 1);
			intersection(TotLine, SelectRgn, &InterRgn);
			area_center(InterRgn, &Area, _, _);
			if(1 < (long)Area[0])
			{
				union2(TotLine, NotSRRgn, &TotLine);
			}
		}
	}

	union1(TotLine, &TotLine);
	//union2(TotLine, DynRegion, &TotLine);

//	closing_circle(TotLine, &TotLine, HTuple(5.5));
	closing_circle(TotLine, &TotLine, HTuple(3));
	//closing_rectangle1(TotLine, &TotLine, 1, 25.5);

	connection(TotLine, &TotLine);
	select_shape(TotLine, &TotLine, HTuple("area"), HTuple("and"), HTuple(min_area), HTuple("max"));
	select_shape(TotLine, &TotLine, HTuple("width").Concat("height"), HTuple("and"), HTuple(min_width).Concat(min_height), HTuple("max").Concat("max"));
	select_shape(TotLine, &RsltRegion2, HTuple("width").Concat("height"), HTuple("or"), HTuple(tolerance).Concat(tolerance), HTuple("max").Concat("max"));

	//Image//////////////////////////////////////
	count_obj(RsltRegion, &Num);

	*rslt_num = (long)Num[0];

	//CHOKI20101005 핀 테스트 흔적 검출방지 코드
	BOOL PinTestCheck = FALSE;
	HTuple PinRow1, PinRow2, PinDist;
	double SumPinDist = 0.0;
	double AvgePinDist = 0.0;

	if(3 < *rslt_num)
	{
		for(int i = 0; i < (long)Num[0] -1; i++)
		{
			select_obj(RsltRegion, &SelectRgn, i + 1);
			area_center(SelectRgn, _, &PinRow1, _);

			select_obj(RsltRegion, &SelectRgn, i + 2);
			area_center(SelectRgn, _, &PinRow2, _);

			distance_pp(PinRow1, HTuple(0), PinRow2, HTuple(0), &PinDist);

			SumPinDist += (double)PinDist[0];
		}

		AvgePinDist = SumPinDist / ((long)Num[0]-1);

		if(AvgePinDist < 2)
		{
			gen_empty_obj(&RsltRegion);
		}
	}
	//CHOKI20101005

	else if(0 < *rslt_num)
	{
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(RsltRegion, win);
		}

		rslt = FALSE;

	}

	copy_obj(RsltRegion, rslt_region, 1, -1);
		

	//Image2/////////////////////////////////////
	count_obj(RsltRegion2, &Num);

	*rslt_num2 = (long)Num[0];

	//CHOKI20101005 핀 테스트 흔적 검출방지 코드
	SumPinDist = 0.0;
	AvgePinDist = 0.0;

	if(3 < *rslt_num2)
	{
		for(int i = 0; i < (long)Num[0] -1; i++)
		{
			select_obj(RsltRegion2, &SelectRgn, i + 1);
			area_center(SelectRgn, _, &PinRow1, _);

			select_obj(RsltRegion2, &SelectRgn, i + 2);
			area_center(SelectRgn, _, &PinRow2, _);

			distance_pp(PinRow1, HTuple(0), PinRow2, HTuple(0), &PinDist);

			SumPinDist += (double)PinDist[0];
		}

		AvgePinDist = SumPinDist / ((long)Num[0]-1);

		if(AvgePinDist < 2)
		{
			gen_empty_obj(&RsltRegion);
		}
	}
	//CHOKI20101005

	else if(0 < *rslt_num2)
	{
		if(win)
		{
			set_color(win, HTuple("red"));
			disp_obj(RsltRegion2, win);
		}

		rslt = FALSE;
	}
	copy_obj(RsltRegion2, rslt_region2, 1, -1);

	copy_obj(RsltDNRegion, rslt_dn_region, 1, -1);

	close_all_measures();

	return rslt;
}
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 110720 ytlee
void C_VisionModule::WriteErrorList(LPCTSTR lpszItem)
{
	//Log
	SYSTEMTIME	lpSystemTime;
	GetLocalTime(&lpSystemTime);
	char path[MAX_PATH];
	char temp[DAT_STR_LENG];
	char name[DAT_STR_LENG];
	CString Dir;

	memset(temp, NULL, DAT_STR_LENG);
	sprintf(temp, "[%02d:%02d:%02d]%s", lpSystemTime.wHour, lpSystemTime.wMinute, lpSystemTime.wSecond, lpszItem);

	memset(name, NULL, sizeof(temp));
	sprintf(name, "Error_Log_%04d%02d%02d.txt", lpSystemTime.wYear, lpSystemTime.wMonth, lpSystemTime.wDay);

	memset(path, NULL, MAX_PATH);
	sprintf(path, "E:\\Insp_Result\\%04d%02d%02d\\SYSTEM_LOG\\", lpSystemTime.wYear, lpSystemTime.wMonth, lpSystemTime.wDay);

	Dir.Format("%s", path);
	MakeDirectories(Dir);

	WriteErrorStatus(path, name, "Error_Log.bak", temp, 0);
}
BOOL C_VisionModule::WriteErrorStatus(CString path, CString file, CString bak_file, CString log, long limit_line)
{
	// check message level
	FILE*	stream;
	char	strFile[MAX_PATH], strToFile[MAX_PATH];
    long	result, line;
	char	szTime[DAT_STR_LENG]; 

	char buffer[DAT_STR_LENG];

	SYSTEMTIME	lpSystemTime;
	GetLocalTime(&lpSystemTime);

	sprintf(strFile, "%s\\%s", path, file); 

	if((stream = fopen( strFile, "a+" )) == NULL)
	{
		HANDLE fd = CreateFile( strFile,
							GENERIC_READ|GENERIC_WRITE,
							//GENERIC_WRITE,
							FILE_SHARE_READ|FILE_SHARE_WRITE,
							NULL,
							OPEN_ALWAYS,
							FILE_ATTRIBUTE_NORMAL,
							NULL
							);
		stream = fopen( strFile, "a+" );
		if(stream == NULL)
		{
			AfxMessageBox("Error : log file open fail!" );
			CloseHandle(fd);
			return FALSE;
		}

		CloseHandle(fd);
	}

	//Check first time
    result = fseek(stream, 0L, SEEK_SET);
    if(result)
	{
		fclose(stream);
		return FALSE;
	}
	line = 0;
	while(fgets(buffer, DAT_STR_LENG, stream)) 
	{
		line++;
		if(1 < line)
		{
			break;
		}
	}

    result = fseek(stream, 0L, SEEK_END);
    if(result)
	{
		fclose(stream);
		return FALSE;
	}

	memset(szTime, NULL, sizeof(szTime));
	sprintf(szTime, "%s", log);
    fputs(szTime, stream);
	fputs("\n", stream);

    result = fseek(stream, 0L, SEEK_SET);
    if(result)
	{
		fclose(stream);
		return FALSE;
	}

	//Check limit line
	line = 0;
	if(limit_line)
	{
		while(fgets(buffer, DAT_STR_LENG, stream)) line++;
		if(line > limit_line)
		{
			sprintf(strToFile, "%s\\%s", path, bak_file); 
			CopyFile(strFile, strToFile, FALSE);
			fclose(stream);
			DeleteFile(strFile);
		}
		else
		{
			fclose(stream);
		}
	}
	else
	{
		fclose(stream);
	}

	return TRUE;
}
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	110723 ytlee 체크 항목 모델별로 로드 위치 이동		
BOOL C_VisionModule::LoadInspectSelectPara(CString path)
{
	BOOL rslt = TRUE;
	CString key, dat;
	int i, j;
	CString file_path, pat_path, extention, master_path;
	
	file_path = path + "\\InspectionSel.par";
	
	//file 존재 확인 
	HANDLE fd = CreateFile( file_path,
		GENERIC_READ|GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);
	if(((LONG)fd)<0)
	{
		rslt = FALSE;
	}
	else
	{
		CloseHandle(fd);
		
		for(i = 0; i < IMG_RECT_MAX_NUM; i++)
		{
			switch(i)
			{
			case 0:
				for(j = 0; j < BOOL_PARA_MAX_NUM_SYS; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_Sys%d", i, j);
					m_VDat[i]->m_SysPara.m_bPara[j] = GetPrivateProfileInt("INSPECTION_SELECT_PARAMETER", key, 0, file_path);
				}
			}
		}
	}
	fd=0;
	
	return rslt;
}
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 110723 ytlee 체크 항목 모델별로 저장
BOOL C_VisionModule::SaveInspectSelectPara(CString path)
{
	BOOL rslt = TRUE;
	CString key, dat;
	int i, j;
	CString file_path, pat_path, extention, master_path;
	
	//Make director
	MakeDirectories(path);
	
	file_path = path + "\\InspectionSel.par";
	
	//file 존재 확인 
	HANDLE fd=CreateFile(   file_path,
		GENERIC_READ|GENERIC_WRITE,
		0,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);
	if(((LONG)fd)<0)
	{
		rslt = FALSE;
	}
	else
	{
		CloseHandle(fd);
		
		//write INI
		
		for(i = 0; i < IMG_RECT_MAX_NUM; i++)
		{
			
			switch(i)
			{
			case 0:
				for(j = 0; j < BOOL_PARA_MAX_NUM_SYS; j++)
				{
					key.Empty();
					key.Format("CAM%d_bPara_Sys%d", i, j);
					dat.Empty();
					dat.Format("%d", m_VDat[i]->m_SysPara.m_bPara[j]);
					WritePrivateProfileString("INSPECTION_SELECT_PARAMETER", key, dat, file_path);
				}
			}
		}
		
	}
	fd=0;
	
	return rslt;
}

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	110801 ytlee
BOOL C_VisionModule::CheckInspectInitPara(CString path)
{
	BOOL rslt = TRUE;
	CString key, dat, add_str, file_path, initname;
	char temp[256];
	int i, j, initval;
	double initval2;

	file_path = path + "\\InspectionInit.par";
	//file 존재 확인 
	HANDLE fd=CreateFile(   file_path,
		GENERIC_READ|GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);
	if(((LONG)fd)<0)
	{
		rslt = FALSE;
	}
	else
	{
		CloseHandle(fd);
		//write INI
		for(i = 0; i < IMG_RECT_MAX_NUM; i++)
		{
			switch(i)
			{
			case 0:
				//Align//////////////////////////////
				for(j = 0; j < INT_PARA_MAX_NUM_ALIGN; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Align%d", i, j);
					initval = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);

					if(!(m_VDat[i]->m_InsPara.m_iParaAlign[j] == initval))
					{
						key.Empty();
						key.Format("CAM%d_cPara_Align%d", i, j);
						GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
						initname.Format("%s", temp);

						add_str.Format("[%s] 값이 초기값(%d)과 일치 하지 않습니다. 변경하시겠습니까?", initname, initval);
						if(IDYES == MessageBox(NULL,add_str, "변경", MB_YESNO) )
						{
							m_VDat[i]->m_InsPara.m_iParaAlign[j] = initval;
						}
						else
						{
						}
					}
				}
				//Chip///////////////////////////////
				for(j = 0; j < INT_PARA_MAX_NUM_CHIP; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Chip%d", i, j);
					initval = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);

					if(j == 4 || j == 11 || j == 12)
					{
						continue;
					}
					if(!(m_VDat[i]->m_InsPara.m_iParaChip[j] == initval))
					{
						key.Empty();
						key.Format("CAM%d_cPara_Chip%d", i, j);
						GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
						initname.Format("%s", temp);

						add_str.Format("[%s] 값이 초기값(%d)과 일치 하지 않습니다. 변경하시겠습니까?", initname, initval);
						if(IDYES == MessageBox(NULL,add_str, "변경", MB_YESNO) )
						{
							m_VDat[i]->m_InsPara.m_iParaChip[j] = initval;
						}
						else
						{
						}
					}
				}
				//Lead///////////////////////////////
				for(j = 0; j < INT_PARA_MAX_NUM_LEAD; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Lead%d", i, j);
					initval = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);

					if(j ==3)
					{
						continue;
					}
					if(!(m_VDat[i]->m_InsPara.m_iParaLead[j] == initval))
					{
						key.Empty();
						key.Format("CAM%d_cPara_Lead%d", i, j);
						GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
						initname.Format("%s", temp);

						add_str.Format("[%s] 값이 초기값(%d)과 일치 하지 않습니다. 변경하시겠습니까?", initname, initval);
						if(IDYES == MessageBox(NULL,add_str, "변경", MB_YESNO) )
						{
							m_VDat[i]->m_InsPara.m_iParaLead[j] = initval;
						}
						else
						{
						}
					}
				}
				for(j = 0; j < DBL_PARA_MAX_NUM_LEAD; j++)
				{
					key.Empty();
					key.Format("CAM%d_dPara_Lead%d", i, j);
					GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
					initval2 = atof(temp);

					if(!(m_VDat[i]->m_InsPara.m_dParaLead[j] == initval2))
					{
						key.Empty();
						key.Format("CAM%d_cdPara_Lead%d", i, j);
						GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
						initname.Format("%s", temp);

						add_str.Format("[%s] 값이 초기값(%f)과 일치 하지 않습니다. 변경하시겠습니까?", initname, initval2);
						if(IDYES == MessageBox(NULL,add_str, "변경", MB_YESNO) )
						{
							m_VDat[i]->m_InsPara.m_dParaLead[j] = initval2;
						}
						else
						{
						}
					}
				}
				//Film///////////////////////////////
				for(j = 0; j < INT_PARA_MAX_NUM_FILM; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_Film%d", i, j);
					initval = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);

					if(j == 4)
					{
						continue;
					}
					if(!(m_VDat[i]->m_InsPara.m_iParaFilm[j] == initval))
					{
						key.Empty();
						key.Format("CAM%d_cPara_Film%d", i, j);
						GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
						initname.Format("%s", temp);

						add_str.Format("[%s] 값이 초기값(%d)과 일치 하지 않습니다. 변경하시겠습니까?", initname, initval);
						if(IDYES == MessageBox(NULL,add_str, "변경", MB_YESNO) )
						{
							m_VDat[i]->m_InsPara.m_iParaFilm[j] = initval;
						}
						else
						{
						}
					}
				}
				//OCV////////////////////////////////
				for(j = 0; j < INT_PARA_MAX_NUM_OCV; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_OCV%d", i, j);
					initval = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);

					if(j > 1)
					{
						continue;
					}
					if(!(m_VDat[i]->m_InsPara.m_iParaOCV[j] == initval))
					{
						key.Empty();
						key.Format("CAM%d_cPara_OCV%d", i, j);
						GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
						initname.Format("%s", temp);

						add_str.Format("[%s] 값이 초기값(%d)과 일치 하지 않습니다. 변경하시겠습니까?", initname, initval);
						if(IDYES == MessageBox(NULL,add_str, "변경", MB_YESNO) )
						{
							m_VDat[i]->m_InsPara.m_iParaOCV[j] = initval;
						}
						else
						{
						}
					}
				}
				//PPunch(펀칭부)/////////////////////
				for(j = 0; j < INT_PARA_MAX_NUM_PPUNCH; j++)
				{
					key.Empty();
					key.Format("CAM%d_iPara_PPUNCH%d", i, j);
					initval = GetPrivateProfileInt("INSPECTION_PARAMETER", key, 0, file_path);

					if(!(m_VDat[i]->m_InsPara.m_iParaPPunch[j] == initval))
					{
						key.Empty();
						key.Format("CAM%d_cPara_PPUNCH%d", i, j);
						GetPrivateProfileString("INSPECTION_PARAMETER", key, "0.0", temp, sizeof(temp), file_path);
						initname.Format("%s", temp);

						add_str.Format("[%s] 값이 초기값(%d)과 일치 하지 않습니다. 변경하시겠습니까?", initname, initval);
						if(IDYES == MessageBox(NULL,add_str, "변경", MB_YESNO) )
						{
							m_VDat[i]->m_InsPara.m_iParaPPunch[j] = initval;
						}
						else
						{
						}
					}
				}
			}
		}
	}
	fd=0;

	return rslt;
}
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<